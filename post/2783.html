<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <meta name="google-site-verification" content="kJUjgbvECplcwB4X3hhAHUuG5Bfr2JLsTpEMZ6fRR-o">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux调度算法">
<meta property="og:url" content="https://blog.iboy.tech/post/2783.html">
<meta property="og:site_name" content="一名不学无术的伪程序猿">
<meta property="og:description" content="12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-09T12:14:19.000Z">
<meta property="article:modified_time" content="2022-05-20T09:05:57.925Z">
<meta property="article:author" content="iBoy">
<meta name="twitter:card" content="summary">
  <link rel="canonical" href="https://blog.iboy.tech/post/2783">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Linux调度算法 | 一名不学无术的伪程序猿</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一名不学无术的伪程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/iboytech" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.iboy.tech/post/2783.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ae01.alicdn.com/kf/HTB1pZi7XlCw3KVjSZFu763AOpXa0.png">
      <meta itemprop="name" content="iBoy">
      <meta itemprop="description" content="知道的越多，不知道的越多...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一名不学无术的伪程序猿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Linux调度算法
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 20:14:19" itemprop="dateCreated datePublished" datetime="2020-11-09T20:14:19+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-20 17:05:57" itemprop="dateModified" datetime="2022-05-20T17:05:57+08:00">2022-05-20</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>213k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:13</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br><span class="line">2555</span><br><span class="line">2556</span><br><span class="line">2557</span><br><span class="line">2558</span><br><span class="line">2559</span><br><span class="line">2560</span><br><span class="line">2561</span><br><span class="line">2562</span><br><span class="line">2563</span><br><span class="line">2564</span><br><span class="line">2565</span><br><span class="line">2566</span><br><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br><span class="line">2577</span><br><span class="line">2578</span><br><span class="line">2579</span><br><span class="line">2580</span><br><span class="line">2581</span><br><span class="line">2582</span><br><span class="line">2583</span><br><span class="line">2584</span><br><span class="line">2585</span><br><span class="line">2586</span><br><span class="line">2587</span><br><span class="line">2588</span><br><span class="line">2589</span><br><span class="line">2590</span><br><span class="line">2591</span><br><span class="line">2592</span><br><span class="line">2593</span><br><span class="line">2594</span><br><span class="line">2595</span><br><span class="line">2596</span><br><span class="line">2597</span><br><span class="line">2598</span><br><span class="line">2599</span><br><span class="line">2600</span><br><span class="line">2601</span><br><span class="line">2602</span><br><span class="line">2603</span><br><span class="line">2604</span><br><span class="line">2605</span><br><span class="line">2606</span><br><span class="line">2607</span><br><span class="line">2608</span><br><span class="line">2609</span><br><span class="line">2610</span><br><span class="line">2611</span><br><span class="line">2612</span><br><span class="line">2613</span><br><span class="line">2614</span><br><span class="line">2615</span><br><span class="line">2616</span><br><span class="line">2617</span><br><span class="line">2618</span><br><span class="line">2619</span><br><span class="line">2620</span><br><span class="line">2621</span><br><span class="line">2622</span><br><span class="line">2623</span><br><span class="line">2624</span><br><span class="line">2625</span><br><span class="line">2626</span><br><span class="line">2627</span><br><span class="line">2628</span><br><span class="line">2629</span><br><span class="line">2630</span><br><span class="line">2631</span><br><span class="line">2632</span><br><span class="line">2633</span><br><span class="line">2634</span><br><span class="line">2635</span><br><span class="line">2636</span><br><span class="line">2637</span><br><span class="line">2638</span><br><span class="line">2639</span><br><span class="line">2640</span><br><span class="line">2641</span><br><span class="line">2642</span><br><span class="line">2643</span><br><span class="line">2644</span><br><span class="line">2645</span><br><span class="line">2646</span><br><span class="line">2647</span><br><span class="line">2648</span><br><span class="line">2649</span><br><span class="line">2650</span><br><span class="line">2651</span><br><span class="line">2652</span><br><span class="line">2653</span><br><span class="line">2654</span><br><span class="line">2655</span><br><span class="line">2656</span><br><span class="line">2657</span><br><span class="line">2658</span><br><span class="line">2659</span><br><span class="line">2660</span><br><span class="line">2661</span><br><span class="line">2662</span><br><span class="line">2663</span><br><span class="line">2664</span><br><span class="line">2665</span><br><span class="line">2666</span><br><span class="line">2667</span><br><span class="line">2668</span><br><span class="line">2669</span><br><span class="line">2670</span><br><span class="line">2671</span><br><span class="line">2672</span><br><span class="line">2673</span><br><span class="line">2674</span><br><span class="line">2675</span><br><span class="line">2676</span><br><span class="line">2677</span><br><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br><span class="line">2686</span><br><span class="line">2687</span><br><span class="line">2688</span><br><span class="line">2689</span><br><span class="line">2690</span><br><span class="line">2691</span><br><span class="line">2692</span><br><span class="line">2693</span><br><span class="line">2694</span><br><span class="line">2695</span><br><span class="line">2696</span><br><span class="line">2697</span><br><span class="line">2698</span><br><span class="line">2699</span><br><span class="line">2700</span><br><span class="line">2701</span><br><span class="line">2702</span><br><span class="line">2703</span><br><span class="line">2704</span><br><span class="line">2705</span><br><span class="line">2706</span><br><span class="line">2707</span><br><span class="line">2708</span><br><span class="line">2709</span><br><span class="line">2710</span><br><span class="line">2711</span><br><span class="line">2712</span><br><span class="line">2713</span><br><span class="line">2714</span><br><span class="line">2715</span><br><span class="line">2716</span><br><span class="line">2717</span><br><span class="line">2718</span><br><span class="line">2719</span><br><span class="line">2720</span><br><span class="line">2721</span><br><span class="line">2722</span><br><span class="line">2723</span><br><span class="line">2724</span><br><span class="line">2725</span><br><span class="line">2726</span><br><span class="line">2727</span><br><span class="line">2728</span><br><span class="line">2729</span><br><span class="line">2730</span><br><span class="line">2731</span><br><span class="line">2732</span><br><span class="line">2733</span><br><span class="line">2734</span><br><span class="line">2735</span><br><span class="line">2736</span><br><span class="line">2737</span><br><span class="line">2738</span><br><span class="line">2739</span><br><span class="line">2740</span><br><span class="line">2741</span><br><span class="line">2742</span><br><span class="line">2743</span><br><span class="line">2744</span><br><span class="line">2745</span><br><span class="line">2746</span><br><span class="line">2747</span><br><span class="line">2748</span><br><span class="line">2749</span><br><span class="line">2750</span><br><span class="line">2751</span><br><span class="line">2752</span><br><span class="line">2753</span><br><span class="line">2754</span><br><span class="line">2755</span><br><span class="line">2756</span><br><span class="line">2757</span><br><span class="line">2758</span><br><span class="line">2759</span><br><span class="line">2760</span><br><span class="line">2761</span><br><span class="line">2762</span><br><span class="line">2763</span><br><span class="line">2764</span><br><span class="line">2765</span><br><span class="line">2766</span><br><span class="line">2767</span><br><span class="line">2768</span><br><span class="line">2769</span><br><span class="line">2770</span><br><span class="line">2771</span><br><span class="line">2772</span><br><span class="line">2773</span><br><span class="line">2774</span><br><span class="line">2775</span><br><span class="line">2776</span><br><span class="line">2777</span><br><span class="line">2778</span><br><span class="line">2779</span><br><span class="line">2780</span><br><span class="line">2781</span><br><span class="line">2782</span><br><span class="line">2783</span><br><span class="line">2784</span><br><span class="line">2785</span><br><span class="line">2786</span><br><span class="line">2787</span><br><span class="line">2788</span><br><span class="line">2789</span><br><span class="line">2790</span><br><span class="line">2791</span><br><span class="line">2792</span><br><span class="line">2793</span><br><span class="line">2794</span><br><span class="line">2795</span><br><span class="line">2796</span><br><span class="line">2797</span><br><span class="line">2798</span><br><span class="line">2799</span><br><span class="line">2800</span><br><span class="line">2801</span><br><span class="line">2802</span><br><span class="line">2803</span><br><span class="line">2804</span><br><span class="line">2805</span><br><span class="line">2806</span><br><span class="line">2807</span><br><span class="line">2808</span><br><span class="line">2809</span><br><span class="line">2810</span><br><span class="line">2811</span><br><span class="line">2812</span><br><span class="line">2813</span><br><span class="line">2814</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br><span class="line">2818</span><br><span class="line">2819</span><br><span class="line">2820</span><br><span class="line">2821</span><br><span class="line">2822</span><br><span class="line">2823</span><br><span class="line">2824</span><br><span class="line">2825</span><br><span class="line">2826</span><br><span class="line">2827</span><br><span class="line">2828</span><br><span class="line">2829</span><br><span class="line">2830</span><br><span class="line">2831</span><br><span class="line">2832</span><br><span class="line">2833</span><br><span class="line">2834</span><br><span class="line">2835</span><br><span class="line">2836</span><br><span class="line">2837</span><br><span class="line">2838</span><br><span class="line">2839</span><br><span class="line">2840</span><br><span class="line">2841</span><br><span class="line">2842</span><br><span class="line">2843</span><br><span class="line">2844</span><br><span class="line">2845</span><br><span class="line">2846</span><br><span class="line">2847</span><br><span class="line">2848</span><br><span class="line">2849</span><br><span class="line">2850</span><br><span class="line">2851</span><br><span class="line">2852</span><br><span class="line">2853</span><br><span class="line">2854</span><br><span class="line">2855</span><br><span class="line">2856</span><br><span class="line">2857</span><br><span class="line">2858</span><br><span class="line">2859</span><br><span class="line">2860</span><br><span class="line">2861</span><br><span class="line">2862</span><br><span class="line">2863</span><br><span class="line">2864</span><br><span class="line">2865</span><br><span class="line">2866</span><br><span class="line">2867</span><br><span class="line">2868</span><br><span class="line">2869</span><br><span class="line">2870</span><br><span class="line">2871</span><br><span class="line">2872</span><br><span class="line">2873</span><br><span class="line">2874</span><br><span class="line">2875</span><br><span class="line">2876</span><br><span class="line">2877</span><br><span class="line">2878</span><br><span class="line">2879</span><br><span class="line">2880</span><br><span class="line">2881</span><br><span class="line">2882</span><br><span class="line">2883</span><br><span class="line">2884</span><br><span class="line">2885</span><br><span class="line">2886</span><br><span class="line">2887</span><br><span class="line">2888</span><br><span class="line">2889</span><br><span class="line">2890</span><br><span class="line">2891</span><br><span class="line">2892</span><br><span class="line">2893</span><br><span class="line">2894</span><br><span class="line">2895</span><br><span class="line">2896</span><br><span class="line">2897</span><br><span class="line">2898</span><br><span class="line">2899</span><br><span class="line">2900</span><br><span class="line">2901</span><br><span class="line">2902</span><br><span class="line">2903</span><br><span class="line">2904</span><br><span class="line">2905</span><br><span class="line">2906</span><br><span class="line">2907</span><br><span class="line">2908</span><br><span class="line">2909</span><br><span class="line">2910</span><br><span class="line">2911</span><br><span class="line">2912</span><br><span class="line">2913</span><br><span class="line">2914</span><br><span class="line">2915</span><br><span class="line">2916</span><br><span class="line">2917</span><br><span class="line">2918</span><br><span class="line">2919</span><br><span class="line">2920</span><br><span class="line">2921</span><br><span class="line">2922</span><br><span class="line">2923</span><br><span class="line">2924</span><br><span class="line">2925</span><br><span class="line">2926</span><br><span class="line">2927</span><br><span class="line">2928</span><br><span class="line">2929</span><br><span class="line">2930</span><br><span class="line">2931</span><br><span class="line">2932</span><br><span class="line">2933</span><br><span class="line">2934</span><br><span class="line">2935</span><br><span class="line">2936</span><br><span class="line">2937</span><br><span class="line">2938</span><br><span class="line">2939</span><br><span class="line">2940</span><br><span class="line">2941</span><br><span class="line">2942</span><br><span class="line">2943</span><br><span class="line">2944</span><br><span class="line">2945</span><br><span class="line">2946</span><br><span class="line">2947</span><br><span class="line">2948</span><br><span class="line">2949</span><br><span class="line">2950</span><br><span class="line">2951</span><br><span class="line">2952</span><br><span class="line">2953</span><br><span class="line">2954</span><br><span class="line">2955</span><br><span class="line">2956</span><br><span class="line">2957</span><br><span class="line">2958</span><br><span class="line">2959</span><br><span class="line">2960</span><br><span class="line">2961</span><br><span class="line">2962</span><br><span class="line">2963</span><br><span class="line">2964</span><br><span class="line">2965</span><br><span class="line">2966</span><br><span class="line">2967</span><br><span class="line">2968</span><br><span class="line">2969</span><br><span class="line">2970</span><br><span class="line">2971</span><br><span class="line">2972</span><br><span class="line">2973</span><br><span class="line">2974</span><br><span class="line">2975</span><br><span class="line">2976</span><br><span class="line">2977</span><br><span class="line">2978</span><br><span class="line">2979</span><br><span class="line">2980</span><br><span class="line">2981</span><br><span class="line">2982</span><br><span class="line">2983</span><br><span class="line">2984</span><br><span class="line">2985</span><br><span class="line">2986</span><br><span class="line">2987</span><br><span class="line">2988</span><br><span class="line">2989</span><br><span class="line">2990</span><br><span class="line">2991</span><br><span class="line">2992</span><br><span class="line">2993</span><br><span class="line">2994</span><br><span class="line">2995</span><br><span class="line">2996</span><br><span class="line">2997</span><br><span class="line">2998</span><br><span class="line">2999</span><br><span class="line">3000</span><br><span class="line">3001</span><br><span class="line">3002</span><br><span class="line">3003</span><br><span class="line">3004</span><br><span class="line">3005</span><br><span class="line">3006</span><br><span class="line">3007</span><br><span class="line">3008</span><br><span class="line">3009</span><br><span class="line">3010</span><br><span class="line">3011</span><br><span class="line">3012</span><br><span class="line">3013</span><br><span class="line">3014</span><br><span class="line">3015</span><br><span class="line">3016</span><br><span class="line">3017</span><br><span class="line">3018</span><br><span class="line">3019</span><br><span class="line">3020</span><br><span class="line">3021</span><br><span class="line">3022</span><br><span class="line">3023</span><br><span class="line">3024</span><br><span class="line">3025</span><br><span class="line">3026</span><br><span class="line">3027</span><br><span class="line">3028</span><br><span class="line">3029</span><br><span class="line">3030</span><br><span class="line">3031</span><br><span class="line">3032</span><br><span class="line">3033</span><br><span class="line">3034</span><br><span class="line">3035</span><br><span class="line">3036</span><br><span class="line">3037</span><br><span class="line">3038</span><br><span class="line">3039</span><br><span class="line">3040</span><br><span class="line">3041</span><br><span class="line">3042</span><br><span class="line">3043</span><br><span class="line">3044</span><br><span class="line">3045</span><br><span class="line">3046</span><br><span class="line">3047</span><br><span class="line">3048</span><br><span class="line">3049</span><br><span class="line">3050</span><br><span class="line">3051</span><br><span class="line">3052</span><br><span class="line">3053</span><br><span class="line">3054</span><br><span class="line">3055</span><br><span class="line">3056</span><br><span class="line">3057</span><br><span class="line">3058</span><br><span class="line">3059</span><br><span class="line">3060</span><br><span class="line">3061</span><br><span class="line">3062</span><br><span class="line">3063</span><br><span class="line">3064</span><br><span class="line">3065</span><br><span class="line">3066</span><br><span class="line">3067</span><br><span class="line">3068</span><br><span class="line">3069</span><br><span class="line">3070</span><br><span class="line">3071</span><br><span class="line">3072</span><br><span class="line">3073</span><br><span class="line">3074</span><br><span class="line">3075</span><br><span class="line">3076</span><br><span class="line">3077</span><br><span class="line">3078</span><br><span class="line">3079</span><br><span class="line">3080</span><br><span class="line">3081</span><br><span class="line">3082</span><br><span class="line">3083</span><br><span class="line">3084</span><br><span class="line">3085</span><br><span class="line">3086</span><br><span class="line">3087</span><br><span class="line">3088</span><br><span class="line">3089</span><br><span class="line">3090</span><br><span class="line">3091</span><br><span class="line">3092</span><br><span class="line">3093</span><br><span class="line">3094</span><br><span class="line">3095</span><br><span class="line">3096</span><br><span class="line">3097</span><br><span class="line">3098</span><br><span class="line">3099</span><br><span class="line">3100</span><br><span class="line">3101</span><br><span class="line">3102</span><br><span class="line">3103</span><br><span class="line">3104</span><br><span class="line">3105</span><br><span class="line">3106</span><br><span class="line">3107</span><br><span class="line">3108</span><br><span class="line">3109</span><br><span class="line">3110</span><br><span class="line">3111</span><br><span class="line">3112</span><br><span class="line">3113</span><br><span class="line">3114</span><br><span class="line">3115</span><br><span class="line">3116</span><br><span class="line">3117</span><br><span class="line">3118</span><br><span class="line">3119</span><br><span class="line">3120</span><br><span class="line">3121</span><br><span class="line">3122</span><br><span class="line">3123</span><br><span class="line">3124</span><br><span class="line">3125</span><br><span class="line">3126</span><br><span class="line">3127</span><br><span class="line">3128</span><br><span class="line">3129</span><br><span class="line">3130</span><br><span class="line">3131</span><br><span class="line">3132</span><br><span class="line">3133</span><br><span class="line">3134</span><br><span class="line">3135</span><br><span class="line">3136</span><br><span class="line">3137</span><br><span class="line">3138</span><br><span class="line">3139</span><br><span class="line">3140</span><br><span class="line">3141</span><br><span class="line">3142</span><br><span class="line">3143</span><br><span class="line">3144</span><br><span class="line">3145</span><br><span class="line">3146</span><br><span class="line">3147</span><br><span class="line">3148</span><br><span class="line">3149</span><br><span class="line">3150</span><br><span class="line">3151</span><br><span class="line">3152</span><br><span class="line">3153</span><br><span class="line">3154</span><br><span class="line">3155</span><br><span class="line">3156</span><br><span class="line">3157</span><br><span class="line">3158</span><br><span class="line">3159</span><br><span class="line">3160</span><br><span class="line">3161</span><br><span class="line">3162</span><br><span class="line">3163</span><br><span class="line">3164</span><br><span class="line">3165</span><br><span class="line">3166</span><br><span class="line">3167</span><br><span class="line">3168</span><br><span class="line">3169</span><br><span class="line">3170</span><br><span class="line">3171</span><br><span class="line">3172</span><br><span class="line">3173</span><br><span class="line">3174</span><br><span class="line">3175</span><br><span class="line">3176</span><br><span class="line">3177</span><br><span class="line">3178</span><br><span class="line">3179</span><br><span class="line">3180</span><br><span class="line">3181</span><br><span class="line">3182</span><br><span class="line">3183</span><br><span class="line">3184</span><br><span class="line">3185</span><br><span class="line">3186</span><br><span class="line">3187</span><br><span class="line">3188</span><br><span class="line">3189</span><br><span class="line">3190</span><br><span class="line">3191</span><br><span class="line">3192</span><br><span class="line">3193</span><br><span class="line">3194</span><br><span class="line">3195</span><br><span class="line">3196</span><br><span class="line">3197</span><br><span class="line">3198</span><br><span class="line">3199</span><br><span class="line">3200</span><br><span class="line">3201</span><br><span class="line">3202</span><br><span class="line">3203</span><br><span class="line">3204</span><br><span class="line">3205</span><br><span class="line">3206</span><br><span class="line">3207</span><br><span class="line">3208</span><br><span class="line">3209</span><br><span class="line">3210</span><br><span class="line">3211</span><br><span class="line">3212</span><br><span class="line">3213</span><br><span class="line">3214</span><br><span class="line">3215</span><br><span class="line">3216</span><br><span class="line">3217</span><br><span class="line">3218</span><br><span class="line">3219</span><br><span class="line">3220</span><br><span class="line">3221</span><br><span class="line">3222</span><br><span class="line">3223</span><br><span class="line">3224</span><br><span class="line">3225</span><br><span class="line">3226</span><br><span class="line">3227</span><br><span class="line">3228</span><br><span class="line">3229</span><br><span class="line">3230</span><br><span class="line">3231</span><br><span class="line">3232</span><br><span class="line">3233</span><br><span class="line">3234</span><br><span class="line">3235</span><br><span class="line">3236</span><br><span class="line">3237</span><br><span class="line">3238</span><br><span class="line">3239</span><br><span class="line">3240</span><br><span class="line">3241</span><br><span class="line">3242</span><br><span class="line">3243</span><br><span class="line">3244</span><br><span class="line">3245</span><br><span class="line">3246</span><br><span class="line">3247</span><br><span class="line">3248</span><br><span class="line">3249</span><br><span class="line">3250</span><br><span class="line">3251</span><br><span class="line">3252</span><br><span class="line">3253</span><br><span class="line">3254</span><br><span class="line">3255</span><br><span class="line">3256</span><br><span class="line">3257</span><br><span class="line">3258</span><br><span class="line">3259</span><br><span class="line">3260</span><br><span class="line">3261</span><br><span class="line">3262</span><br><span class="line">3263</span><br><span class="line">3264</span><br><span class="line">3265</span><br><span class="line">3266</span><br><span class="line">3267</span><br><span class="line">3268</span><br><span class="line">3269</span><br><span class="line">3270</span><br><span class="line">3271</span><br><span class="line">3272</span><br><span class="line">3273</span><br><span class="line">3274</span><br><span class="line">3275</span><br><span class="line">3276</span><br><span class="line">3277</span><br><span class="line">3278</span><br><span class="line">3279</span><br><span class="line">3280</span><br><span class="line">3281</span><br><span class="line">3282</span><br><span class="line">3283</span><br><span class="line">3284</span><br><span class="line">3285</span><br><span class="line">3286</span><br><span class="line">3287</span><br><span class="line">3288</span><br><span class="line">3289</span><br><span class="line">3290</span><br><span class="line">3291</span><br><span class="line">3292</span><br><span class="line">3293</span><br><span class="line">3294</span><br><span class="line">3295</span><br><span class="line">3296</span><br><span class="line">3297</span><br><span class="line">3298</span><br><span class="line">3299</span><br><span class="line">3300</span><br><span class="line">3301</span><br><span class="line">3302</span><br><span class="line">3303</span><br><span class="line">3304</span><br><span class="line">3305</span><br><span class="line">3306</span><br><span class="line">3307</span><br><span class="line">3308</span><br><span class="line">3309</span><br><span class="line">3310</span><br><span class="line">3311</span><br><span class="line">3312</span><br><span class="line">3313</span><br><span class="line">3314</span><br><span class="line">3315</span><br><span class="line">3316</span><br><span class="line">3317</span><br><span class="line">3318</span><br><span class="line">3319</span><br><span class="line">3320</span><br><span class="line">3321</span><br><span class="line">3322</span><br><span class="line">3323</span><br><span class="line">3324</span><br><span class="line">3325</span><br><span class="line">3326</span><br><span class="line">3327</span><br><span class="line">3328</span><br><span class="line">3329</span><br><span class="line">3330</span><br><span class="line">3331</span><br><span class="line">3332</span><br><span class="line">3333</span><br><span class="line">3334</span><br><span class="line">3335</span><br><span class="line">3336</span><br><span class="line">3337</span><br><span class="line">3338</span><br><span class="line">3339</span><br><span class="line">3340</span><br><span class="line">3341</span><br><span class="line">3342</span><br><span class="line">3343</span><br><span class="line">3344</span><br><span class="line">3345</span><br><span class="line">3346</span><br><span class="line">3347</span><br><span class="line">3348</span><br><span class="line">3349</span><br><span class="line">3350</span><br><span class="line">3351</span><br><span class="line">3352</span><br><span class="line">3353</span><br><span class="line">3354</span><br><span class="line">3355</span><br><span class="line">3356</span><br><span class="line">3357</span><br><span class="line">3358</span><br><span class="line">3359</span><br><span class="line">3360</span><br><span class="line">3361</span><br><span class="line">3362</span><br><span class="line">3363</span><br><span class="line">3364</span><br><span class="line">3365</span><br><span class="line">3366</span><br><span class="line">3367</span><br><span class="line">3368</span><br><span class="line">3369</span><br><span class="line">3370</span><br><span class="line">3371</span><br><span class="line">3372</span><br><span class="line">3373</span><br><span class="line">3374</span><br><span class="line">3375</span><br><span class="line">3376</span><br><span class="line">3377</span><br><span class="line">3378</span><br><span class="line">3379</span><br><span class="line">3380</span><br><span class="line">3381</span><br><span class="line">3382</span><br><span class="line">3383</span><br><span class="line">3384</span><br><span class="line">3385</span><br><span class="line">3386</span><br><span class="line">3387</span><br><span class="line">3388</span><br><span class="line">3389</span><br><span class="line">3390</span><br><span class="line">3391</span><br><span class="line">3392</span><br><span class="line">3393</span><br><span class="line">3394</span><br><span class="line">3395</span><br><span class="line">3396</span><br><span class="line">3397</span><br><span class="line">3398</span><br><span class="line">3399</span><br><span class="line">3400</span><br><span class="line">3401</span><br><span class="line">3402</span><br><span class="line">3403</span><br><span class="line">3404</span><br><span class="line">3405</span><br><span class="line">3406</span><br><span class="line">3407</span><br><span class="line">3408</span><br><span class="line">3409</span><br><span class="line">3410</span><br><span class="line">3411</span><br><span class="line">3412</span><br><span class="line">3413</span><br><span class="line">3414</span><br><span class="line">3415</span><br><span class="line">3416</span><br><span class="line">3417</span><br><span class="line">3418</span><br><span class="line">3419</span><br><span class="line">3420</span><br><span class="line">3421</span><br><span class="line">3422</span><br><span class="line">3423</span><br><span class="line">3424</span><br><span class="line">3425</span><br><span class="line">3426</span><br><span class="line">3427</span><br><span class="line">3428</span><br><span class="line">3429</span><br><span class="line">3430</span><br><span class="line">3431</span><br><span class="line">3432</span><br><span class="line">3433</span><br><span class="line">3434</span><br><span class="line">3435</span><br><span class="line">3436</span><br><span class="line">3437</span><br><span class="line">3438</span><br><span class="line">3439</span><br><span class="line">3440</span><br><span class="line">3441</span><br><span class="line">3442</span><br><span class="line">3443</span><br><span class="line">3444</span><br><span class="line">3445</span><br><span class="line">3446</span><br><span class="line">3447</span><br><span class="line">3448</span><br><span class="line">3449</span><br><span class="line">3450</span><br><span class="line">3451</span><br><span class="line">3452</span><br><span class="line">3453</span><br><span class="line">3454</span><br><span class="line">3455</span><br><span class="line">3456</span><br><span class="line">3457</span><br><span class="line">3458</span><br><span class="line">3459</span><br><span class="line">3460</span><br><span class="line">3461</span><br><span class="line">3462</span><br><span class="line">3463</span><br><span class="line">3464</span><br><span class="line">3465</span><br><span class="line">3466</span><br><span class="line">3467</span><br><span class="line">3468</span><br><span class="line">3469</span><br><span class="line">3470</span><br><span class="line">3471</span><br><span class="line">3472</span><br><span class="line">3473</span><br><span class="line">3474</span><br><span class="line">3475</span><br><span class="line">3476</span><br><span class="line">3477</span><br><span class="line">3478</span><br><span class="line">3479</span><br><span class="line">3480</span><br><span class="line">3481</span><br><span class="line">3482</span><br><span class="line">3483</span><br><span class="line">3484</span><br><span class="line">3485</span><br><span class="line">3486</span><br><span class="line">3487</span><br><span class="line">3488</span><br><span class="line">3489</span><br><span class="line">3490</span><br><span class="line">3491</span><br><span class="line">3492</span><br><span class="line">3493</span><br><span class="line">3494</span><br><span class="line">3495</span><br><span class="line">3496</span><br><span class="line">3497</span><br><span class="line">3498</span><br><span class="line">3499</span><br><span class="line">3500</span><br><span class="line">3501</span><br><span class="line">3502</span><br><span class="line">3503</span><br><span class="line">3504</span><br><span class="line">3505</span><br><span class="line">3506</span><br><span class="line">3507</span><br><span class="line">3508</span><br><span class="line">3509</span><br><span class="line">3510</span><br><span class="line">3511</span><br><span class="line">3512</span><br><span class="line">3513</span><br><span class="line">3514</span><br><span class="line">3515</span><br><span class="line">3516</span><br><span class="line">3517</span><br><span class="line">3518</span><br><span class="line">3519</span><br><span class="line">3520</span><br><span class="line">3521</span><br><span class="line">3522</span><br><span class="line">3523</span><br><span class="line">3524</span><br><span class="line">3525</span><br><span class="line">3526</span><br><span class="line">3527</span><br><span class="line">3528</span><br><span class="line">3529</span><br><span class="line">3530</span><br><span class="line">3531</span><br><span class="line">3532</span><br><span class="line">3533</span><br><span class="line">3534</span><br><span class="line">3535</span><br><span class="line">3536</span><br><span class="line">3537</span><br><span class="line">3538</span><br><span class="line">3539</span><br><span class="line">3540</span><br><span class="line">3541</span><br><span class="line">3542</span><br><span class="line">3543</span><br><span class="line">3544</span><br><span class="line">3545</span><br><span class="line">3546</span><br><span class="line">3547</span><br><span class="line">3548</span><br><span class="line">3549</span><br><span class="line">3550</span><br><span class="line">3551</span><br><span class="line">3552</span><br><span class="line">3553</span><br><span class="line">3554</span><br><span class="line">3555</span><br><span class="line">3556</span><br><span class="line">3557</span><br><span class="line">3558</span><br><span class="line">3559</span><br><span class="line">3560</span><br><span class="line">3561</span><br><span class="line">3562</span><br><span class="line">3563</span><br><span class="line">3564</span><br><span class="line">3565</span><br><span class="line">3566</span><br><span class="line">3567</span><br><span class="line">3568</span><br><span class="line">3569</span><br><span class="line">3570</span><br><span class="line">3571</span><br><span class="line">3572</span><br><span class="line">3573</span><br><span class="line">3574</span><br><span class="line">3575</span><br><span class="line">3576</span><br><span class="line">3577</span><br><span class="line">3578</span><br><span class="line">3579</span><br><span class="line">3580</span><br><span class="line">3581</span><br><span class="line">3582</span><br><span class="line">3583</span><br><span class="line">3584</span><br><span class="line">3585</span><br><span class="line">3586</span><br><span class="line">3587</span><br><span class="line">3588</span><br><span class="line">3589</span><br><span class="line">3590</span><br><span class="line">3591</span><br><span class="line">3592</span><br><span class="line">3593</span><br><span class="line">3594</span><br><span class="line">3595</span><br><span class="line">3596</span><br><span class="line">3597</span><br><span class="line">3598</span><br><span class="line">3599</span><br><span class="line">3600</span><br><span class="line">3601</span><br><span class="line">3602</span><br><span class="line">3603</span><br><span class="line">3604</span><br><span class="line">3605</span><br><span class="line">3606</span><br><span class="line">3607</span><br><span class="line">3608</span><br><span class="line">3609</span><br><span class="line">3610</span><br><span class="line">3611</span><br><span class="line">3612</span><br><span class="line">3613</span><br><span class="line">3614</span><br><span class="line">3615</span><br><span class="line">3616</span><br><span class="line">3617</span><br><span class="line">3618</span><br><span class="line">3619</span><br><span class="line">3620</span><br><span class="line">3621</span><br><span class="line">3622</span><br><span class="line">3623</span><br><span class="line">3624</span><br><span class="line">3625</span><br><span class="line">3626</span><br><span class="line">3627</span><br><span class="line">3628</span><br><span class="line">3629</span><br><span class="line">3630</span><br><span class="line">3631</span><br><span class="line">3632</span><br><span class="line">3633</span><br><span class="line">3634</span><br><span class="line">3635</span><br><span class="line">3636</span><br><span class="line">3637</span><br><span class="line">3638</span><br><span class="line">3639</span><br><span class="line">3640</span><br><span class="line">3641</span><br><span class="line">3642</span><br><span class="line">3643</span><br><span class="line">3644</span><br><span class="line">3645</span><br><span class="line">3646</span><br><span class="line">3647</span><br><span class="line">3648</span><br><span class="line">3649</span><br><span class="line">3650</span><br><span class="line">3651</span><br><span class="line">3652</span><br><span class="line">3653</span><br><span class="line">3654</span><br><span class="line">3655</span><br><span class="line">3656</span><br><span class="line">3657</span><br><span class="line">3658</span><br><span class="line">3659</span><br><span class="line">3660</span><br><span class="line">3661</span><br><span class="line">3662</span><br><span class="line">3663</span><br><span class="line">3664</span><br><span class="line">3665</span><br><span class="line">3666</span><br><span class="line">3667</span><br><span class="line">3668</span><br><span class="line">3669</span><br><span class="line">3670</span><br><span class="line">3671</span><br><span class="line">3672</span><br><span class="line">3673</span><br><span class="line">3674</span><br><span class="line">3675</span><br><span class="line">3676</span><br><span class="line">3677</span><br><span class="line">3678</span><br><span class="line">3679</span><br><span class="line">3680</span><br><span class="line">3681</span><br><span class="line">3682</span><br><span class="line">3683</span><br><span class="line">3684</span><br><span class="line">3685</span><br><span class="line">3686</span><br><span class="line">3687</span><br><span class="line">3688</span><br><span class="line">3689</span><br><span class="line">3690</span><br><span class="line">3691</span><br><span class="line">3692</span><br><span class="line">3693</span><br><span class="line">3694</span><br><span class="line">3695</span><br><span class="line">3696</span><br><span class="line">3697</span><br><span class="line">3698</span><br><span class="line">3699</span><br><span class="line">3700</span><br><span class="line">3701</span><br><span class="line">3702</span><br><span class="line">3703</span><br><span class="line">3704</span><br><span class="line">3705</span><br><span class="line">3706</span><br><span class="line">3707</span><br><span class="line">3708</span><br><span class="line">3709</span><br><span class="line">3710</span><br><span class="line">3711</span><br><span class="line">3712</span><br><span class="line">3713</span><br><span class="line">3714</span><br><span class="line">3715</span><br><span class="line">3716</span><br><span class="line">3717</span><br><span class="line">3718</span><br><span class="line">3719</span><br><span class="line">3720</span><br><span class="line">3721</span><br><span class="line">3722</span><br><span class="line">3723</span><br><span class="line">3724</span><br><span class="line">3725</span><br><span class="line">3726</span><br><span class="line">3727</span><br><span class="line">3728</span><br><span class="line">3729</span><br><span class="line">3730</span><br><span class="line">3731</span><br><span class="line">3732</span><br><span class="line">3733</span><br><span class="line">3734</span><br><span class="line">3735</span><br><span class="line">3736</span><br><span class="line">3737</span><br><span class="line">3738</span><br><span class="line">3739</span><br><span class="line">3740</span><br><span class="line">3741</span><br><span class="line">3742</span><br><span class="line">3743</span><br><span class="line">3744</span><br><span class="line">3745</span><br><span class="line">3746</span><br><span class="line">3747</span><br><span class="line">3748</span><br><span class="line">3749</span><br><span class="line">3750</span><br><span class="line">3751</span><br><span class="line">3752</span><br><span class="line">3753</span><br><span class="line">3754</span><br><span class="line">3755</span><br><span class="line">3756</span><br><span class="line">3757</span><br><span class="line">3758</span><br><span class="line">3759</span><br><span class="line">3760</span><br><span class="line">3761</span><br><span class="line">3762</span><br><span class="line">3763</span><br><span class="line">3764</span><br><span class="line">3765</span><br><span class="line">3766</span><br><span class="line">3767</span><br><span class="line">3768</span><br><span class="line">3769</span><br><span class="line">3770</span><br><span class="line">3771</span><br><span class="line">3772</span><br><span class="line">3773</span><br><span class="line">3774</span><br><span class="line">3775</span><br><span class="line">3776</span><br><span class="line">3777</span><br><span class="line">3778</span><br><span class="line">3779</span><br><span class="line">3780</span><br><span class="line">3781</span><br><span class="line">3782</span><br><span class="line">3783</span><br><span class="line">3784</span><br><span class="line">3785</span><br><span class="line">3786</span><br><span class="line">3787</span><br><span class="line">3788</span><br><span class="line">3789</span><br><span class="line">3790</span><br><span class="line">3791</span><br><span class="line">3792</span><br><span class="line">3793</span><br><span class="line">3794</span><br><span class="line">3795</span><br><span class="line">3796</span><br><span class="line">3797</span><br><span class="line">3798</span><br><span class="line">3799</span><br><span class="line">3800</span><br><span class="line">3801</span><br><span class="line">3802</span><br><span class="line">3803</span><br><span class="line">3804</span><br><span class="line">3805</span><br><span class="line">3806</span><br><span class="line">3807</span><br><span class="line">3808</span><br><span class="line">3809</span><br><span class="line">3810</span><br><span class="line">3811</span><br><span class="line">3812</span><br><span class="line">3813</span><br><span class="line">3814</span><br><span class="line">3815</span><br><span class="line">3816</span><br><span class="line">3817</span><br><span class="line">3818</span><br><span class="line">3819</span><br><span class="line">3820</span><br><span class="line">3821</span><br><span class="line">3822</span><br><span class="line">3823</span><br><span class="line">3824</span><br><span class="line">3825</span><br><span class="line">3826</span><br><span class="line">3827</span><br><span class="line">3828</span><br><span class="line">3829</span><br><span class="line">3830</span><br><span class="line">3831</span><br><span class="line">3832</span><br><span class="line">3833</span><br><span class="line">3834</span><br><span class="line">3835</span><br><span class="line">3836</span><br><span class="line">3837</span><br><span class="line">3838</span><br><span class="line">3839</span><br><span class="line">3840</span><br><span class="line">3841</span><br><span class="line">3842</span><br><span class="line">3843</span><br><span class="line">3844</span><br><span class="line">3845</span><br><span class="line">3846</span><br><span class="line">3847</span><br><span class="line">3848</span><br><span class="line">3849</span><br><span class="line">3850</span><br><span class="line">3851</span><br><span class="line">3852</span><br><span class="line">3853</span><br><span class="line">3854</span><br><span class="line">3855</span><br><span class="line">3856</span><br><span class="line">3857</span><br><span class="line">3858</span><br><span class="line">3859</span><br><span class="line">3860</span><br><span class="line">3861</span><br><span class="line">3862</span><br><span class="line">3863</span><br><span class="line">3864</span><br><span class="line">3865</span><br><span class="line">3866</span><br><span class="line">3867</span><br><span class="line">3868</span><br><span class="line">3869</span><br><span class="line">3870</span><br><span class="line">3871</span><br><span class="line">3872</span><br><span class="line">3873</span><br><span class="line">3874</span><br><span class="line">3875</span><br><span class="line">3876</span><br><span class="line">3877</span><br><span class="line">3878</span><br><span class="line">3879</span><br><span class="line">3880</span><br><span class="line">3881</span><br><span class="line">3882</span><br><span class="line">3883</span><br><span class="line">3884</span><br><span class="line">3885</span><br><span class="line">3886</span><br><span class="line">3887</span><br><span class="line">3888</span><br><span class="line">3889</span><br><span class="line">3890</span><br><span class="line">3891</span><br><span class="line">3892</span><br><span class="line">3893</span><br><span class="line">3894</span><br><span class="line">3895</span><br><span class="line">3896</span><br><span class="line">3897</span><br><span class="line">3898</span><br><span class="line">3899</span><br><span class="line">3900</span><br><span class="line">3901</span><br><span class="line">3902</span><br><span class="line">3903</span><br><span class="line">3904</span><br><span class="line">3905</span><br><span class="line">3906</span><br><span class="line">3907</span><br><span class="line">3908</span><br><span class="line">3909</span><br><span class="line">3910</span><br><span class="line">3911</span><br><span class="line">3912</span><br><span class="line">3913</span><br><span class="line">3914</span><br><span class="line">3915</span><br><span class="line">3916</span><br><span class="line">3917</span><br><span class="line">3918</span><br><span class="line">3919</span><br><span class="line">3920</span><br><span class="line">3921</span><br><span class="line">3922</span><br><span class="line">3923</span><br><span class="line">3924</span><br><span class="line">3925</span><br><span class="line">3926</span><br><span class="line">3927</span><br><span class="line">3928</span><br><span class="line">3929</span><br><span class="line">3930</span><br><span class="line">3931</span><br><span class="line">3932</span><br><span class="line">3933</span><br><span class="line">3934</span><br><span class="line">3935</span><br><span class="line">3936</span><br><span class="line">3937</span><br><span class="line">3938</span><br><span class="line">3939</span><br><span class="line">3940</span><br><span class="line">3941</span><br><span class="line">3942</span><br><span class="line">3943</span><br><span class="line">3944</span><br><span class="line">3945</span><br><span class="line">3946</span><br><span class="line">3947</span><br><span class="line">3948</span><br><span class="line">3949</span><br><span class="line">3950</span><br><span class="line">3951</span><br><span class="line">3952</span><br><span class="line">3953</span><br><span class="line">3954</span><br><span class="line">3955</span><br><span class="line">3956</span><br><span class="line">3957</span><br><span class="line">3958</span><br><span class="line">3959</span><br><span class="line">3960</span><br><span class="line">3961</span><br><span class="line">3962</span><br><span class="line">3963</span><br><span class="line">3964</span><br><span class="line">3965</span><br><span class="line">3966</span><br><span class="line">3967</span><br><span class="line">3968</span><br><span class="line">3969</span><br><span class="line">3970</span><br><span class="line">3971</span><br><span class="line">3972</span><br><span class="line">3973</span><br><span class="line">3974</span><br><span class="line">3975</span><br><span class="line">3976</span><br><span class="line">3977</span><br><span class="line">3978</span><br><span class="line">3979</span><br><span class="line">3980</span><br><span class="line">3981</span><br><span class="line">3982</span><br><span class="line">3983</span><br><span class="line">3984</span><br><span class="line">3985</span><br><span class="line">3986</span><br><span class="line">3987</span><br><span class="line">3988</span><br><span class="line">3989</span><br><span class="line">3990</span><br><span class="line">3991</span><br><span class="line">3992</span><br><span class="line">3993</span><br><span class="line">3994</span><br><span class="line">3995</span><br><span class="line">3996</span><br><span class="line">3997</span><br><span class="line">3998</span><br><span class="line">3999</span><br><span class="line">4000</span><br><span class="line">4001</span><br><span class="line">4002</span><br><span class="line">4003</span><br><span class="line">4004</span><br><span class="line">4005</span><br><span class="line">4006</span><br><span class="line">4007</span><br><span class="line">4008</span><br><span class="line">4009</span><br><span class="line">4010</span><br><span class="line">4011</span><br><span class="line">4012</span><br><span class="line">4013</span><br><span class="line">4014</span><br><span class="line">4015</span><br><span class="line">4016</span><br><span class="line">4017</span><br><span class="line">4018</span><br><span class="line">4019</span><br><span class="line">4020</span><br><span class="line">4021</span><br><span class="line">4022</span><br><span class="line">4023</span><br><span class="line">4024</span><br><span class="line">4025</span><br><span class="line">4026</span><br><span class="line">4027</span><br><span class="line">4028</span><br><span class="line">4029</span><br><span class="line">4030</span><br><span class="line">4031</span><br><span class="line">4032</span><br><span class="line">4033</span><br><span class="line">4034</span><br><span class="line">4035</span><br><span class="line">4036</span><br><span class="line">4037</span><br><span class="line">4038</span><br><span class="line">4039</span><br><span class="line">4040</span><br><span class="line">4041</span><br><span class="line">4042</span><br><span class="line">4043</span><br><span class="line">4044</span><br><span class="line">4045</span><br><span class="line">4046</span><br><span class="line">4047</span><br><span class="line">4048</span><br><span class="line">4049</span><br><span class="line">4050</span><br><span class="line">4051</span><br><span class="line">4052</span><br><span class="line">4053</span><br><span class="line">4054</span><br><span class="line">4055</span><br><span class="line">4056</span><br><span class="line">4057</span><br><span class="line">4058</span><br><span class="line">4059</span><br><span class="line">4060</span><br><span class="line">4061</span><br><span class="line">4062</span><br><span class="line">4063</span><br><span class="line">4064</span><br><span class="line">4065</span><br><span class="line">4066</span><br><span class="line">4067</span><br><span class="line">4068</span><br><span class="line">4069</span><br><span class="line">4070</span><br><span class="line">4071</span><br><span class="line">4072</span><br><span class="line">4073</span><br><span class="line">4074</span><br><span class="line">4075</span><br><span class="line">4076</span><br><span class="line">4077</span><br><span class="line">4078</span><br><span class="line">4079</span><br><span class="line">4080</span><br><span class="line">4081</span><br><span class="line">4082</span><br><span class="line">4083</span><br><span class="line">4084</span><br><span class="line">4085</span><br><span class="line">4086</span><br><span class="line">4087</span><br><span class="line">4088</span><br><span class="line">4089</span><br><span class="line">4090</span><br><span class="line">4091</span><br><span class="line">4092</span><br><span class="line">4093</span><br><span class="line">4094</span><br><span class="line">4095</span><br><span class="line">4096</span><br><span class="line">4097</span><br><span class="line">4098</span><br><span class="line">4099</span><br><span class="line">4100</span><br><span class="line">4101</span><br><span class="line">4102</span><br><span class="line">4103</span><br><span class="line">4104</span><br><span class="line">4105</span><br><span class="line">4106</span><br><span class="line">4107</span><br><span class="line">4108</span><br><span class="line">4109</span><br><span class="line">4110</span><br><span class="line">4111</span><br><span class="line">4112</span><br><span class="line">4113</span><br><span class="line">4114</span><br><span class="line">4115</span><br><span class="line">4116</span><br><span class="line">4117</span><br><span class="line">4118</span><br><span class="line">4119</span><br><span class="line">4120</span><br><span class="line">4121</span><br><span class="line">4122</span><br><span class="line">4123</span><br><span class="line">4124</span><br><span class="line">4125</span><br><span class="line">4126</span><br><span class="line">4127</span><br><span class="line">4128</span><br><span class="line">4129</span><br><span class="line">4130</span><br><span class="line">4131</span><br><span class="line">4132</span><br><span class="line">4133</span><br><span class="line">4134</span><br><span class="line">4135</span><br><span class="line">4136</span><br><span class="line">4137</span><br><span class="line">4138</span><br><span class="line">4139</span><br><span class="line">4140</span><br><span class="line">4141</span><br><span class="line">4142</span><br><span class="line">4143</span><br><span class="line">4144</span><br><span class="line">4145</span><br><span class="line">4146</span><br><span class="line">4147</span><br><span class="line">4148</span><br><span class="line">4149</span><br><span class="line">4150</span><br><span class="line">4151</span><br><span class="line">4152</span><br><span class="line">4153</span><br><span class="line">4154</span><br><span class="line">4155</span><br><span class="line">4156</span><br><span class="line">4157</span><br><span class="line">4158</span><br><span class="line">4159</span><br><span class="line">4160</span><br><span class="line">4161</span><br><span class="line">4162</span><br><span class="line">4163</span><br><span class="line">4164</span><br><span class="line">4165</span><br><span class="line">4166</span><br><span class="line">4167</span><br><span class="line">4168</span><br><span class="line">4169</span><br><span class="line">4170</span><br><span class="line">4171</span><br><span class="line">4172</span><br><span class="line">4173</span><br><span class="line">4174</span><br><span class="line">4175</span><br><span class="line">4176</span><br><span class="line">4177</span><br><span class="line">4178</span><br><span class="line">4179</span><br><span class="line">4180</span><br><span class="line">4181</span><br><span class="line">4182</span><br><span class="line">4183</span><br><span class="line">4184</span><br><span class="line">4185</span><br><span class="line">4186</span><br><span class="line">4187</span><br><span class="line">4188</span><br><span class="line">4189</span><br><span class="line">4190</span><br><span class="line">4191</span><br><span class="line">4192</span><br><span class="line">4193</span><br><span class="line">4194</span><br><span class="line">4195</span><br><span class="line">4196</span><br><span class="line">4197</span><br><span class="line">4198</span><br><span class="line">4199</span><br><span class="line">4200</span><br><span class="line">4201</span><br><span class="line">4202</span><br><span class="line">4203</span><br><span class="line">4204</span><br><span class="line">4205</span><br><span class="line">4206</span><br><span class="line">4207</span><br><span class="line">4208</span><br><span class="line">4209</span><br><span class="line">4210</span><br><span class="line">4211</span><br><span class="line">4212</span><br><span class="line">4213</span><br><span class="line">4214</span><br><span class="line">4215</span><br><span class="line">4216</span><br><span class="line">4217</span><br><span class="line">4218</span><br><span class="line">4219</span><br><span class="line">4220</span><br><span class="line">4221</span><br><span class="line">4222</span><br><span class="line">4223</span><br><span class="line">4224</span><br><span class="line">4225</span><br><span class="line">4226</span><br><span class="line">4227</span><br><span class="line">4228</span><br><span class="line">4229</span><br><span class="line">4230</span><br><span class="line">4231</span><br><span class="line">4232</span><br><span class="line">4233</span><br><span class="line">4234</span><br><span class="line">4235</span><br><span class="line">4236</span><br><span class="line">4237</span><br><span class="line">4238</span><br><span class="line">4239</span><br><span class="line">4240</span><br><span class="line">4241</span><br><span class="line">4242</span><br><span class="line">4243</span><br><span class="line">4244</span><br><span class="line">4245</span><br><span class="line">4246</span><br><span class="line">4247</span><br><span class="line">4248</span><br><span class="line">4249</span><br><span class="line">4250</span><br><span class="line">4251</span><br><span class="line">4252</span><br><span class="line">4253</span><br><span class="line">4254</span><br><span class="line">4255</span><br><span class="line">4256</span><br><span class="line">4257</span><br><span class="line">4258</span><br><span class="line">4259</span><br><span class="line">4260</span><br><span class="line">4261</span><br><span class="line">4262</span><br><span class="line">4263</span><br><span class="line">4264</span><br><span class="line">4265</span><br><span class="line">4266</span><br><span class="line">4267</span><br><span class="line">4268</span><br><span class="line">4269</span><br><span class="line">4270</span><br><span class="line">4271</span><br><span class="line">4272</span><br><span class="line">4273</span><br><span class="line">4274</span><br><span class="line">4275</span><br><span class="line">4276</span><br><span class="line">4277</span><br><span class="line">4278</span><br><span class="line">4279</span><br><span class="line">4280</span><br><span class="line">4281</span><br><span class="line">4282</span><br><span class="line">4283</span><br><span class="line">4284</span><br><span class="line">4285</span><br><span class="line">4286</span><br><span class="line">4287</span><br><span class="line">4288</span><br><span class="line">4289</span><br><span class="line">4290</span><br><span class="line">4291</span><br><span class="line">4292</span><br><span class="line">4293</span><br><span class="line">4294</span><br><span class="line">4295</span><br><span class="line">4296</span><br><span class="line">4297</span><br><span class="line">4298</span><br><span class="line">4299</span><br><span class="line">4300</span><br><span class="line">4301</span><br><span class="line">4302</span><br><span class="line">4303</span><br><span class="line">4304</span><br><span class="line">4305</span><br><span class="line">4306</span><br><span class="line">4307</span><br><span class="line">4308</span><br><span class="line">4309</span><br><span class="line">4310</span><br><span class="line">4311</span><br><span class="line">4312</span><br><span class="line">4313</span><br><span class="line">4314</span><br><span class="line">4315</span><br><span class="line">4316</span><br><span class="line">4317</span><br><span class="line">4318</span><br><span class="line">4319</span><br><span class="line">4320</span><br><span class="line">4321</span><br><span class="line">4322</span><br><span class="line">4323</span><br><span class="line">4324</span><br><span class="line">4325</span><br><span class="line">4326</span><br><span class="line">4327</span><br><span class="line">4328</span><br><span class="line">4329</span><br><span class="line">4330</span><br><span class="line">4331</span><br><span class="line">4332</span><br><span class="line">4333</span><br><span class="line">4334</span><br><span class="line">4335</span><br><span class="line">4336</span><br><span class="line">4337</span><br><span class="line">4338</span><br><span class="line">4339</span><br><span class="line">4340</span><br><span class="line">4341</span><br><span class="line">4342</span><br><span class="line">4343</span><br><span class="line">4344</span><br><span class="line">4345</span><br><span class="line">4346</span><br><span class="line">4347</span><br><span class="line">4348</span><br><span class="line">4349</span><br><span class="line">4350</span><br><span class="line">4351</span><br><span class="line">4352</span><br><span class="line">4353</span><br><span class="line">4354</span><br><span class="line">4355</span><br><span class="line">4356</span><br><span class="line">4357</span><br><span class="line">4358</span><br><span class="line">4359</span><br><span class="line">4360</span><br><span class="line">4361</span><br><span class="line">4362</span><br><span class="line">4363</span><br><span class="line">4364</span><br><span class="line">4365</span><br><span class="line">4366</span><br><span class="line">4367</span><br><span class="line">4368</span><br><span class="line">4369</span><br><span class="line">4370</span><br><span class="line">4371</span><br><span class="line">4372</span><br><span class="line">4373</span><br><span class="line">4374</span><br><span class="line">4375</span><br><span class="line">4376</span><br><span class="line">4377</span><br><span class="line">4378</span><br><span class="line">4379</span><br><span class="line">4380</span><br><span class="line">4381</span><br><span class="line">4382</span><br><span class="line">4383</span><br><span class="line">4384</span><br><span class="line">4385</span><br><span class="line">4386</span><br><span class="line">4387</span><br><span class="line">4388</span><br><span class="line">4389</span><br><span class="line">4390</span><br><span class="line">4391</span><br><span class="line">4392</span><br><span class="line">4393</span><br><span class="line">4394</span><br><span class="line">4395</span><br><span class="line">4396</span><br><span class="line">4397</span><br><span class="line">4398</span><br><span class="line">4399</span><br><span class="line">4400</span><br><span class="line">4401</span><br><span class="line">4402</span><br><span class="line">4403</span><br><span class="line">4404</span><br><span class="line">4405</span><br><span class="line">4406</span><br><span class="line">4407</span><br><span class="line">4408</span><br><span class="line">4409</span><br><span class="line">4410</span><br><span class="line">4411</span><br><span class="line">4412</span><br><span class="line">4413</span><br><span class="line">4414</span><br><span class="line">4415</span><br><span class="line">4416</span><br><span class="line">4417</span><br><span class="line">4418</span><br><span class="line">4419</span><br><span class="line">4420</span><br><span class="line">4421</span><br><span class="line">4422</span><br><span class="line">4423</span><br><span class="line">4424</span><br><span class="line">4425</span><br><span class="line">4426</span><br><span class="line">4427</span><br><span class="line">4428</span><br><span class="line">4429</span><br><span class="line">4430</span><br><span class="line">4431</span><br><span class="line">4432</span><br><span class="line">4433</span><br><span class="line">4434</span><br><span class="line">4435</span><br><span class="line">4436</span><br><span class="line">4437</span><br><span class="line">4438</span><br><span class="line">4439</span><br><span class="line">4440</span><br><span class="line">4441</span><br><span class="line">4442</span><br><span class="line">4443</span><br><span class="line">4444</span><br><span class="line">4445</span><br><span class="line">4446</span><br><span class="line">4447</span><br><span class="line">4448</span><br><span class="line">4449</span><br><span class="line">4450</span><br><span class="line">4451</span><br><span class="line">4452</span><br><span class="line">4453</span><br><span class="line">4454</span><br><span class="line">4455</span><br><span class="line">4456</span><br><span class="line">4457</span><br><span class="line">4458</span><br><span class="line">4459</span><br><span class="line">4460</span><br><span class="line">4461</span><br><span class="line">4462</span><br><span class="line">4463</span><br><span class="line">4464</span><br><span class="line">4465</span><br><span class="line">4466</span><br><span class="line">4467</span><br><span class="line">4468</span><br><span class="line">4469</span><br><span class="line">4470</span><br><span class="line">4471</span><br><span class="line">4472</span><br><span class="line">4473</span><br><span class="line">4474</span><br><span class="line">4475</span><br><span class="line">4476</span><br><span class="line">4477</span><br><span class="line">4478</span><br><span class="line">4479</span><br><span class="line">4480</span><br><span class="line">4481</span><br><span class="line">4482</span><br><span class="line">4483</span><br><span class="line">4484</span><br><span class="line">4485</span><br><span class="line">4486</span><br><span class="line">4487</span><br><span class="line">4488</span><br><span class="line">4489</span><br><span class="line">4490</span><br><span class="line">4491</span><br><span class="line">4492</span><br><span class="line">4493</span><br><span class="line">4494</span><br><span class="line">4495</span><br><span class="line">4496</span><br><span class="line">4497</span><br><span class="line">4498</span><br><span class="line">4499</span><br><span class="line">4500</span><br><span class="line">4501</span><br><span class="line">4502</span><br><span class="line">4503</span><br><span class="line">4504</span><br><span class="line">4505</span><br><span class="line">4506</span><br><span class="line">4507</span><br><span class="line">4508</span><br><span class="line">4509</span><br><span class="line">4510</span><br><span class="line">4511</span><br><span class="line">4512</span><br><span class="line">4513</span><br><span class="line">4514</span><br><span class="line">4515</span><br><span class="line">4516</span><br><span class="line">4517</span><br><span class="line">4518</span><br><span class="line">4519</span><br><span class="line">4520</span><br><span class="line">4521</span><br><span class="line">4522</span><br><span class="line">4523</span><br><span class="line">4524</span><br><span class="line">4525</span><br><span class="line">4526</span><br><span class="line">4527</span><br><span class="line">4528</span><br><span class="line">4529</span><br><span class="line">4530</span><br><span class="line">4531</span><br><span class="line">4532</span><br><span class="line">4533</span><br><span class="line">4534</span><br><span class="line">4535</span><br><span class="line">4536</span><br><span class="line">4537</span><br><span class="line">4538</span><br><span class="line">4539</span><br><span class="line">4540</span><br><span class="line">4541</span><br><span class="line">4542</span><br><span class="line">4543</span><br><span class="line">4544</span><br><span class="line">4545</span><br><span class="line">4546</span><br><span class="line">4547</span><br><span class="line">4548</span><br><span class="line">4549</span><br><span class="line">4550</span><br><span class="line">4551</span><br><span class="line">4552</span><br><span class="line">4553</span><br><span class="line">4554</span><br><span class="line">4555</span><br><span class="line">4556</span><br><span class="line">4557</span><br><span class="line">4558</span><br><span class="line">4559</span><br><span class="line">4560</span><br><span class="line">4561</span><br><span class="line">4562</span><br><span class="line">4563</span><br><span class="line">4564</span><br><span class="line">4565</span><br><span class="line">4566</span><br><span class="line">4567</span><br><span class="line">4568</span><br><span class="line">4569</span><br><span class="line">4570</span><br><span class="line">4571</span><br><span class="line">4572</span><br><span class="line">4573</span><br><span class="line">4574</span><br><span class="line">4575</span><br><span class="line">4576</span><br><span class="line">4577</span><br><span class="line">4578</span><br><span class="line">4579</span><br><span class="line">4580</span><br><span class="line">4581</span><br><span class="line">4582</span><br><span class="line">4583</span><br><span class="line">4584</span><br><span class="line">4585</span><br><span class="line">4586</span><br><span class="line">4587</span><br><span class="line">4588</span><br><span class="line">4589</span><br><span class="line">4590</span><br><span class="line">4591</span><br><span class="line">4592</span><br><span class="line">4593</span><br><span class="line">4594</span><br><span class="line">4595</span><br><span class="line">4596</span><br><span class="line">4597</span><br><span class="line">4598</span><br><span class="line">4599</span><br><span class="line">4600</span><br><span class="line">4601</span><br><span class="line">4602</span><br><span class="line">4603</span><br><span class="line">4604</span><br><span class="line">4605</span><br><span class="line">4606</span><br><span class="line">4607</span><br><span class="line">4608</span><br><span class="line">4609</span><br><span class="line">4610</span><br><span class="line">4611</span><br><span class="line">4612</span><br><span class="line">4613</span><br><span class="line">4614</span><br><span class="line">4615</span><br><span class="line">4616</span><br><span class="line">4617</span><br><span class="line">4618</span><br><span class="line">4619</span><br><span class="line">4620</span><br><span class="line">4621</span><br><span class="line">4622</span><br><span class="line">4623</span><br><span class="line">4624</span><br><span class="line">4625</span><br><span class="line">4626</span><br><span class="line">4627</span><br><span class="line">4628</span><br><span class="line">4629</span><br><span class="line">4630</span><br><span class="line">4631</span><br><span class="line">4632</span><br><span class="line">4633</span><br><span class="line">4634</span><br><span class="line">4635</span><br><span class="line">4636</span><br><span class="line">4637</span><br><span class="line">4638</span><br><span class="line">4639</span><br><span class="line">4640</span><br><span class="line">4641</span><br><span class="line">4642</span><br><span class="line">4643</span><br><span class="line">4644</span><br><span class="line">4645</span><br><span class="line">4646</span><br><span class="line">4647</span><br><span class="line">4648</span><br><span class="line">4649</span><br><span class="line">4650</span><br><span class="line">4651</span><br><span class="line">4652</span><br><span class="line">4653</span><br><span class="line">4654</span><br><span class="line">4655</span><br><span class="line">4656</span><br><span class="line">4657</span><br><span class="line">4658</span><br><span class="line">4659</span><br><span class="line">4660</span><br><span class="line">4661</span><br><span class="line">4662</span><br><span class="line">4663</span><br><span class="line">4664</span><br><span class="line">4665</span><br><span class="line">4666</span><br><span class="line">4667</span><br><span class="line">4668</span><br><span class="line">4669</span><br><span class="line">4670</span><br><span class="line">4671</span><br><span class="line">4672</span><br><span class="line">4673</span><br><span class="line">4674</span><br><span class="line">4675</span><br><span class="line">4676</span><br><span class="line">4677</span><br><span class="line">4678</span><br><span class="line">4679</span><br><span class="line">4680</span><br><span class="line">4681</span><br><span class="line">4682</span><br><span class="line">4683</span><br><span class="line">4684</span><br><span class="line">4685</span><br><span class="line">4686</span><br><span class="line">4687</span><br><span class="line">4688</span><br><span class="line">4689</span><br><span class="line">4690</span><br><span class="line">4691</span><br><span class="line">4692</span><br><span class="line">4693</span><br><span class="line">4694</span><br><span class="line">4695</span><br><span class="line">4696</span><br><span class="line">4697</span><br><span class="line">4698</span><br><span class="line">4699</span><br><span class="line">4700</span><br><span class="line">4701</span><br><span class="line">4702</span><br><span class="line">4703</span><br><span class="line">4704</span><br><span class="line">4705</span><br><span class="line">4706</span><br><span class="line">4707</span><br><span class="line">4708</span><br><span class="line">4709</span><br><span class="line">4710</span><br><span class="line">4711</span><br><span class="line">4712</span><br><span class="line">4713</span><br><span class="line">4714</span><br><span class="line">4715</span><br><span class="line">4716</span><br><span class="line">4717</span><br><span class="line">4718</span><br><span class="line">4719</span><br><span class="line">4720</span><br><span class="line">4721</span><br><span class="line">4722</span><br><span class="line">4723</span><br><span class="line">4724</span><br><span class="line">4725</span><br><span class="line">4726</span><br><span class="line">4727</span><br><span class="line">4728</span><br><span class="line">4729</span><br><span class="line">4730</span><br><span class="line">4731</span><br><span class="line">4732</span><br><span class="line">4733</span><br><span class="line">4734</span><br><span class="line">4735</span><br><span class="line">4736</span><br><span class="line">4737</span><br><span class="line">4738</span><br><span class="line">4739</span><br><span class="line">4740</span><br><span class="line">4741</span><br><span class="line">4742</span><br><span class="line">4743</span><br><span class="line">4744</span><br><span class="line">4745</span><br><span class="line">4746</span><br><span class="line">4747</span><br><span class="line">4748</span><br><span class="line">4749</span><br><span class="line">4750</span><br><span class="line">4751</span><br><span class="line">4752</span><br><span class="line">4753</span><br><span class="line">4754</span><br><span class="line">4755</span><br><span class="line">4756</span><br><span class="line">4757</span><br><span class="line">4758</span><br><span class="line">4759</span><br><span class="line">4760</span><br><span class="line">4761</span><br><span class="line">4762</span><br><span class="line">4763</span><br><span class="line">4764</span><br><span class="line">4765</span><br><span class="line">4766</span><br><span class="line">4767</span><br><span class="line">4768</span><br><span class="line">4769</span><br><span class="line">4770</span><br><span class="line">4771</span><br><span class="line">4772</span><br><span class="line">4773</span><br><span class="line">4774</span><br><span class="line">4775</span><br><span class="line">4776</span><br><span class="line">4777</span><br><span class="line">4778</span><br><span class="line">4779</span><br><span class="line">4780</span><br><span class="line">4781</span><br><span class="line">4782</span><br><span class="line">4783</span><br><span class="line">4784</span><br><span class="line">4785</span><br><span class="line">4786</span><br><span class="line">4787</span><br><span class="line">4788</span><br><span class="line">4789</span><br><span class="line">4790</span><br><span class="line">4791</span><br><span class="line">4792</span><br><span class="line">4793</span><br><span class="line">4794</span><br><span class="line">4795</span><br><span class="line">4796</span><br><span class="line">4797</span><br><span class="line">4798</span><br><span class="line">4799</span><br><span class="line">4800</span><br><span class="line">4801</span><br><span class="line">4802</span><br><span class="line">4803</span><br><span class="line">4804</span><br><span class="line">4805</span><br><span class="line">4806</span><br><span class="line">4807</span><br><span class="line">4808</span><br><span class="line">4809</span><br><span class="line">4810</span><br><span class="line">4811</span><br><span class="line">4812</span><br><span class="line">4813</span><br><span class="line">4814</span><br><span class="line">4815</span><br><span class="line">4816</span><br><span class="line">4817</span><br><span class="line">4818</span><br><span class="line">4819</span><br><span class="line">4820</span><br><span class="line">4821</span><br><span class="line">4822</span><br><span class="line">4823</span><br><span class="line">4824</span><br><span class="line">4825</span><br><span class="line">4826</span><br><span class="line">4827</span><br><span class="line">4828</span><br><span class="line">4829</span><br><span class="line">4830</span><br><span class="line">4831</span><br><span class="line">4832</span><br><span class="line">4833</span><br><span class="line">4834</span><br><span class="line">4835</span><br><span class="line">4836</span><br><span class="line">4837</span><br><span class="line">4838</span><br><span class="line">4839</span><br><span class="line">4840</span><br><span class="line">4841</span><br><span class="line">4842</span><br><span class="line">4843</span><br><span class="line">4844</span><br><span class="line">4845</span><br><span class="line">4846</span><br><span class="line">4847</span><br><span class="line">4848</span><br><span class="line">4849</span><br><span class="line">4850</span><br><span class="line">4851</span><br><span class="line">4852</span><br><span class="line">4853</span><br><span class="line">4854</span><br><span class="line">4855</span><br><span class="line">4856</span><br><span class="line">4857</span><br><span class="line">4858</span><br><span class="line">4859</span><br><span class="line">4860</span><br><span class="line">4861</span><br><span class="line">4862</span><br><span class="line">4863</span><br><span class="line">4864</span><br><span class="line">4865</span><br><span class="line">4866</span><br><span class="line">4867</span><br><span class="line">4868</span><br><span class="line">4869</span><br><span class="line">4870</span><br><span class="line">4871</span><br><span class="line">4872</span><br><span class="line">4873</span><br><span class="line">4874</span><br><span class="line">4875</span><br><span class="line">4876</span><br><span class="line">4877</span><br><span class="line">4878</span><br><span class="line">4879</span><br><span class="line">4880</span><br><span class="line">4881</span><br><span class="line">4882</span><br><span class="line">4883</span><br><span class="line">4884</span><br><span class="line">4885</span><br><span class="line">4886</span><br><span class="line">4887</span><br><span class="line">4888</span><br><span class="line">4889</span><br><span class="line">4890</span><br><span class="line">4891</span><br><span class="line">4892</span><br><span class="line">4893</span><br><span class="line">4894</span><br><span class="line">4895</span><br><span class="line">4896</span><br><span class="line">4897</span><br><span class="line">4898</span><br><span class="line">4899</span><br><span class="line">4900</span><br><span class="line">4901</span><br><span class="line">4902</span><br><span class="line">4903</span><br><span class="line">4904</span><br><span class="line">4905</span><br><span class="line">4906</span><br><span class="line">4907</span><br><span class="line">4908</span><br><span class="line">4909</span><br><span class="line">4910</span><br><span class="line">4911</span><br><span class="line">4912</span><br><span class="line">4913</span><br><span class="line">4914</span><br><span class="line">4915</span><br><span class="line">4916</span><br><span class="line">4917</span><br><span class="line">4918</span><br><span class="line">4919</span><br><span class="line">4920</span><br><span class="line">4921</span><br><span class="line">4922</span><br><span class="line">4923</span><br><span class="line">4924</span><br><span class="line">4925</span><br><span class="line">4926</span><br><span class="line">4927</span><br><span class="line">4928</span><br><span class="line">4929</span><br><span class="line">4930</span><br><span class="line">4931</span><br><span class="line">4932</span><br><span class="line">4933</span><br><span class="line">4934</span><br><span class="line">4935</span><br><span class="line">4936</span><br><span class="line">4937</span><br><span class="line">4938</span><br><span class="line">4939</span><br><span class="line">4940</span><br><span class="line">4941</span><br><span class="line">4942</span><br><span class="line">4943</span><br><span class="line">4944</span><br><span class="line">4945</span><br><span class="line">4946</span><br><span class="line">4947</span><br><span class="line">4948</span><br><span class="line">4949</span><br><span class="line">4950</span><br><span class="line">4951</span><br><span class="line">4952</span><br><span class="line">4953</span><br><span class="line">4954</span><br><span class="line">4955</span><br><span class="line">4956</span><br><span class="line">4957</span><br><span class="line">4958</span><br><span class="line">4959</span><br><span class="line">4960</span><br><span class="line">4961</span><br><span class="line">4962</span><br><span class="line">4963</span><br><span class="line">4964</span><br><span class="line">4965</span><br><span class="line">4966</span><br><span class="line">4967</span><br><span class="line">4968</span><br><span class="line">4969</span><br><span class="line">4970</span><br><span class="line">4971</span><br><span class="line">4972</span><br><span class="line">4973</span><br><span class="line">4974</span><br><span class="line">4975</span><br><span class="line">4976</span><br><span class="line">4977</span><br><span class="line">4978</span><br><span class="line">4979</span><br><span class="line">4980</span><br><span class="line">4981</span><br><span class="line">4982</span><br><span class="line">4983</span><br><span class="line">4984</span><br><span class="line">4985</span><br><span class="line">4986</span><br><span class="line">4987</span><br><span class="line">4988</span><br><span class="line">4989</span><br><span class="line">4990</span><br><span class="line">4991</span><br><span class="line">4992</span><br><span class="line">4993</span><br><span class="line">4994</span><br><span class="line">4995</span><br><span class="line">4996</span><br><span class="line">4997</span><br><span class="line">4998</span><br><span class="line">4999</span><br><span class="line">5000</span><br><span class="line">5001</span><br><span class="line">5002</span><br><span class="line">5003</span><br><span class="line">5004</span><br><span class="line">5005</span><br><span class="line">5006</span><br><span class="line">5007</span><br><span class="line">5008</span><br><span class="line">5009</span><br><span class="line">5010</span><br><span class="line">5011</span><br><span class="line">5012</span><br><span class="line">5013</span><br><span class="line">5014</span><br><span class="line">5015</span><br><span class="line">5016</span><br><span class="line">5017</span><br><span class="line">5018</span><br><span class="line">5019</span><br><span class="line">5020</span><br><span class="line">5021</span><br><span class="line">5022</span><br><span class="line">5023</span><br><span class="line">5024</span><br><span class="line">5025</span><br><span class="line">5026</span><br><span class="line">5027</span><br><span class="line">5028</span><br><span class="line">5029</span><br><span class="line">5030</span><br><span class="line">5031</span><br><span class="line">5032</span><br><span class="line">5033</span><br><span class="line">5034</span><br><span class="line">5035</span><br><span class="line">5036</span><br><span class="line">5037</span><br><span class="line">5038</span><br><span class="line">5039</span><br><span class="line">5040</span><br><span class="line">5041</span><br><span class="line">5042</span><br><span class="line">5043</span><br><span class="line">5044</span><br><span class="line">5045</span><br><span class="line">5046</span><br><span class="line">5047</span><br><span class="line">5048</span><br><span class="line">5049</span><br><span class="line">5050</span><br><span class="line">5051</span><br><span class="line">5052</span><br><span class="line">5053</span><br><span class="line">5054</span><br><span class="line">5055</span><br><span class="line">5056</span><br><span class="line">5057</span><br><span class="line">5058</span><br><span class="line">5059</span><br><span class="line">5060</span><br><span class="line">5061</span><br><span class="line">5062</span><br><span class="line">5063</span><br><span class="line">5064</span><br><span class="line">5065</span><br><span class="line">5066</span><br><span class="line">5067</span><br><span class="line">5068</span><br><span class="line">5069</span><br><span class="line">5070</span><br><span class="line">5071</span><br><span class="line">5072</span><br><span class="line">5073</span><br><span class="line">5074</span><br><span class="line">5075</span><br><span class="line">5076</span><br><span class="line">5077</span><br><span class="line">5078</span><br><span class="line">5079</span><br><span class="line">5080</span><br><span class="line">5081</span><br><span class="line">5082</span><br><span class="line">5083</span><br><span class="line">5084</span><br><span class="line">5085</span><br><span class="line">5086</span><br><span class="line">5087</span><br><span class="line">5088</span><br><span class="line">5089</span><br><span class="line">5090</span><br><span class="line">5091</span><br><span class="line">5092</span><br><span class="line">5093</span><br><span class="line">5094</span><br><span class="line">5095</span><br><span class="line">5096</span><br><span class="line">5097</span><br><span class="line">5098</span><br><span class="line">5099</span><br><span class="line">5100</span><br><span class="line">5101</span><br><span class="line">5102</span><br><span class="line">5103</span><br><span class="line">5104</span><br><span class="line">5105</span><br><span class="line">5106</span><br><span class="line">5107</span><br><span class="line">5108</span><br><span class="line">5109</span><br><span class="line">5110</span><br><span class="line">5111</span><br><span class="line">5112</span><br><span class="line">5113</span><br><span class="line">5114</span><br><span class="line">5115</span><br><span class="line">5116</span><br><span class="line">5117</span><br><span class="line">5118</span><br><span class="line">5119</span><br><span class="line">5120</span><br><span class="line">5121</span><br><span class="line">5122</span><br><span class="line">5123</span><br><span class="line">5124</span><br><span class="line">5125</span><br><span class="line">5126</span><br><span class="line">5127</span><br><span class="line">5128</span><br><span class="line">5129</span><br><span class="line">5130</span><br><span class="line">5131</span><br><span class="line">5132</span><br><span class="line">5133</span><br><span class="line">5134</span><br><span class="line">5135</span><br><span class="line">5136</span><br><span class="line">5137</span><br><span class="line">5138</span><br><span class="line">5139</span><br><span class="line">5140</span><br><span class="line">5141</span><br><span class="line">5142</span><br><span class="line">5143</span><br><span class="line">5144</span><br><span class="line">5145</span><br><span class="line">5146</span><br><span class="line">5147</span><br><span class="line">5148</span><br><span class="line">5149</span><br><span class="line">5150</span><br><span class="line">5151</span><br><span class="line">5152</span><br><span class="line">5153</span><br><span class="line">5154</span><br><span class="line">5155</span><br><span class="line">5156</span><br><span class="line">5157</span><br><span class="line">5158</span><br><span class="line">5159</span><br><span class="line">5160</span><br><span class="line">5161</span><br><span class="line">5162</span><br><span class="line">5163</span><br><span class="line">5164</span><br><span class="line">5165</span><br><span class="line">5166</span><br><span class="line">5167</span><br><span class="line">5168</span><br><span class="line">5169</span><br><span class="line">5170</span><br><span class="line">5171</span><br><span class="line">5172</span><br><span class="line">5173</span><br><span class="line">5174</span><br><span class="line">5175</span><br><span class="line">5176</span><br><span class="line">5177</span><br><span class="line">5178</span><br><span class="line">5179</span><br><span class="line">5180</span><br><span class="line">5181</span><br><span class="line">5182</span><br><span class="line">5183</span><br><span class="line">5184</span><br><span class="line">5185</span><br><span class="line">5186</span><br><span class="line">5187</span><br><span class="line">5188</span><br><span class="line">5189</span><br><span class="line">5190</span><br><span class="line">5191</span><br><span class="line">5192</span><br><span class="line">5193</span><br><span class="line">5194</span><br><span class="line">5195</span><br><span class="line">5196</span><br><span class="line">5197</span><br><span class="line">5198</span><br><span class="line">5199</span><br><span class="line">5200</span><br><span class="line">5201</span><br><span class="line">5202</span><br><span class="line">5203</span><br><span class="line">5204</span><br><span class="line">5205</span><br><span class="line">5206</span><br><span class="line">5207</span><br><span class="line">5208</span><br><span class="line">5209</span><br><span class="line">5210</span><br><span class="line">5211</span><br><span class="line">5212</span><br><span class="line">5213</span><br><span class="line">5214</span><br><span class="line">5215</span><br><span class="line">5216</span><br><span class="line">5217</span><br><span class="line">5218</span><br><span class="line">5219</span><br><span class="line">5220</span><br><span class="line">5221</span><br><span class="line">5222</span><br><span class="line">5223</span><br><span class="line">5224</span><br><span class="line">5225</span><br><span class="line">5226</span><br><span class="line">5227</span><br><span class="line">5228</span><br><span class="line">5229</span><br><span class="line">5230</span><br><span class="line">5231</span><br><span class="line">5232</span><br><span class="line">5233</span><br><span class="line">5234</span><br><span class="line">5235</span><br><span class="line">5236</span><br><span class="line">5237</span><br><span class="line">5238</span><br><span class="line">5239</span><br><span class="line">5240</span><br><span class="line">5241</span><br><span class="line">5242</span><br><span class="line">5243</span><br><span class="line">5244</span><br><span class="line">5245</span><br><span class="line">5246</span><br><span class="line">5247</span><br><span class="line">5248</span><br><span class="line">5249</span><br><span class="line">5250</span><br><span class="line">5251</span><br><span class="line">5252</span><br><span class="line">5253</span><br><span class="line">5254</span><br><span class="line">5255</span><br><span class="line">5256</span><br><span class="line">5257</span><br><span class="line">5258</span><br><span class="line">5259</span><br><span class="line">5260</span><br><span class="line">5261</span><br><span class="line">5262</span><br><span class="line">5263</span><br><span class="line">5264</span><br><span class="line">5265</span><br><span class="line">5266</span><br><span class="line">5267</span><br><span class="line">5268</span><br><span class="line">5269</span><br><span class="line">5270</span><br><span class="line">5271</span><br><span class="line">5272</span><br><span class="line">5273</span><br><span class="line">5274</span><br><span class="line">5275</span><br><span class="line">5276</span><br><span class="line">5277</span><br><span class="line">5278</span><br><span class="line">5279</span><br><span class="line">5280</span><br><span class="line">5281</span><br><span class="line">5282</span><br><span class="line">5283</span><br><span class="line">5284</span><br><span class="line">5285</span><br><span class="line">5286</span><br><span class="line">5287</span><br><span class="line">5288</span><br><span class="line">5289</span><br><span class="line">5290</span><br><span class="line">5291</span><br><span class="line">5292</span><br><span class="line">5293</span><br><span class="line">5294</span><br><span class="line">5295</span><br><span class="line">5296</span><br><span class="line">5297</span><br><span class="line">5298</span><br><span class="line">5299</span><br><span class="line">5300</span><br><span class="line">5301</span><br><span class="line">5302</span><br><span class="line">5303</span><br><span class="line">5304</span><br><span class="line">5305</span><br><span class="line">5306</span><br><span class="line">5307</span><br><span class="line">5308</span><br><span class="line">5309</span><br><span class="line">5310</span><br><span class="line">5311</span><br><span class="line">5312</span><br><span class="line">5313</span><br><span class="line">5314</span><br><span class="line">5315</span><br><span class="line">5316</span><br><span class="line">5317</span><br><span class="line">5318</span><br><span class="line">5319</span><br><span class="line">5320</span><br><span class="line">5321</span><br><span class="line">5322</span><br><span class="line">5323</span><br><span class="line">5324</span><br><span class="line">5325</span><br><span class="line">5326</span><br><span class="line">5327</span><br><span class="line">5328</span><br><span class="line">5329</span><br><span class="line">5330</span><br><span class="line">5331</span><br><span class="line">5332</span><br><span class="line">5333</span><br><span class="line">5334</span><br><span class="line">5335</span><br><span class="line">5336</span><br><span class="line">5337</span><br><span class="line">5338</span><br><span class="line">5339</span><br><span class="line">5340</span><br><span class="line">5341</span><br><span class="line">5342</span><br><span class="line">5343</span><br><span class="line">5344</span><br><span class="line">5345</span><br><span class="line">5346</span><br><span class="line">5347</span><br><span class="line">5348</span><br><span class="line">5349</span><br><span class="line">5350</span><br><span class="line">5351</span><br><span class="line">5352</span><br><span class="line">5353</span><br><span class="line">5354</span><br><span class="line">5355</span><br><span class="line">5356</span><br><span class="line">5357</span><br><span class="line">5358</span><br><span class="line">5359</span><br><span class="line">5360</span><br><span class="line">5361</span><br><span class="line">5362</span><br><span class="line">5363</span><br><span class="line">5364</span><br><span class="line">5365</span><br><span class="line">5366</span><br><span class="line">5367</span><br><span class="line">5368</span><br><span class="line">5369</span><br><span class="line">5370</span><br><span class="line">5371</span><br><span class="line">5372</span><br><span class="line">5373</span><br><span class="line">5374</span><br><span class="line">5375</span><br><span class="line">5376</span><br><span class="line">5377</span><br><span class="line">5378</span><br><span class="line">5379</span><br><span class="line">5380</span><br><span class="line">5381</span><br><span class="line">5382</span><br><span class="line">5383</span><br><span class="line">5384</span><br><span class="line">5385</span><br><span class="line">5386</span><br><span class="line">5387</span><br><span class="line">5388</span><br><span class="line">5389</span><br><span class="line">5390</span><br><span class="line">5391</span><br><span class="line">5392</span><br><span class="line">5393</span><br><span class="line">5394</span><br><span class="line">5395</span><br><span class="line">5396</span><br><span class="line">5397</span><br><span class="line">5398</span><br><span class="line">5399</span><br><span class="line">5400</span><br><span class="line">5401</span><br><span class="line">5402</span><br><span class="line">5403</span><br><span class="line">5404</span><br><span class="line">5405</span><br><span class="line">5406</span><br><span class="line">5407</span><br><span class="line">5408</span><br><span class="line">5409</span><br><span class="line">5410</span><br><span class="line">5411</span><br><span class="line">5412</span><br><span class="line">5413</span><br><span class="line">5414</span><br><span class="line">5415</span><br><span class="line">5416</span><br><span class="line">5417</span><br><span class="line">5418</span><br><span class="line">5419</span><br><span class="line">5420</span><br><span class="line">5421</span><br><span class="line">5422</span><br><span class="line">5423</span><br><span class="line">5424</span><br><span class="line">5425</span><br><span class="line">5426</span><br><span class="line">5427</span><br><span class="line">5428</span><br><span class="line">5429</span><br><span class="line">5430</span><br><span class="line">5431</span><br><span class="line">5432</span><br><span class="line">5433</span><br><span class="line">5434</span><br><span class="line">5435</span><br><span class="line">5436</span><br><span class="line">5437</span><br><span class="line">5438</span><br><span class="line">5439</span><br><span class="line">5440</span><br><span class="line">5441</span><br><span class="line">5442</span><br><span class="line">5443</span><br><span class="line">5444</span><br><span class="line">5445</span><br><span class="line">5446</span><br><span class="line">5447</span><br><span class="line">5448</span><br><span class="line">5449</span><br><span class="line">5450</span><br><span class="line">5451</span><br><span class="line">5452</span><br><span class="line">5453</span><br><span class="line">5454</span><br><span class="line">5455</span><br><span class="line">5456</span><br><span class="line">5457</span><br><span class="line">5458</span><br><span class="line">5459</span><br><span class="line">5460</span><br><span class="line">5461</span><br><span class="line">5462</span><br><span class="line">5463</span><br><span class="line">5464</span><br><span class="line">5465</span><br><span class="line">5466</span><br><span class="line">5467</span><br><span class="line">5468</span><br><span class="line">5469</span><br><span class="line">5470</span><br><span class="line">5471</span><br><span class="line">5472</span><br><span class="line">5473</span><br><span class="line">5474</span><br><span class="line">5475</span><br><span class="line">5476</span><br><span class="line">5477</span><br><span class="line">5478</span><br><span class="line">5479</span><br><span class="line">5480</span><br><span class="line">5481</span><br><span class="line">5482</span><br><span class="line">5483</span><br><span class="line">5484</span><br><span class="line">5485</span><br><span class="line">5486</span><br><span class="line">5487</span><br><span class="line">5488</span><br><span class="line">5489</span><br><span class="line">5490</span><br><span class="line">5491</span><br><span class="line">5492</span><br><span class="line">5493</span><br><span class="line">5494</span><br><span class="line">5495</span><br><span class="line">5496</span><br><span class="line">5497</span><br><span class="line">5498</span><br><span class="line">5499</span><br><span class="line">5500</span><br><span class="line">5501</span><br><span class="line">5502</span><br><span class="line">5503</span><br><span class="line">5504</span><br><span class="line">5505</span><br><span class="line">5506</span><br><span class="line">5507</span><br><span class="line">5508</span><br><span class="line">5509</span><br><span class="line">5510</span><br><span class="line">5511</span><br><span class="line">5512</span><br><span class="line">5513</span><br><span class="line">5514</span><br><span class="line">5515</span><br><span class="line">5516</span><br><span class="line">5517</span><br><span class="line">5518</span><br><span class="line">5519</span><br><span class="line">5520</span><br><span class="line">5521</span><br><span class="line">5522</span><br><span class="line">5523</span><br><span class="line">5524</span><br><span class="line">5525</span><br><span class="line">5526</span><br><span class="line">5527</span><br><span class="line">5528</span><br><span class="line">5529</span><br><span class="line">5530</span><br><span class="line">5531</span><br><span class="line">5532</span><br><span class="line">5533</span><br><span class="line">5534</span><br><span class="line">5535</span><br><span class="line">5536</span><br><span class="line">5537</span><br><span class="line">5538</span><br><span class="line">5539</span><br><span class="line">5540</span><br><span class="line">5541</span><br><span class="line">5542</span><br><span class="line">5543</span><br><span class="line">5544</span><br><span class="line">5545</span><br><span class="line">5546</span><br><span class="line">5547</span><br><span class="line">5548</span><br><span class="line">5549</span><br><span class="line">5550</span><br><span class="line">5551</span><br><span class="line">5552</span><br><span class="line">5553</span><br><span class="line">5554</span><br><span class="line">5555</span><br><span class="line">5556</span><br><span class="line">5557</span><br><span class="line">5558</span><br><span class="line">5559</span><br><span class="line">5560</span><br><span class="line">5561</span><br><span class="line">5562</span><br><span class="line">5563</span><br><span class="line">5564</span><br><span class="line">5565</span><br><span class="line">5566</span><br><span class="line">5567</span><br><span class="line">5568</span><br><span class="line">5569</span><br><span class="line">5570</span><br><span class="line">5571</span><br><span class="line">5572</span><br><span class="line">5573</span><br><span class="line">5574</span><br><span class="line">5575</span><br><span class="line">5576</span><br><span class="line">5577</span><br><span class="line">5578</span><br><span class="line">5579</span><br><span class="line">5580</span><br><span class="line">5581</span><br><span class="line">5582</span><br><span class="line">5583</span><br><span class="line">5584</span><br><span class="line">5585</span><br><span class="line">5586</span><br><span class="line">5587</span><br><span class="line">5588</span><br><span class="line">5589</span><br><span class="line">5590</span><br><span class="line">5591</span><br><span class="line">5592</span><br><span class="line">5593</span><br><span class="line">5594</span><br><span class="line">5595</span><br><span class="line">5596</span><br><span class="line">5597</span><br><span class="line">5598</span><br><span class="line">5599</span><br><span class="line">5600</span><br><span class="line">5601</span><br><span class="line">5602</span><br><span class="line">5603</span><br><span class="line">5604</span><br><span class="line">5605</span><br><span class="line">5606</span><br><span class="line">5607</span><br><span class="line">5608</span><br><span class="line">5609</span><br><span class="line">5610</span><br><span class="line">5611</span><br><span class="line">5612</span><br><span class="line">5613</span><br><span class="line">5614</span><br><span class="line">5615</span><br><span class="line">5616</span><br><span class="line">5617</span><br><span class="line">5618</span><br><span class="line">5619</span><br><span class="line">5620</span><br><span class="line">5621</span><br><span class="line">5622</span><br><span class="line">5623</span><br><span class="line">5624</span><br><span class="line">5625</span><br><span class="line">5626</span><br><span class="line">5627</span><br><span class="line">5628</span><br><span class="line">5629</span><br><span class="line">5630</span><br><span class="line">5631</span><br><span class="line">5632</span><br><span class="line">5633</span><br><span class="line">5634</span><br><span class="line">5635</span><br><span class="line">5636</span><br><span class="line">5637</span><br><span class="line">5638</span><br><span class="line">5639</span><br><span class="line">5640</span><br><span class="line">5641</span><br><span class="line">5642</span><br><span class="line">5643</span><br><span class="line">5644</span><br><span class="line">5645</span><br><span class="line">5646</span><br><span class="line">5647</span><br><span class="line">5648</span><br><span class="line">5649</span><br><span class="line">5650</span><br><span class="line">5651</span><br><span class="line">5652</span><br><span class="line">5653</span><br><span class="line">5654</span><br><span class="line">5655</span><br><span class="line">5656</span><br><span class="line">5657</span><br><span class="line">5658</span><br><span class="line">5659</span><br><span class="line">5660</span><br><span class="line">5661</span><br><span class="line">5662</span><br><span class="line">5663</span><br><span class="line">5664</span><br><span class="line">5665</span><br><span class="line">5666</span><br><span class="line">5667</span><br><span class="line">5668</span><br><span class="line">5669</span><br><span class="line">5670</span><br><span class="line">5671</span><br><span class="line">5672</span><br><span class="line">5673</span><br><span class="line">5674</span><br><span class="line">5675</span><br><span class="line">5676</span><br><span class="line">5677</span><br><span class="line">5678</span><br><span class="line">5679</span><br><span class="line">5680</span><br><span class="line">5681</span><br><span class="line">5682</span><br><span class="line">5683</span><br><span class="line">5684</span><br><span class="line">5685</span><br><span class="line">5686</span><br><span class="line">5687</span><br><span class="line">5688</span><br><span class="line">5689</span><br><span class="line">5690</span><br><span class="line">5691</span><br><span class="line">5692</span><br><span class="line">5693</span><br><span class="line">5694</span><br><span class="line">5695</span><br><span class="line">5696</span><br><span class="line">5697</span><br><span class="line">5698</span><br><span class="line">5699</span><br><span class="line">5700</span><br><span class="line">5701</span><br><span class="line">5702</span><br><span class="line">5703</span><br><span class="line">5704</span><br><span class="line">5705</span><br><span class="line">5706</span><br><span class="line">5707</span><br><span class="line">5708</span><br><span class="line">5709</span><br><span class="line">5710</span><br><span class="line">5711</span><br><span class="line">5712</span><br><span class="line">5713</span><br><span class="line">5714</span><br><span class="line">5715</span><br><span class="line">5716</span><br><span class="line">5717</span><br><span class="line">5718</span><br><span class="line">5719</span><br><span class="line">5720</span><br><span class="line">5721</span><br><span class="line">5722</span><br><span class="line">5723</span><br><span class="line">5724</span><br><span class="line">5725</span><br><span class="line">5726</span><br><span class="line">5727</span><br><span class="line">5728</span><br><span class="line">5729</span><br><span class="line">5730</span><br><span class="line">5731</span><br><span class="line">5732</span><br><span class="line">5733</span><br><span class="line">5734</span><br><span class="line">5735</span><br><span class="line">5736</span><br><span class="line">5737</span><br><span class="line">5738</span><br><span class="line">5739</span><br><span class="line">5740</span><br><span class="line">5741</span><br><span class="line">5742</span><br><span class="line">5743</span><br><span class="line">5744</span><br><span class="line">5745</span><br><span class="line">5746</span><br><span class="line">5747</span><br><span class="line">5748</span><br><span class="line">5749</span><br><span class="line">5750</span><br><span class="line">5751</span><br><span class="line">5752</span><br><span class="line">5753</span><br><span class="line">5754</span><br><span class="line">5755</span><br><span class="line">5756</span><br><span class="line">5757</span><br><span class="line">5758</span><br><span class="line">5759</span><br><span class="line">5760</span><br><span class="line">5761</span><br><span class="line">5762</span><br><span class="line">5763</span><br><span class="line">5764</span><br><span class="line">5765</span><br><span class="line">5766</span><br><span class="line">5767</span><br><span class="line">5768</span><br><span class="line">5769</span><br><span class="line">5770</span><br><span class="line">5771</span><br><span class="line">5772</span><br><span class="line">5773</span><br><span class="line">5774</span><br><span class="line">5775</span><br><span class="line">5776</span><br><span class="line">5777</span><br><span class="line">5778</span><br><span class="line">5779</span><br><span class="line">5780</span><br><span class="line">5781</span><br><span class="line">5782</span><br><span class="line">5783</span><br><span class="line">5784</span><br><span class="line">5785</span><br><span class="line">5786</span><br><span class="line">5787</span><br><span class="line">5788</span><br><span class="line">5789</span><br><span class="line">5790</span><br><span class="line">5791</span><br><span class="line">5792</span><br><span class="line">5793</span><br><span class="line">5794</span><br><span class="line">5795</span><br><span class="line">5796</span><br><span class="line">5797</span><br><span class="line">5798</span><br><span class="line">5799</span><br><span class="line">5800</span><br><span class="line">5801</span><br><span class="line">5802</span><br><span class="line">5803</span><br><span class="line">5804</span><br><span class="line">5805</span><br><span class="line">5806</span><br><span class="line">5807</span><br><span class="line">5808</span><br><span class="line">5809</span><br><span class="line">5810</span><br><span class="line">5811</span><br><span class="line">5812</span><br><span class="line">5813</span><br><span class="line">5814</span><br><span class="line">5815</span><br><span class="line">5816</span><br><span class="line">5817</span><br><span class="line">5818</span><br><span class="line">5819</span><br><span class="line">5820</span><br><span class="line">5821</span><br><span class="line">5822</span><br><span class="line">5823</span><br><span class="line">5824</span><br><span class="line">5825</span><br><span class="line">5826</span><br><span class="line">5827</span><br><span class="line">5828</span><br><span class="line">5829</span><br><span class="line">5830</span><br><span class="line">5831</span><br><span class="line">5832</span><br><span class="line">5833</span><br><span class="line">5834</span><br><span class="line">5835</span><br><span class="line">5836</span><br><span class="line">5837</span><br><span class="line">5838</span><br><span class="line">5839</span><br><span class="line">5840</span><br><span class="line">5841</span><br><span class="line">5842</span><br><span class="line">5843</span><br><span class="line">5844</span><br><span class="line">5845</span><br><span class="line">5846</span><br><span class="line">5847</span><br><span class="line">5848</span><br><span class="line">5849</span><br><span class="line">5850</span><br><span class="line">5851</span><br><span class="line">5852</span><br><span class="line">5853</span><br><span class="line">5854</span><br><span class="line">5855</span><br><span class="line">5856</span><br><span class="line">5857</span><br><span class="line">5858</span><br><span class="line">5859</span><br><span class="line">5860</span><br><span class="line">5861</span><br><span class="line">5862</span><br><span class="line">5863</span><br><span class="line">5864</span><br><span class="line">5865</span><br><span class="line">5866</span><br><span class="line">5867</span><br><span class="line">5868</span><br><span class="line">5869</span><br><span class="line">5870</span><br><span class="line">5871</span><br><span class="line">5872</span><br><span class="line">5873</span><br><span class="line">5874</span><br><span class="line">5875</span><br><span class="line">5876</span><br><span class="line">5877</span><br><span class="line">5878</span><br><span class="line">5879</span><br><span class="line">5880</span><br><span class="line">5881</span><br><span class="line">5882</span><br><span class="line">5883</span><br><span class="line">5884</span><br><span class="line">5885</span><br><span class="line">5886</span><br><span class="line">5887</span><br><span class="line">5888</span><br><span class="line">5889</span><br><span class="line">5890</span><br><span class="line">5891</span><br><span class="line">5892</span><br><span class="line">5893</span><br><span class="line">5894</span><br><span class="line">5895</span><br><span class="line">5896</span><br><span class="line">5897</span><br><span class="line">5898</span><br><span class="line">5899</span><br><span class="line">5900</span><br><span class="line">5901</span><br><span class="line">5902</span><br><span class="line">5903</span><br><span class="line">5904</span><br><span class="line">5905</span><br><span class="line">5906</span><br><span class="line">5907</span><br><span class="line">5908</span><br><span class="line">5909</span><br><span class="line">5910</span><br><span class="line">5911</span><br><span class="line">5912</span><br><span class="line">5913</span><br><span class="line">5914</span><br><span class="line">5915</span><br><span class="line">5916</span><br><span class="line">5917</span><br><span class="line">5918</span><br><span class="line">5919</span><br><span class="line">5920</span><br><span class="line">5921</span><br><span class="line">5922</span><br><span class="line">5923</span><br><span class="line">5924</span><br><span class="line">5925</span><br><span class="line">5926</span><br><span class="line">5927</span><br><span class="line">5928</span><br><span class="line">5929</span><br><span class="line">5930</span><br><span class="line">5931</span><br><span class="line">5932</span><br><span class="line">5933</span><br><span class="line">5934</span><br><span class="line">5935</span><br><span class="line">5936</span><br><span class="line">5937</span><br><span class="line">5938</span><br><span class="line">5939</span><br><span class="line">5940</span><br><span class="line">5941</span><br><span class="line">5942</span><br><span class="line">5943</span><br><span class="line">5944</span><br><span class="line">5945</span><br><span class="line">5946</span><br><span class="line">5947</span><br><span class="line">5948</span><br><span class="line">5949</span><br><span class="line">5950</span><br><span class="line">5951</span><br><span class="line">5952</span><br><span class="line">5953</span><br><span class="line">5954</span><br><span class="line">5955</span><br><span class="line">5956</span><br><span class="line">5957</span><br><span class="line">5958</span><br><span class="line">5959</span><br><span class="line">5960</span><br><span class="line">5961</span><br><span class="line">5962</span><br><span class="line">5963</span><br><span class="line">5964</span><br><span class="line">5965</span><br><span class="line">5966</span><br><span class="line">5967</span><br><span class="line">5968</span><br><span class="line">5969</span><br><span class="line">5970</span><br><span class="line">5971</span><br><span class="line">5972</span><br><span class="line">5973</span><br><span class="line">5974</span><br><span class="line">5975</span><br><span class="line">5976</span><br><span class="line">5977</span><br><span class="line">5978</span><br><span class="line">5979</span><br><span class="line">5980</span><br><span class="line">5981</span><br><span class="line">5982</span><br><span class="line">5983</span><br><span class="line">5984</span><br><span class="line">5985</span><br><span class="line">5986</span><br><span class="line">5987</span><br><span class="line">5988</span><br><span class="line">5989</span><br><span class="line">5990</span><br><span class="line">5991</span><br><span class="line">5992</span><br><span class="line">5993</span><br><span class="line">5994</span><br><span class="line">5995</span><br><span class="line">5996</span><br><span class="line">5997</span><br><span class="line">5998</span><br><span class="line">5999</span><br><span class="line">6000</span><br><span class="line">6001</span><br><span class="line">6002</span><br><span class="line">6003</span><br><span class="line">6004</span><br><span class="line">6005</span><br><span class="line">6006</span><br><span class="line">6007</span><br><span class="line">6008</span><br><span class="line">6009</span><br><span class="line">6010</span><br><span class="line">6011</span><br><span class="line">6012</span><br><span class="line">6013</span><br><span class="line">6014</span><br><span class="line">6015</span><br><span class="line">6016</span><br><span class="line">6017</span><br><span class="line">6018</span><br><span class="line">6019</span><br><span class="line">6020</span><br><span class="line">6021</span><br><span class="line">6022</span><br><span class="line">6023</span><br><span class="line">6024</span><br><span class="line">6025</span><br><span class="line">6026</span><br><span class="line">6027</span><br><span class="line">6028</span><br><span class="line">6029</span><br><span class="line">6030</span><br><span class="line">6031</span><br><span class="line">6032</span><br><span class="line">6033</span><br><span class="line">6034</span><br><span class="line">6035</span><br><span class="line">6036</span><br><span class="line">6037</span><br><span class="line">6038</span><br><span class="line">6039</span><br><span class="line">6040</span><br><span class="line">6041</span><br><span class="line">6042</span><br><span class="line">6043</span><br><span class="line">6044</span><br><span class="line">6045</span><br><span class="line">6046</span><br><span class="line">6047</span><br><span class="line">6048</span><br><span class="line">6049</span><br><span class="line">6050</span><br><span class="line">6051</span><br><span class="line">6052</span><br><span class="line">6053</span><br><span class="line">6054</span><br><span class="line">6055</span><br><span class="line">6056</span><br><span class="line">6057</span><br><span class="line">6058</span><br><span class="line">6059</span><br><span class="line">6060</span><br><span class="line">6061</span><br><span class="line">6062</span><br><span class="line">6063</span><br><span class="line">6064</span><br><span class="line">6065</span><br><span class="line">6066</span><br><span class="line">6067</span><br><span class="line">6068</span><br><span class="line">6069</span><br><span class="line">6070</span><br><span class="line">6071</span><br><span class="line">6072</span><br><span class="line">6073</span><br><span class="line">6074</span><br><span class="line">6075</span><br><span class="line">6076</span><br><span class="line">6077</span><br><span class="line">6078</span><br><span class="line">6079</span><br><span class="line">6080</span><br><span class="line">6081</span><br><span class="line">6082</span><br><span class="line">6083</span><br><span class="line">6084</span><br><span class="line">6085</span><br><span class="line">6086</span><br><span class="line">6087</span><br><span class="line">6088</span><br><span class="line">6089</span><br><span class="line">6090</span><br><span class="line">6091</span><br><span class="line">6092</span><br><span class="line">6093</span><br><span class="line">6094</span><br><span class="line">6095</span><br><span class="line">6096</span><br><span class="line">6097</span><br><span class="line">6098</span><br><span class="line">6099</span><br><span class="line">6100</span><br><span class="line">6101</span><br><span class="line">6102</span><br><span class="line">6103</span><br><span class="line">6104</span><br><span class="line">6105</span><br><span class="line">6106</span><br><span class="line">6107</span><br><span class="line">6108</span><br><span class="line">6109</span><br><span class="line">6110</span><br><span class="line">6111</span><br><span class="line">6112</span><br><span class="line">6113</span><br><span class="line">6114</span><br><span class="line">6115</span><br><span class="line">6116</span><br><span class="line">6117</span><br><span class="line">6118</span><br><span class="line">6119</span><br><span class="line">6120</span><br><span class="line">6121</span><br><span class="line">6122</span><br><span class="line">6123</span><br><span class="line">6124</span><br><span class="line">6125</span><br><span class="line">6126</span><br><span class="line">6127</span><br><span class="line">6128</span><br><span class="line">6129</span><br><span class="line">6130</span><br><span class="line">6131</span><br><span class="line">6132</span><br><span class="line">6133</span><br><span class="line">6134</span><br><span class="line">6135</span><br><span class="line">6136</span><br><span class="line">6137</span><br><span class="line">6138</span><br><span class="line">6139</span><br><span class="line">6140</span><br><span class="line">6141</span><br><span class="line">6142</span><br><span class="line">6143</span><br><span class="line">6144</span><br><span class="line">6145</span><br><span class="line">6146</span><br><span class="line">6147</span><br><span class="line">6148</span><br><span class="line">6149</span><br><span class="line">6150</span><br><span class="line">6151</span><br><span class="line">6152</span><br><span class="line">6153</span><br><span class="line">6154</span><br><span class="line">6155</span><br><span class="line">6156</span><br><span class="line">6157</span><br><span class="line">6158</span><br><span class="line">6159</span><br><span class="line">6160</span><br><span class="line">6161</span><br><span class="line">6162</span><br><span class="line">6163</span><br><span class="line">6164</span><br><span class="line">6165</span><br><span class="line">6166</span><br><span class="line">6167</span><br><span class="line">6168</span><br><span class="line">6169</span><br><span class="line">6170</span><br><span class="line">6171</span><br><span class="line">6172</span><br><span class="line">6173</span><br><span class="line">6174</span><br><span class="line">6175</span><br><span class="line">6176</span><br><span class="line">6177</span><br><span class="line">6178</span><br><span class="line">6179</span><br><span class="line">6180</span><br><span class="line">6181</span><br><span class="line">6182</span><br><span class="line">6183</span><br><span class="line">6184</span><br><span class="line">6185</span><br><span class="line">6186</span><br><span class="line">6187</span><br><span class="line">6188</span><br><span class="line">6189</span><br><span class="line">6190</span><br><span class="line">6191</span><br><span class="line">6192</span><br><span class="line">6193</span><br><span class="line">6194</span><br><span class="line">6195</span><br><span class="line">6196</span><br><span class="line">6197</span><br><span class="line">6198</span><br><span class="line">6199</span><br><span class="line">6200</span><br><span class="line">6201</span><br><span class="line">6202</span><br><span class="line">6203</span><br><span class="line">6204</span><br><span class="line">6205</span><br><span class="line">6206</span><br><span class="line">6207</span><br><span class="line">6208</span><br><span class="line">6209</span><br><span class="line">6210</span><br><span class="line">6211</span><br><span class="line">6212</span><br><span class="line">6213</span><br><span class="line">6214</span><br><span class="line">6215</span><br><span class="line">6216</span><br><span class="line">6217</span><br><span class="line">6218</span><br><span class="line">6219</span><br><span class="line">6220</span><br><span class="line">6221</span><br><span class="line">6222</span><br><span class="line">6223</span><br><span class="line">6224</span><br><span class="line">6225</span><br><span class="line">6226</span><br><span class="line">6227</span><br><span class="line">6228</span><br><span class="line">6229</span><br><span class="line">6230</span><br><span class="line">6231</span><br><span class="line">6232</span><br><span class="line">6233</span><br><span class="line">6234</span><br><span class="line">6235</span><br><span class="line">6236</span><br><span class="line">6237</span><br><span class="line">6238</span><br><span class="line">6239</span><br><span class="line">6240</span><br><span class="line">6241</span><br><span class="line">6242</span><br><span class="line">6243</span><br><span class="line">6244</span><br><span class="line">6245</span><br><span class="line">6246</span><br><span class="line">6247</span><br><span class="line">6248</span><br><span class="line">6249</span><br><span class="line">6250</span><br><span class="line">6251</span><br><span class="line">6252</span><br><span class="line">6253</span><br><span class="line">6254</span><br><span class="line">6255</span><br><span class="line">6256</span><br><span class="line">6257</span><br><span class="line">6258</span><br><span class="line">6259</span><br><span class="line">6260</span><br><span class="line">6261</span><br><span class="line">6262</span><br><span class="line">6263</span><br><span class="line">6264</span><br><span class="line">6265</span><br><span class="line">6266</span><br><span class="line">6267</span><br><span class="line">6268</span><br><span class="line">6269</span><br><span class="line">6270</span><br><span class="line">6271</span><br><span class="line">6272</span><br><span class="line">6273</span><br><span class="line">6274</span><br><span class="line">6275</span><br><span class="line">6276</span><br><span class="line">6277</span><br><span class="line">6278</span><br><span class="line">6279</span><br><span class="line">6280</span><br><span class="line">6281</span><br><span class="line">6282</span><br><span class="line">6283</span><br><span class="line">6284</span><br><span class="line">6285</span><br><span class="line">6286</span><br><span class="line">6287</span><br><span class="line">6288</span><br><span class="line">6289</span><br><span class="line">6290</span><br><span class="line">6291</span><br><span class="line">6292</span><br><span class="line">6293</span><br><span class="line">6294</span><br><span class="line">6295</span><br><span class="line">6296</span><br><span class="line">6297</span><br><span class="line">6298</span><br><span class="line">6299</span><br><span class="line">6300</span><br><span class="line">6301</span><br><span class="line">6302</span><br><span class="line">6303</span><br><span class="line">6304</span><br><span class="line">6305</span><br><span class="line">6306</span><br><span class="line">6307</span><br><span class="line">6308</span><br><span class="line">6309</span><br><span class="line">6310</span><br><span class="line">6311</span><br><span class="line">6312</span><br><span class="line">6313</span><br><span class="line">6314</span><br><span class="line">6315</span><br><span class="line">6316</span><br><span class="line">6317</span><br><span class="line">6318</span><br><span class="line">6319</span><br><span class="line">6320</span><br><span class="line">6321</span><br><span class="line">6322</span><br><span class="line">6323</span><br><span class="line">6324</span><br><span class="line">6325</span><br><span class="line">6326</span><br><span class="line">6327</span><br><span class="line">6328</span><br><span class="line">6329</span><br><span class="line">6330</span><br><span class="line">6331</span><br><span class="line">6332</span><br><span class="line">6333</span><br><span class="line">6334</span><br><span class="line">6335</span><br><span class="line">6336</span><br><span class="line">6337</span><br><span class="line">6338</span><br><span class="line">6339</span><br><span class="line">6340</span><br><span class="line">6341</span><br><span class="line">6342</span><br><span class="line">6343</span><br><span class="line">6344</span><br><span class="line">6345</span><br><span class="line">6346</span><br><span class="line">6347</span><br><span class="line">6348</span><br><span class="line">6349</span><br><span class="line">6350</span><br><span class="line">6351</span><br><span class="line">6352</span><br><span class="line">6353</span><br><span class="line">6354</span><br><span class="line">6355</span><br><span class="line">6356</span><br><span class="line">6357</span><br><span class="line">6358</span><br><span class="line">6359</span><br><span class="line">6360</span><br><span class="line">6361</span><br><span class="line">6362</span><br><span class="line">6363</span><br><span class="line">6364</span><br><span class="line">6365</span><br><span class="line">6366</span><br><span class="line">6367</span><br><span class="line">6368</span><br><span class="line">6369</span><br><span class="line">6370</span><br><span class="line">6371</span><br><span class="line">6372</span><br><span class="line">6373</span><br><span class="line">6374</span><br><span class="line">6375</span><br><span class="line">6376</span><br><span class="line">6377</span><br><span class="line">6378</span><br><span class="line">6379</span><br><span class="line">6380</span><br><span class="line">6381</span><br><span class="line">6382</span><br><span class="line">6383</span><br><span class="line">6384</span><br><span class="line">6385</span><br><span class="line">6386</span><br><span class="line">6387</span><br><span class="line">6388</span><br><span class="line">6389</span><br><span class="line">6390</span><br><span class="line">6391</span><br><span class="line">6392</span><br><span class="line">6393</span><br><span class="line">6394</span><br><span class="line">6395</span><br><span class="line">6396</span><br><span class="line">6397</span><br><span class="line">6398</span><br><span class="line">6399</span><br><span class="line">6400</span><br><span class="line">6401</span><br><span class="line">6402</span><br><span class="line">6403</span><br><span class="line">6404</span><br><span class="line">6405</span><br><span class="line">6406</span><br><span class="line">6407</span><br><span class="line">6408</span><br><span class="line">6409</span><br><span class="line">6410</span><br><span class="line">6411</span><br><span class="line">6412</span><br><span class="line">6413</span><br><span class="line">6414</span><br><span class="line">6415</span><br><span class="line">6416</span><br><span class="line">6417</span><br><span class="line">6418</span><br><span class="line">6419</span><br><span class="line">6420</span><br><span class="line">6421</span><br><span class="line">6422</span><br><span class="line">6423</span><br><span class="line">6424</span><br><span class="line">6425</span><br><span class="line">6426</span><br><span class="line">6427</span><br><span class="line">6428</span><br><span class="line">6429</span><br><span class="line">6430</span><br><span class="line">6431</span><br><span class="line">6432</span><br><span class="line">6433</span><br><span class="line">6434</span><br><span class="line">6435</span><br><span class="line">6436</span><br><span class="line">6437</span><br><span class="line">6438</span><br><span class="line">6439</span><br><span class="line">6440</span><br><span class="line">6441</span><br><span class="line">6442</span><br><span class="line">6443</span><br><span class="line">6444</span><br><span class="line">6445</span><br><span class="line">6446</span><br><span class="line">6447</span><br><span class="line">6448</span><br><span class="line">6449</span><br><span class="line">6450</span><br><span class="line">6451</span><br><span class="line">6452</span><br><span class="line">6453</span><br><span class="line">6454</span><br><span class="line">6455</span><br><span class="line">6456</span><br><span class="line">6457</span><br><span class="line">6458</span><br><span class="line">6459</span><br><span class="line">6460</span><br><span class="line">6461</span><br><span class="line">6462</span><br><span class="line">6463</span><br><span class="line">6464</span><br><span class="line">6465</span><br><span class="line">6466</span><br><span class="line">6467</span><br><span class="line">6468</span><br><span class="line">6469</span><br><span class="line">6470</span><br><span class="line">6471</span><br><span class="line">6472</span><br><span class="line">6473</span><br><span class="line">6474</span><br><span class="line">6475</span><br><span class="line">6476</span><br><span class="line">6477</span><br><span class="line">6478</span><br><span class="line">6479</span><br><span class="line">6480</span><br><span class="line">6481</span><br><span class="line">6482</span><br><span class="line">6483</span><br><span class="line">6484</span><br><span class="line">6485</span><br><span class="line">6486</span><br><span class="line">6487</span><br><span class="line">6488</span><br><span class="line">6489</span><br><span class="line">6490</span><br><span class="line">6491</span><br><span class="line">6492</span><br><span class="line">6493</span><br><span class="line">6494</span><br><span class="line">6495</span><br><span class="line">6496</span><br><span class="line">6497</span><br><span class="line">6498</span><br><span class="line">6499</span><br><span class="line">6500</span><br><span class="line">6501</span><br><span class="line">6502</span><br><span class="line">6503</span><br><span class="line">6504</span><br><span class="line">6505</span><br><span class="line">6506</span><br><span class="line">6507</span><br><span class="line">6508</span><br><span class="line">6509</span><br><span class="line">6510</span><br><span class="line">6511</span><br><span class="line">6512</span><br><span class="line">6513</span><br><span class="line">6514</span><br><span class="line">6515</span><br><span class="line">6516</span><br><span class="line">6517</span><br><span class="line">6518</span><br><span class="line">6519</span><br><span class="line">6520</span><br><span class="line">6521</span><br><span class="line">6522</span><br><span class="line">6523</span><br><span class="line">6524</span><br><span class="line">6525</span><br><span class="line">6526</span><br><span class="line">6527</span><br><span class="line">6528</span><br><span class="line">6529</span><br><span class="line">6530</span><br><span class="line">6531</span><br><span class="line">6532</span><br><span class="line">6533</span><br><span class="line">6534</span><br><span class="line">6535</span><br><span class="line">6536</span><br><span class="line">6537</span><br><span class="line">6538</span><br><span class="line">6539</span><br><span class="line">6540</span><br><span class="line">6541</span><br><span class="line">6542</span><br><span class="line">6543</span><br><span class="line">6544</span><br><span class="line">6545</span><br><span class="line">6546</span><br><span class="line">6547</span><br><span class="line">6548</span><br><span class="line">6549</span><br><span class="line">6550</span><br><span class="line">6551</span><br><span class="line">6552</span><br><span class="line">6553</span><br><span class="line">6554</span><br><span class="line">6555</span><br><span class="line">6556</span><br><span class="line">6557</span><br><span class="line">6558</span><br><span class="line">6559</span><br><span class="line">6560</span><br><span class="line">6561</span><br><span class="line">6562</span><br><span class="line">6563</span><br><span class="line">6564</span><br><span class="line">6565</span><br><span class="line">6566</span><br><span class="line">6567</span><br><span class="line">6568</span><br><span class="line">6569</span><br><span class="line">6570</span><br><span class="line">6571</span><br><span class="line">6572</span><br><span class="line">6573</span><br><span class="line">6574</span><br><span class="line">6575</span><br><span class="line">6576</span><br><span class="line">6577</span><br><span class="line">6578</span><br><span class="line">6579</span><br><span class="line">6580</span><br><span class="line">6581</span><br><span class="line">6582</span><br><span class="line">6583</span><br><span class="line">6584</span><br><span class="line">6585</span><br><span class="line">6586</span><br><span class="line">6587</span><br><span class="line">6588</span><br><span class="line">6589</span><br><span class="line">6590</span><br><span class="line">6591</span><br><span class="line">6592</span><br><span class="line">6593</span><br><span class="line">6594</span><br><span class="line">6595</span><br><span class="line">6596</span><br><span class="line">6597</span><br><span class="line">6598</span><br><span class="line">6599</span><br><span class="line">6600</span><br><span class="line">6601</span><br><span class="line">6602</span><br><span class="line">6603</span><br><span class="line">6604</span><br><span class="line">6605</span><br><span class="line">6606</span><br><span class="line">6607</span><br><span class="line">6608</span><br><span class="line">6609</span><br><span class="line">6610</span><br><span class="line">6611</span><br><span class="line">6612</span><br><span class="line">6613</span><br><span class="line">6614</span><br><span class="line">6615</span><br><span class="line">6616</span><br><span class="line">6617</span><br><span class="line">6618</span><br><span class="line">6619</span><br><span class="line">6620</span><br><span class="line">6621</span><br><span class="line">6622</span><br><span class="line">6623</span><br><span class="line">6624</span><br><span class="line">6625</span><br><span class="line">6626</span><br><span class="line">6627</span><br><span class="line">6628</span><br><span class="line">6629</span><br><span class="line">6630</span><br><span class="line">6631</span><br><span class="line">6632</span><br><span class="line">6633</span><br><span class="line">6634</span><br><span class="line">6635</span><br><span class="line">6636</span><br><span class="line">6637</span><br><span class="line">6638</span><br><span class="line">6639</span><br><span class="line">6640</span><br><span class="line">6641</span><br><span class="line">6642</span><br><span class="line">6643</span><br><span class="line">6644</span><br><span class="line">6645</span><br><span class="line">6646</span><br><span class="line">6647</span><br><span class="line">6648</span><br><span class="line">6649</span><br><span class="line">6650</span><br><span class="line">6651</span><br><span class="line">6652</span><br><span class="line">6653</span><br><span class="line">6654</span><br><span class="line">6655</span><br><span class="line">6656</span><br><span class="line">6657</span><br><span class="line">6658</span><br><span class="line">6659</span><br><span class="line">6660</span><br><span class="line">6661</span><br><span class="line">6662</span><br><span class="line">6663</span><br><span class="line">6664</span><br><span class="line">6665</span><br><span class="line">6666</span><br><span class="line">6667</span><br><span class="line">6668</span><br><span class="line">6669</span><br><span class="line">6670</span><br><span class="line">6671</span><br><span class="line">6672</span><br><span class="line">6673</span><br><span class="line">6674</span><br><span class="line">6675</span><br><span class="line">6676</span><br><span class="line">6677</span><br><span class="line">6678</span><br><span class="line">6679</span><br><span class="line">6680</span><br><span class="line">6681</span><br><span class="line">6682</span><br><span class="line">6683</span><br><span class="line">6684</span><br><span class="line">6685</span><br><span class="line">6686</span><br><span class="line">6687</span><br><span class="line">6688</span><br><span class="line">6689</span><br><span class="line">6690</span><br><span class="line">6691</span><br><span class="line">6692</span><br><span class="line">6693</span><br><span class="line">6694</span><br><span class="line">6695</span><br><span class="line">6696</span><br><span class="line">6697</span><br><span class="line">6698</span><br><span class="line">6699</span><br><span class="line">6700</span><br><span class="line">6701</span><br><span class="line">6702</span><br><span class="line">6703</span><br><span class="line">6704</span><br><span class="line">6705</span><br><span class="line">6706</span><br><span class="line">6707</span><br><span class="line">6708</span><br><span class="line">6709</span><br><span class="line">6710</span><br><span class="line">6711</span><br><span class="line">6712</span><br><span class="line">6713</span><br><span class="line">6714</span><br><span class="line">6715</span><br><span class="line">6716</span><br><span class="line">6717</span><br><span class="line">6718</span><br><span class="line">6719</span><br><span class="line">6720</span><br><span class="line">6721</span><br><span class="line">6722</span><br><span class="line">6723</span><br><span class="line">6724</span><br><span class="line">6725</span><br><span class="line">6726</span><br><span class="line">6727</span><br><span class="line">6728</span><br><span class="line">6729</span><br><span class="line">6730</span><br><span class="line">6731</span><br><span class="line">6732</span><br><span class="line">6733</span><br><span class="line">6734</span><br><span class="line">6735</span><br><span class="line">6736</span><br><span class="line">6737</span><br><span class="line">6738</span><br><span class="line">6739</span><br><span class="line">6740</span><br><span class="line">6741</span><br><span class="line">6742</span><br><span class="line">6743</span><br><span class="line">6744</span><br><span class="line">6745</span><br><span class="line">6746</span><br><span class="line">6747</span><br><span class="line">6748</span><br><span class="line">6749</span><br><span class="line">6750</span><br><span class="line">6751</span><br><span class="line">6752</span><br><span class="line">6753</span><br><span class="line">6754</span><br><span class="line">6755</span><br><span class="line">6756</span><br><span class="line">6757</span><br><span class="line">6758</span><br><span class="line">6759</span><br><span class="line">6760</span><br><span class="line">6761</span><br><span class="line">6762</span><br><span class="line">6763</span><br><span class="line">6764</span><br><span class="line">6765</span><br><span class="line">6766</span><br><span class="line">6767</span><br><span class="line">6768</span><br><span class="line">6769</span><br><span class="line">6770</span><br><span class="line">6771</span><br><span class="line">6772</span><br><span class="line">6773</span><br><span class="line">6774</span><br><span class="line">6775</span><br><span class="line">6776</span><br><span class="line">6777</span><br><span class="line">6778</span><br><span class="line">6779</span><br><span class="line">6780</span><br><span class="line">6781</span><br><span class="line">6782</span><br><span class="line">6783</span><br><span class="line">6784</span><br><span class="line">6785</span><br><span class="line">6786</span><br><span class="line">6787</span><br><span class="line">6788</span><br><span class="line">6789</span><br><span class="line">6790</span><br><span class="line">6791</span><br><span class="line">6792</span><br><span class="line">6793</span><br><span class="line">6794</span><br><span class="line">6795</span><br><span class="line">6796</span><br><span class="line">6797</span><br><span class="line">6798</span><br><span class="line">6799</span><br><span class="line">6800</span><br><span class="line">6801</span><br><span class="line">6802</span><br><span class="line">6803</span><br><span class="line">6804</span><br><span class="line">6805</span><br><span class="line">6806</span><br><span class="line">6807</span><br><span class="line">6808</span><br><span class="line">6809</span><br><span class="line">6810</span><br><span class="line">6811</span><br><span class="line">6812</span><br><span class="line">6813</span><br><span class="line">6814</span><br><span class="line">6815</span><br><span class="line">6816</span><br><span class="line">6817</span><br><span class="line">6818</span><br><span class="line">6819</span><br><span class="line">6820</span><br><span class="line">6821</span><br><span class="line">6822</span><br><span class="line">6823</span><br><span class="line">6824</span><br><span class="line">6825</span><br><span class="line">6826</span><br><span class="line">6827</span><br><span class="line">6828</span><br><span class="line">6829</span><br><span class="line">6830</span><br><span class="line">6831</span><br><span class="line">6832</span><br><span class="line">6833</span><br><span class="line">6834</span><br><span class="line">6835</span><br><span class="line">6836</span><br><span class="line">6837</span><br><span class="line">6838</span><br><span class="line">6839</span><br><span class="line">6840</span><br><span class="line">6841</span><br><span class="line">6842</span><br><span class="line">6843</span><br><span class="line">6844</span><br><span class="line">6845</span><br><span class="line">6846</span><br><span class="line">6847</span><br><span class="line">6848</span><br><span class="line">6849</span><br><span class="line">6850</span><br><span class="line">6851</span><br><span class="line">6852</span><br><span class="line">6853</span><br><span class="line">6854</span><br><span class="line">6855</span><br><span class="line">6856</span><br><span class="line">6857</span><br><span class="line">6858</span><br><span class="line">6859</span><br><span class="line">6860</span><br><span class="line">6861</span><br><span class="line">6862</span><br><span class="line">6863</span><br><span class="line">6864</span><br><span class="line">6865</span><br><span class="line">6866</span><br><span class="line">6867</span><br><span class="line">6868</span><br><span class="line">6869</span><br><span class="line">6870</span><br><span class="line">6871</span><br><span class="line">6872</span><br><span class="line">6873</span><br><span class="line">6874</span><br><span class="line">6875</span><br><span class="line">6876</span><br><span class="line">6877</span><br><span class="line">6878</span><br><span class="line">6879</span><br><span class="line">6880</span><br><span class="line">6881</span><br><span class="line">6882</span><br><span class="line">6883</span><br><span class="line">6884</span><br><span class="line">6885</span><br><span class="line">6886</span><br><span class="line">6887</span><br><span class="line">6888</span><br><span class="line">6889</span><br><span class="line">6890</span><br><span class="line">6891</span><br><span class="line">6892</span><br><span class="line">6893</span><br><span class="line">6894</span><br><span class="line">6895</span><br><span class="line">6896</span><br><span class="line">6897</span><br><span class="line">6898</span><br><span class="line">6899</span><br><span class="line">6900</span><br><span class="line">6901</span><br><span class="line">6902</span><br><span class="line">6903</span><br><span class="line">6904</span><br><span class="line">6905</span><br><span class="line">6906</span><br><span class="line">6907</span><br><span class="line">6908</span><br><span class="line">6909</span><br><span class="line">6910</span><br><span class="line">6911</span><br><span class="line">6912</span><br><span class="line">6913</span><br><span class="line">6914</span><br><span class="line">6915</span><br><span class="line">6916</span><br><span class="line">6917</span><br><span class="line">6918</span><br><span class="line">6919</span><br><span class="line">6920</span><br><span class="line">6921</span><br><span class="line">6922</span><br><span class="line">6923</span><br><span class="line">6924</span><br><span class="line">6925</span><br><span class="line">6926</span><br><span class="line">6927</span><br><span class="line">6928</span><br><span class="line">6929</span><br><span class="line">6930</span><br><span class="line">6931</span><br><span class="line">6932</span><br><span class="line">6933</span><br><span class="line">6934</span><br><span class="line">6935</span><br><span class="line">6936</span><br><span class="line">6937</span><br><span class="line">6938</span><br><span class="line">6939</span><br><span class="line">6940</span><br><span class="line">6941</span><br><span class="line">6942</span><br><span class="line">6943</span><br><span class="line">6944</span><br><span class="line">6945</span><br><span class="line">6946</span><br><span class="line">6947</span><br><span class="line">6948</span><br><span class="line">6949</span><br><span class="line">6950</span><br><span class="line">6951</span><br><span class="line">6952</span><br><span class="line">6953</span><br><span class="line">6954</span><br><span class="line">6955</span><br><span class="line">6956</span><br><span class="line">6957</span><br><span class="line">6958</span><br><span class="line">6959</span><br><span class="line">6960</span><br><span class="line">6961</span><br><span class="line">6962</span><br><span class="line">6963</span><br><span class="line">6964</span><br><span class="line">6965</span><br><span class="line">6966</span><br><span class="line">6967</span><br><span class="line">6968</span><br><span class="line">6969</span><br><span class="line">6970</span><br><span class="line">6971</span><br><span class="line">6972</span><br><span class="line">6973</span><br><span class="line">6974</span><br><span class="line">6975</span><br><span class="line">6976</span><br><span class="line">6977</span><br><span class="line">6978</span><br><span class="line">6979</span><br><span class="line">6980</span><br><span class="line">6981</span><br><span class="line">6982</span><br><span class="line">6983</span><br><span class="line">6984</span><br><span class="line">6985</span><br><span class="line">6986</span><br><span class="line">6987</span><br><span class="line">6988</span><br><span class="line">6989</span><br><span class="line">6990</span><br><span class="line">6991</span><br><span class="line">6992</span><br><span class="line">6993</span><br><span class="line">6994</span><br><span class="line">6995</span><br><span class="line">6996</span><br><span class="line">6997</span><br><span class="line">6998</span><br><span class="line">6999</span><br><span class="line">7000</span><br><span class="line">7001</span><br><span class="line">7002</span><br><span class="line">7003</span><br><span class="line">7004</span><br><span class="line">7005</span><br><span class="line">7006</span><br><span class="line">7007</span><br><span class="line">7008</span><br><span class="line">7009</span><br><span class="line">7010</span><br><span class="line">7011</span><br><span class="line">7012</span><br><span class="line">7013</span><br><span class="line">7014</span><br><span class="line">7015</span><br><span class="line">7016</span><br><span class="line">7017</span><br><span class="line">7018</span><br><span class="line">7019</span><br><span class="line">7020</span><br><span class="line">7021</span><br><span class="line">7022</span><br><span class="line">7023</span><br><span class="line">7024</span><br><span class="line">7025</span><br><span class="line">7026</span><br><span class="line">7027</span><br><span class="line">7028</span><br><span class="line">7029</span><br><span class="line">7030</span><br><span class="line">7031</span><br><span class="line">7032</span><br><span class="line">7033</span><br><span class="line">7034</span><br><span class="line">7035</span><br><span class="line">7036</span><br><span class="line">7037</span><br><span class="line">7038</span><br><span class="line">7039</span><br><span class="line">7040</span><br><span class="line">7041</span><br><span class="line">7042</span><br><span class="line">7043</span><br><span class="line">7044</span><br><span class="line">7045</span><br><span class="line">7046</span><br><span class="line">7047</span><br><span class="line">7048</span><br><span class="line">7049</span><br><span class="line">7050</span><br><span class="line">7051</span><br><span class="line">7052</span><br><span class="line">7053</span><br><span class="line">7054</span><br><span class="line">7055</span><br><span class="line">7056</span><br><span class="line">7057</span><br><span class="line">7058</span><br><span class="line">7059</span><br><span class="line">7060</span><br><span class="line">7061</span><br><span class="line">7062</span><br><span class="line">7063</span><br><span class="line">7064</span><br><span class="line">7065</span><br><span class="line">7066</span><br><span class="line">7067</span><br><span class="line">7068</span><br><span class="line">7069</span><br><span class="line">7070</span><br><span class="line">7071</span><br><span class="line">7072</span><br><span class="line">7073</span><br><span class="line">7074</span><br><span class="line">7075</span><br><span class="line">7076</span><br><span class="line">7077</span><br><span class="line">7078</span><br><span class="line">7079</span><br><span class="line">7080</span><br><span class="line">7081</span><br><span class="line">7082</span><br><span class="line">7083</span><br><span class="line">7084</span><br><span class="line">7085</span><br><span class="line">7086</span><br><span class="line">7087</span><br><span class="line">7088</span><br><span class="line">7089</span><br><span class="line">7090</span><br><span class="line">7091</span><br><span class="line">7092</span><br><span class="line">7093</span><br><span class="line">7094</span><br><span class="line">7095</span><br><span class="line">7096</span><br><span class="line">7097</span><br><span class="line">7098</span><br><span class="line">7099</span><br><span class="line">7100</span><br><span class="line">7101</span><br><span class="line">7102</span><br><span class="line">7103</span><br><span class="line">7104</span><br><span class="line">7105</span><br><span class="line">7106</span><br><span class="line">7107</span><br><span class="line">7108</span><br><span class="line">7109</span><br><span class="line">7110</span><br><span class="line">7111</span><br><span class="line">7112</span><br><span class="line">7113</span><br><span class="line">7114</span><br><span class="line">7115</span><br><span class="line">7116</span><br><span class="line">7117</span><br><span class="line">7118</span><br><span class="line">7119</span><br><span class="line">7120</span><br><span class="line">7121</span><br><span class="line">7122</span><br><span class="line">7123</span><br><span class="line">7124</span><br><span class="line">7125</span><br><span class="line">7126</span><br><span class="line">7127</span><br><span class="line">7128</span><br><span class="line">7129</span><br><span class="line">7130</span><br><span class="line">7131</span><br><span class="line">7132</span><br><span class="line">7133</span><br><span class="line">7134</span><br><span class="line">7135</span><br><span class="line">7136</span><br><span class="line">7137</span><br><span class="line">7138</span><br><span class="line">7139</span><br><span class="line">7140</span><br><span class="line">7141</span><br><span class="line">7142</span><br><span class="line">7143</span><br><span class="line">7144</span><br><span class="line">7145</span><br><span class="line">7146</span><br><span class="line">7147</span><br><span class="line">7148</span><br><span class="line">7149</span><br><span class="line">7150</span><br><span class="line">7151</span><br><span class="line">7152</span><br><span class="line">7153</span><br><span class="line">7154</span><br><span class="line">7155</span><br><span class="line">7156</span><br><span class="line">7157</span><br><span class="line">7158</span><br><span class="line">7159</span><br><span class="line">7160</span><br><span class="line">7161</span><br><span class="line">7162</span><br><span class="line">7163</span><br><span class="line">7164</span><br><span class="line">7165</span><br><span class="line">7166</span><br><span class="line">7167</span><br><span class="line">7168</span><br><span class="line">7169</span><br><span class="line">7170</span><br><span class="line">7171</span><br><span class="line">7172</span><br><span class="line">7173</span><br><span class="line">7174</span><br><span class="line">7175</span><br><span class="line">7176</span><br><span class="line">7177</span><br><span class="line">7178</span><br><span class="line">7179</span><br><span class="line">7180</span><br><span class="line">7181</span><br><span class="line">7182</span><br><span class="line">7183</span><br><span class="line">7184</span><br><span class="line">7185</span><br><span class="line">7186</span><br><span class="line">7187</span><br><span class="line">7188</span><br><span class="line">7189</span><br><span class="line">7190</span><br><span class="line">7191</span><br><span class="line">7192</span><br><span class="line">7193</span><br><span class="line">7194</span><br><span class="line">7195</span><br><span class="line">7196</span><br><span class="line">7197</span><br><span class="line">7198</span><br><span class="line">7199</span><br><span class="line">7200</span><br><span class="line">7201</span><br><span class="line">7202</span><br><span class="line">7203</span><br><span class="line">7204</span><br><span class="line">7205</span><br><span class="line">7206</span><br><span class="line">7207</span><br><span class="line">7208</span><br><span class="line">7209</span><br><span class="line">7210</span><br><span class="line">7211</span><br><span class="line">7212</span><br><span class="line">7213</span><br><span class="line">7214</span><br><span class="line">7215</span><br><span class="line">7216</span><br><span class="line">7217</span><br><span class="line">7218</span><br><span class="line">7219</span><br><span class="line">7220</span><br><span class="line">7221</span><br><span class="line">7222</span><br><span class="line">7223</span><br><span class="line">7224</span><br><span class="line">7225</span><br><span class="line">7226</span><br><span class="line">7227</span><br><span class="line">7228</span><br><span class="line">7229</span><br><span class="line">7230</span><br><span class="line">7231</span><br><span class="line">7232</span><br><span class="line">7233</span><br><span class="line">7234</span><br><span class="line">7235</span><br><span class="line">7236</span><br><span class="line">7237</span><br><span class="line">7238</span><br><span class="line">7239</span><br><span class="line">7240</span><br><span class="line">7241</span><br><span class="line">7242</span><br><span class="line">7243</span><br><span class="line">7244</span><br><span class="line">7245</span><br><span class="line">7246</span><br><span class="line">7247</span><br><span class="line">7248</span><br><span class="line">7249</span><br><span class="line">7250</span><br><span class="line">7251</span><br><span class="line">7252</span><br><span class="line">7253</span><br><span class="line">7254</span><br><span class="line">7255</span><br><span class="line">7256</span><br><span class="line">7257</span><br><span class="line">7258</span><br><span class="line">7259</span><br><span class="line">7260</span><br><span class="line">7261</span><br><span class="line">7262</span><br><span class="line">7263</span><br><span class="line">7264</span><br><span class="line">7265</span><br><span class="line">7266</span><br><span class="line">7267</span><br><span class="line">7268</span><br><span class="line">7269</span><br><span class="line">7270</span><br><span class="line">7271</span><br><span class="line">7272</span><br><span class="line">7273</span><br><span class="line">7274</span><br><span class="line">7275</span><br><span class="line">7276</span><br><span class="line">7277</span><br><span class="line">7278</span><br><span class="line">7279</span><br><span class="line">7280</span><br><span class="line">7281</span><br><span class="line">7282</span><br><span class="line">7283</span><br><span class="line">7284</span><br><span class="line">7285</span><br><span class="line">7286</span><br><span class="line">7287</span><br><span class="line">7288</span><br><span class="line">7289</span><br><span class="line">7290</span><br><span class="line">7291</span><br><span class="line">7292</span><br><span class="line">7293</span><br><span class="line">7294</span><br><span class="line">7295</span><br><span class="line">7296</span><br><span class="line">7297</span><br><span class="line">7298</span><br><span class="line">7299</span><br><span class="line">7300</span><br><span class="line">7301</span><br><span class="line">7302</span><br><span class="line">7303</span><br><span class="line">7304</span><br><span class="line">7305</span><br><span class="line">7306</span><br><span class="line">7307</span><br><span class="line">7308</span><br><span class="line">7309</span><br><span class="line">7310</span><br><span class="line">7311</span><br><span class="line">7312</span><br><span class="line">7313</span><br><span class="line">7314</span><br><span class="line">7315</span><br><span class="line">7316</span><br><span class="line">7317</span><br><span class="line">7318</span><br><span class="line">7319</span><br><span class="line">7320</span><br><span class="line">7321</span><br><span class="line">7322</span><br><span class="line">7323</span><br><span class="line">7324</span><br><span class="line">7325</span><br><span class="line">7326</span><br><span class="line">7327</span><br><span class="line">7328</span><br><span class="line">7329</span><br><span class="line">7330</span><br><span class="line">7331</span><br><span class="line">7332</span><br><span class="line">7333</span><br><span class="line">7334</span><br><span class="line">7335</span><br><span class="line">7336</span><br><span class="line">7337</span><br><span class="line">7338</span><br><span class="line">7339</span><br><span class="line">7340</span><br><span class="line">7341</span><br><span class="line">7342</span><br><span class="line">7343</span><br><span class="line">7344</span><br><span class="line">7345</span><br><span class="line">7346</span><br><span class="line">7347</span><br><span class="line">7348</span><br><span class="line">7349</span><br><span class="line">7350</span><br><span class="line">7351</span><br><span class="line">7352</span><br><span class="line">7353</span><br><span class="line">7354</span><br><span class="line">7355</span><br><span class="line">7356</span><br><span class="line">7357</span><br><span class="line">7358</span><br><span class="line">7359</span><br><span class="line">7360</span><br><span class="line">7361</span><br><span class="line">7362</span><br><span class="line">7363</span><br><span class="line">7364</span><br><span class="line">7365</span><br><span class="line">7366</span><br><span class="line">7367</span><br><span class="line">7368</span><br><span class="line">7369</span><br><span class="line">7370</span><br><span class="line">7371</span><br><span class="line">7372</span><br><span class="line">7373</span><br><span class="line">7374</span><br><span class="line">7375</span><br><span class="line">7376</span><br><span class="line">7377</span><br><span class="line">7378</span><br><span class="line">7379</span><br><span class="line">7380</span><br><span class="line">7381</span><br><span class="line">7382</span><br><span class="line">7383</span><br><span class="line">7384</span><br><span class="line">7385</span><br><span class="line">7386</span><br><span class="line">7387</span><br><span class="line">7388</span><br><span class="line">7389</span><br><span class="line">7390</span><br><span class="line">7391</span><br><span class="line">7392</span><br><span class="line">7393</span><br><span class="line">7394</span><br><span class="line">7395</span><br><span class="line">7396</span><br><span class="line">7397</span><br><span class="line">7398</span><br><span class="line">7399</span><br><span class="line">7400</span><br><span class="line">7401</span><br><span class="line">7402</span><br><span class="line">7403</span><br><span class="line">7404</span><br><span class="line">7405</span><br><span class="line">7406</span><br><span class="line">7407</span><br><span class="line">7408</span><br><span class="line">7409</span><br><span class="line">7410</span><br><span class="line">7411</span><br><span class="line">7412</span><br><span class="line">7413</span><br><span class="line">7414</span><br><span class="line">7415</span><br><span class="line">7416</span><br><span class="line">7417</span><br><span class="line">7418</span><br><span class="line">7419</span><br><span class="line">7420</span><br><span class="line">7421</span><br><span class="line">7422</span><br><span class="line">7423</span><br><span class="line">7424</span><br><span class="line">7425</span><br><span class="line">7426</span><br><span class="line">7427</span><br><span class="line">7428</span><br><span class="line">7429</span><br><span class="line">7430</span><br><span class="line">7431</span><br><span class="line">7432</span><br><span class="line">7433</span><br><span class="line">7434</span><br><span class="line">7435</span><br><span class="line">7436</span><br><span class="line">7437</span><br><span class="line">7438</span><br><span class="line">7439</span><br><span class="line">7440</span><br><span class="line">7441</span><br><span class="line">7442</span><br><span class="line">7443</span><br><span class="line">7444</span><br><span class="line">7445</span><br><span class="line">7446</span><br><span class="line">7447</span><br><span class="line">7448</span><br><span class="line">7449</span><br><span class="line">7450</span><br><span class="line">7451</span><br><span class="line">7452</span><br><span class="line">7453</span><br><span class="line">7454</span><br><span class="line">7455</span><br><span class="line">7456</span><br><span class="line">7457</span><br><span class="line">7458</span><br><span class="line">7459</span><br><span class="line">7460</span><br><span class="line">7461</span><br><span class="line">7462</span><br><span class="line">7463</span><br><span class="line">7464</span><br><span class="line">7465</span><br><span class="line">7466</span><br><span class="line">7467</span><br><span class="line">7468</span><br><span class="line">7469</span><br><span class="line">7470</span><br><span class="line">7471</span><br><span class="line">7472</span><br><span class="line">7473</span><br><span class="line">7474</span><br><span class="line">7475</span><br><span class="line">7476</span><br><span class="line">7477</span><br><span class="line">7478</span><br><span class="line">7479</span><br><span class="line">7480</span><br><span class="line">7481</span><br><span class="line">7482</span><br><span class="line">7483</span><br><span class="line">7484</span><br><span class="line">7485</span><br><span class="line">7486</span><br><span class="line">7487</span><br><span class="line">7488</span><br><span class="line">7489</span><br><span class="line">7490</span><br><span class="line">7491</span><br><span class="line">7492</span><br><span class="line">7493</span><br><span class="line">7494</span><br><span class="line">7495</span><br><span class="line">7496</span><br><span class="line">7497</span><br><span class="line">7498</span><br><span class="line">7499</span><br><span class="line">7500</span><br><span class="line">7501</span><br><span class="line">7502</span><br><span class="line">7503</span><br><span class="line">7504</span><br><span class="line">7505</span><br><span class="line">7506</span><br><span class="line">7507</span><br><span class="line">7508</span><br><span class="line">7509</span><br><span class="line">7510</span><br><span class="line">7511</span><br><span class="line">7512</span><br><span class="line">7513</span><br><span class="line">7514</span><br><span class="line">7515</span><br><span class="line">7516</span><br><span class="line">7517</span><br><span class="line">7518</span><br><span class="line">7519</span><br><span class="line">7520</span><br><span class="line">7521</span><br><span class="line">7522</span><br><span class="line">7523</span><br><span class="line">7524</span><br><span class="line">7525</span><br><span class="line">7526</span><br><span class="line">7527</span><br><span class="line">7528</span><br><span class="line">7529</span><br><span class="line">7530</span><br><span class="line">7531</span><br><span class="line">7532</span><br><span class="line">7533</span><br><span class="line">7534</span><br><span class="line">7535</span><br><span class="line">7536</span><br><span class="line">7537</span><br><span class="line">7538</span><br><span class="line">7539</span><br><span class="line">7540</span><br><span class="line">7541</span><br><span class="line">7542</span><br><span class="line">7543</span><br><span class="line">7544</span><br><span class="line">7545</span><br><span class="line">7546</span><br><span class="line">7547</span><br><span class="line">7548</span><br><span class="line">7549</span><br><span class="line">7550</span><br><span class="line">7551</span><br><span class="line">7552</span><br><span class="line">7553</span><br><span class="line">7554</span><br><span class="line">7555</span><br><span class="line">7556</span><br><span class="line">7557</span><br><span class="line">7558</span><br><span class="line">7559</span><br><span class="line">7560</span><br><span class="line">7561</span><br><span class="line">7562</span><br><span class="line">7563</span><br><span class="line">7564</span><br><span class="line">7565</span><br><span class="line">7566</span><br><span class="line">7567</span><br><span class="line">7568</span><br><span class="line">7569</span><br><span class="line">7570</span><br><span class="line">7571</span><br><span class="line">7572</span><br><span class="line">7573</span><br><span class="line">7574</span><br><span class="line">7575</span><br><span class="line">7576</span><br><span class="line">7577</span><br><span class="line">7578</span><br><span class="line">7579</span><br><span class="line">7580</span><br><span class="line">7581</span><br><span class="line">7582</span><br><span class="line">7583</span><br><span class="line">7584</span><br><span class="line">7585</span><br><span class="line">7586</span><br><span class="line">7587</span><br><span class="line">7588</span><br><span class="line">7589</span><br><span class="line">7590</span><br><span class="line">7591</span><br><span class="line">7592</span><br><span class="line">7593</span><br><span class="line">7594</span><br><span class="line">7595</span><br><span class="line">7596</span><br><span class="line">7597</span><br><span class="line">7598</span><br><span class="line">7599</span><br><span class="line">7600</span><br><span class="line">7601</span><br><span class="line">7602</span><br><span class="line">7603</span><br><span class="line">7604</span><br><span class="line">7605</span><br><span class="line">7606</span><br><span class="line">7607</span><br><span class="line">7608</span><br><span class="line">7609</span><br><span class="line">7610</span><br><span class="line">7611</span><br><span class="line">7612</span><br><span class="line">7613</span><br><span class="line">7614</span><br><span class="line">7615</span><br><span class="line">7616</span><br><span class="line">7617</span><br><span class="line">7618</span><br><span class="line">7619</span><br><span class="line">7620</span><br><span class="line">7621</span><br><span class="line">7622</span><br><span class="line">7623</span><br><span class="line">7624</span><br><span class="line">7625</span><br><span class="line">7626</span><br><span class="line">7627</span><br><span class="line">7628</span><br><span class="line">7629</span><br><span class="line">7630</span><br><span class="line">7631</span><br><span class="line">7632</span><br><span class="line">7633</span><br><span class="line">7634</span><br><span class="line">7635</span><br><span class="line">7636</span><br><span class="line">7637</span><br><span class="line">7638</span><br><span class="line">7639</span><br><span class="line">7640</span><br><span class="line">7641</span><br><span class="line">7642</span><br><span class="line">7643</span><br><span class="line">7644</span><br><span class="line">7645</span><br><span class="line">7646</span><br><span class="line">7647</span><br><span class="line">7648</span><br><span class="line">7649</span><br><span class="line">7650</span><br><span class="line">7651</span><br><span class="line">7652</span><br><span class="line">7653</span><br><span class="line">7654</span><br><span class="line">7655</span><br><span class="line">7656</span><br><span class="line">7657</span><br><span class="line">7658</span><br><span class="line">7659</span><br><span class="line">7660</span><br><span class="line">7661</span><br><span class="line">7662</span><br><span class="line">7663</span><br><span class="line">7664</span><br><span class="line">7665</span><br><span class="line">7666</span><br><span class="line">7667</span><br><span class="line">7668</span><br><span class="line">7669</span><br><span class="line">7670</span><br><span class="line">7671</span><br><span class="line">7672</span><br><span class="line">7673</span><br><span class="line">7674</span><br><span class="line">7675</span><br><span class="line">7676</span><br><span class="line">7677</span><br><span class="line">7678</span><br><span class="line">7679</span><br><span class="line">7680</span><br><span class="line">7681</span><br><span class="line">7682</span><br><span class="line">7683</span><br><span class="line">7684</span><br><span class="line">7685</span><br><span class="line">7686</span><br><span class="line">7687</span><br><span class="line">7688</span><br><span class="line">7689</span><br><span class="line">7690</span><br><span class="line">7691</span><br><span class="line">7692</span><br><span class="line">7693</span><br><span class="line">7694</span><br><span class="line">7695</span><br><span class="line">7696</span><br><span class="line">7697</span><br><span class="line">7698</span><br><span class="line">7699</span><br><span class="line">7700</span><br><span class="line">7701</span><br><span class="line">7702</span><br><span class="line">7703</span><br><span class="line">7704</span><br><span class="line">7705</span><br><span class="line">7706</span><br><span class="line">7707</span><br><span class="line">7708</span><br><span class="line">7709</span><br><span class="line">7710</span><br><span class="line">7711</span><br><span class="line">7712</span><br><span class="line">7713</span><br><span class="line">7714</span><br><span class="line">7715</span><br><span class="line">7716</span><br><span class="line">7717</span><br><span class="line">7718</span><br><span class="line">7719</span><br><span class="line">7720</span><br><span class="line">7721</span><br><span class="line">7722</span><br><span class="line">7723</span><br><span class="line">7724</span><br><span class="line">7725</span><br><span class="line">7726</span><br><span class="line">7727</span><br><span class="line">7728</span><br><span class="line">7729</span><br><span class="line">7730</span><br><span class="line">7731</span><br><span class="line">7732</span><br><span class="line">7733</span><br><span class="line">7734</span><br><span class="line">7735</span><br><span class="line">7736</span><br><span class="line">7737</span><br><span class="line">7738</span><br><span class="line">7739</span><br><span class="line">7740</span><br><span class="line">7741</span><br><span class="line">7742</span><br><span class="line">7743</span><br><span class="line">7744</span><br><span class="line">7745</span><br><span class="line">7746</span><br><span class="line">7747</span><br><span class="line">7748</span><br><span class="line">7749</span><br><span class="line">7750</span><br><span class="line">7751</span><br><span class="line">7752</span><br><span class="line">7753</span><br><span class="line">7754</span><br><span class="line">7755</span><br><span class="line">7756</span><br><span class="line">7757</span><br><span class="line">7758</span><br><span class="line">7759</span><br><span class="line">7760</span><br><span class="line">7761</span><br><span class="line">7762</span><br><span class="line">7763</span><br><span class="line">7764</span><br><span class="line">7765</span><br><span class="line">7766</span><br><span class="line">7767</span><br><span class="line">7768</span><br><span class="line">7769</span><br><span class="line">7770</span><br><span class="line">7771</span><br><span class="line">7772</span><br><span class="line">7773</span><br><span class="line">7774</span><br><span class="line">7775</span><br><span class="line">7776</span><br><span class="line">7777</span><br><span class="line">7778</span><br><span class="line">7779</span><br><span class="line">7780</span><br><span class="line">7781</span><br><span class="line">7782</span><br><span class="line">7783</span><br><span class="line">7784</span><br><span class="line">7785</span><br><span class="line">7786</span><br><span class="line">7787</span><br><span class="line">7788</span><br><span class="line">7789</span><br><span class="line">7790</span><br><span class="line">7791</span><br><span class="line">7792</span><br><span class="line">7793</span><br><span class="line">7794</span><br><span class="line">7795</span><br><span class="line">7796</span><br><span class="line">7797</span><br><span class="line">7798</span><br><span class="line">7799</span><br><span class="line">7800</span><br><span class="line">7801</span><br><span class="line">7802</span><br><span class="line">7803</span><br><span class="line">7804</span><br><span class="line">7805</span><br><span class="line">7806</span><br><span class="line">7807</span><br><span class="line">7808</span><br><span class="line">7809</span><br><span class="line">7810</span><br><span class="line">7811</span><br><span class="line">7812</span><br><span class="line">7813</span><br><span class="line">7814</span><br><span class="line">7815</span><br><span class="line">7816</span><br><span class="line">7817</span><br><span class="line">7818</span><br><span class="line">7819</span><br><span class="line">7820</span><br><span class="line">7821</span><br><span class="line">7822</span><br><span class="line">7823</span><br><span class="line">7824</span><br><span class="line">7825</span><br><span class="line">7826</span><br><span class="line">7827</span><br><span class="line">7828</span><br><span class="line">7829</span><br><span class="line">7830</span><br><span class="line">7831</span><br><span class="line">7832</span><br><span class="line">7833</span><br><span class="line">7834</span><br><span class="line">7835</span><br><span class="line">7836</span><br><span class="line">7837</span><br><span class="line">7838</span><br><span class="line">7839</span><br><span class="line">7840</span><br><span class="line">7841</span><br><span class="line">7842</span><br><span class="line">7843</span><br><span class="line">7844</span><br><span class="line">7845</span><br><span class="line">7846</span><br><span class="line">7847</span><br><span class="line">7848</span><br><span class="line">7849</span><br><span class="line">7850</span><br><span class="line">7851</span><br><span class="line">7852</span><br><span class="line">7853</span><br><span class="line">7854</span><br><span class="line">7855</span><br><span class="line">7856</span><br><span class="line">7857</span><br><span class="line">7858</span><br><span class="line">7859</span><br><span class="line">7860</span><br><span class="line">7861</span><br><span class="line">7862</span><br><span class="line">7863</span><br><span class="line">7864</span><br><span class="line">7865</span><br><span class="line">7866</span><br><span class="line">7867</span><br><span class="line">7868</span><br><span class="line">7869</span><br><span class="line">7870</span><br><span class="line">7871</span><br><span class="line">7872</span><br><span class="line">7873</span><br><span class="line">7874</span><br><span class="line">7875</span><br><span class="line">7876</span><br><span class="line">7877</span><br><span class="line">7878</span><br><span class="line">7879</span><br><span class="line">7880</span><br><span class="line">7881</span><br><span class="line">7882</span><br><span class="line">7883</span><br><span class="line">7884</span><br><span class="line">7885</span><br><span class="line">7886</span><br><span class="line">7887</span><br><span class="line">7888</span><br><span class="line">7889</span><br><span class="line">7890</span><br><span class="line">7891</span><br><span class="line">7892</span><br><span class="line">7893</span><br><span class="line">7894</span><br><span class="line">7895</span><br><span class="line">7896</span><br><span class="line">7897</span><br><span class="line">7898</span><br><span class="line">7899</span><br><span class="line">7900</span><br><span class="line">7901</span><br><span class="line">7902</span><br><span class="line">7903</span><br><span class="line">7904</span><br><span class="line">7905</span><br><span class="line">7906</span><br><span class="line">7907</span><br><span class="line">7908</span><br><span class="line">7909</span><br><span class="line">7910</span><br><span class="line">7911</span><br><span class="line">7912</span><br><span class="line">7913</span><br><span class="line">7914</span><br><span class="line">7915</span><br><span class="line">7916</span><br><span class="line">7917</span><br><span class="line">7918</span><br><span class="line">7919</span><br><span class="line">7920</span><br><span class="line">7921</span><br><span class="line">7922</span><br><span class="line">7923</span><br><span class="line">7924</span><br><span class="line">7925</span><br><span class="line">7926</span><br><span class="line">7927</span><br><span class="line">7928</span><br><span class="line">7929</span><br><span class="line">7930</span><br><span class="line">7931</span><br><span class="line">7932</span><br><span class="line">7933</span><br><span class="line">7934</span><br><span class="line">7935</span><br><span class="line">7936</span><br><span class="line">7937</span><br><span class="line">7938</span><br><span class="line">7939</span><br><span class="line">7940</span><br><span class="line">7941</span><br><span class="line">7942</span><br><span class="line">7943</span><br><span class="line">7944</span><br><span class="line">7945</span><br><span class="line">7946</span><br><span class="line">7947</span><br><span class="line">7948</span><br><span class="line">7949</span><br><span class="line">7950</span><br><span class="line">7951</span><br><span class="line">7952</span><br><span class="line">7953</span><br><span class="line">7954</span><br><span class="line">7955</span><br><span class="line">7956</span><br><span class="line">7957</span><br><span class="line">7958</span><br><span class="line">7959</span><br><span class="line">7960</span><br><span class="line">7961</span><br><span class="line">7962</span><br><span class="line">7963</span><br><span class="line">7964</span><br><span class="line">7965</span><br><span class="line">7966</span><br><span class="line">7967</span><br><span class="line">7968</span><br><span class="line">7969</span><br><span class="line">7970</span><br><span class="line">7971</span><br><span class="line">7972</span><br><span class="line">7973</span><br><span class="line">7974</span><br><span class="line">7975</span><br><span class="line">7976</span><br><span class="line">7977</span><br><span class="line">7978</span><br><span class="line">7979</span><br><span class="line">7980</span><br><span class="line">7981</span><br><span class="line">7982</span><br><span class="line">7983</span><br><span class="line">7984</span><br><span class="line">7985</span><br><span class="line">7986</span><br><span class="line">7987</span><br><span class="line">7988</span><br><span class="line">7989</span><br><span class="line">7990</span><br><span class="line">7991</span><br><span class="line">7992</span><br><span class="line">7993</span><br><span class="line">7994</span><br><span class="line">7995</span><br><span class="line">7996</span><br><span class="line">7997</span><br><span class="line">7998</span><br><span class="line">7999</span><br><span class="line">8000</span><br><span class="line">8001</span><br><span class="line">8002</span><br><span class="line">8003</span><br><span class="line">8004</span><br><span class="line">8005</span><br><span class="line">8006</span><br><span class="line">8007</span><br><span class="line">8008</span><br><span class="line">8009</span><br><span class="line">8010</span><br><span class="line">8011</span><br><span class="line">8012</span><br><span class="line">8013</span><br><span class="line">8014</span><br><span class="line">8015</span><br><span class="line">8016</span><br><span class="line">8017</span><br><span class="line">8018</span><br><span class="line">8019</span><br><span class="line">8020</span><br><span class="line">8021</span><br><span class="line">8022</span><br><span class="line">8023</span><br><span class="line">8024</span><br><span class="line">8025</span><br><span class="line">8026</span><br><span class="line">8027</span><br><span class="line">8028</span><br><span class="line">8029</span><br><span class="line">8030</span><br><span class="line">8031</span><br><span class="line">8032</span><br><span class="line">8033</span><br><span class="line">8034</span><br><span class="line">8035</span><br><span class="line">8036</span><br><span class="line">8037</span><br><span class="line">8038</span><br><span class="line">8039</span><br><span class="line">8040</span><br><span class="line">8041</span><br><span class="line">8042</span><br><span class="line">8043</span><br><span class="line">8044</span><br><span class="line">8045</span><br><span class="line">8046</span><br><span class="line">8047</span><br><span class="line">8048</span><br><span class="line">8049</span><br><span class="line">8050</span><br><span class="line">8051</span><br><span class="line">8052</span><br><span class="line">8053</span><br><span class="line">8054</span><br><span class="line">8055</span><br><span class="line">8056</span><br><span class="line">8057</span><br><span class="line">8058</span><br><span class="line">8059</span><br><span class="line">8060</span><br><span class="line">8061</span><br><span class="line">8062</span><br><span class="line">8063</span><br><span class="line">8064</span><br><span class="line">8065</span><br><span class="line">8066</span><br><span class="line">8067</span><br><span class="line">8068</span><br><span class="line">8069</span><br><span class="line">8070</span><br><span class="line">8071</span><br><span class="line">8072</span><br><span class="line">8073</span><br><span class="line">8074</span><br><span class="line">8075</span><br><span class="line">8076</span><br><span class="line">8077</span><br><span class="line">8078</span><br><span class="line">8079</span><br><span class="line">8080</span><br><span class="line">8081</span><br><span class="line">8082</span><br><span class="line">8083</span><br><span class="line">8084</span><br><span class="line">8085</span><br><span class="line">8086</span><br><span class="line">8087</span><br><span class="line">8088</span><br><span class="line">8089</span><br><span class="line">8090</span><br><span class="line">8091</span><br><span class="line">8092</span><br><span class="line">8093</span><br><span class="line">8094</span><br><span class="line">8095</span><br><span class="line">8096</span><br><span class="line">8097</span><br><span class="line">8098</span><br><span class="line">8099</span><br><span class="line">8100</span><br><span class="line">8101</span><br><span class="line">8102</span><br><span class="line">8103</span><br><span class="line">8104</span><br><span class="line">8105</span><br><span class="line">8106</span><br><span class="line">8107</span><br><span class="line">8108</span><br><span class="line">8109</span><br><span class="line">8110</span><br><span class="line">8111</span><br><span class="line">8112</span><br><span class="line">8113</span><br><span class="line">8114</span><br><span class="line">8115</span><br><span class="line">8116</span><br><span class="line">8117</span><br><span class="line">8118</span><br><span class="line">8119</span><br><span class="line">8120</span><br><span class="line">8121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  kernel/sched/core.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Core kernel scheduler code and related syscalls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 1991-2002  Linus Torvalds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sched.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/nospec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kcov.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/scs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/switch_to.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/tlb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../workqueue_internal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../../fs/io-wq.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../smpboot.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pelt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"smp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_TRACE_POINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;trace/events/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Export tracepoints that act as a bare tracehook (ie: have no trace event</span></span><br><span class="line"><span class="comment"> * associated with them) to allow external modules to probe them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_cfs_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_rt_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_dl_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_irq_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_se_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(sched_overutilized_tp);</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SCHED_DEBUG) &amp;&amp; defined(CONFIG_JUMP_LABEL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Debugging: various feature bits</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If SCHED_DEBUG is disabled, each compilation unit has its own copy of</span></span><br><span class="line"><span class="comment"> * sysctl_sched_features, defined in sched.h, to allow constants propagation</span></span><br><span class="line"><span class="comment"> * at compile time and compiler optimization based on features default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FEAT(name, enabled)	\</span></span><br><span class="line">	(<span class="number">1U</span>L &lt;&lt; __SCHED_FEAT_##name) * enabled |</span><br><span class="line">const_debug <span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_features =</span><br><span class="line">#include <span class="string">"features.h"</span></span><br><span class="line">	<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> SCHED_FEAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of tasks to iterate in a single balance run.</span></span><br><span class="line"><span class="comment"> * Limited because this is done with IRQs disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">const_debug <span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_nr_migrate = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * period over which we measure -rt task CPU usage in us.</span></span><br><span class="line"><span class="comment"> * default: 1s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_rt_period = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">__read_mostly <span class="keyword">int</span> scheduler_running;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * part of the period that we allow rt tasks to run in us.</span></span><br><span class="line"><span class="comment"> * default: 0.95s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> sysctl_sched_rt_runtime = <span class="number">950000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __task_rq_lock - lock the rq @p resides on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *__<span class="title">task_rq_lock</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">	__<span class="title">acquires</span>(<span class="title">rq</span>-&gt;<span class="title">lock</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		rq = task_rq(p);</span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) &#123;</span><br><span class="line">			rq_pin_lock(rq, rf);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (unlikely(task_on_rq_migrating(p)))</span><br><span class="line">			cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * task_rq_lock - lock p-&gt;pi_lock and lock the rq @p resides on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct rq *<span class="title">task_rq_lock</span><span class="params">(struct task_struct *p, struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(p-&gt;pi_lock)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf-&gt;flags);</span><br><span class="line">		rq = task_rq(p);</span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *	move_queued_task()		task_rq_lock()</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *	ACQUIRE (rq-&gt;lock)</span></span><br><span class="line"><span class="comment">		 *	[S] -&gt;on_rq = MIGRATING		[L] rq = task_rq()</span></span><br><span class="line"><span class="comment">		 *	WMB (__set_task_cpu())		ACQUIRE (rq-&gt;lock);</span></span><br><span class="line"><span class="comment">		 *	[S] -&gt;cpu = new_cpu		[L] task_rq()</span></span><br><span class="line"><span class="comment">		 *					[L] -&gt;on_rq</span></span><br><span class="line"><span class="comment">		 *	RELEASE (rq-&gt;lock)</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If we observe the old CPU in task_rq_lock(), the acquire of</span></span><br><span class="line"><span class="comment">		 * the old rq-&gt;lock will fully serialize against the stores.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If we observe the new CPU in task_rq_lock(), the address</span></span><br><span class="line"><span class="comment">		 * dependency headed by '[L] rq = task_rq()' and the acquire</span></span><br><span class="line"><span class="comment">		 * will pair with the WMB to ensure we then also see migrating.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) &#123;</span><br><span class="line">			rq_pin_lock(rq, rf);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, rf-&gt;flags);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (unlikely(task_on_rq_migrating(p)))</span><br><span class="line">			cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RQ-clock updating methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_rq_clock_task</span><span class="params">(struct rq *rq, s64 delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In theory, the compile should just see 0 here, and optimize out the call</span></span><br><span class="line"><span class="comment"> * to sched_rt_avg_update. But I don't trust it...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	s64 __maybe_unused steal = <span class="number">0</span>, irq_delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_TIME_ACCOUNTING</span></span><br><span class="line">	irq_delta = irq_time_read(cpu_of(rq)) - rq-&gt;prev_irq_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since irq_time is only updated on &#123;soft,&#125;irq_exit, we might run into</span></span><br><span class="line"><span class="comment">	 * this case when a previous update_rq_clock() happened inside a</span></span><br><span class="line"><span class="comment">	 * &#123;soft,&#125;irq region.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When this happens, we stop -&gt;clock_task and only update the</span></span><br><span class="line"><span class="comment">	 * prev_irq_time stamp to account for the part that fit, so that a next</span></span><br><span class="line"><span class="comment">	 * update will consume the rest. This ensures -&gt;clock_task is</span></span><br><span class="line"><span class="comment">	 * monotonic.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * It does however cause some slight miss-attribution of &#123;soft,&#125;irq</span></span><br><span class="line"><span class="comment">	 * time, a more accurate solution would be to update the irq_time using</span></span><br><span class="line"><span class="comment">	 * the current rq-&gt;clock timestamp, except that would require using</span></span><br><span class="line"><span class="comment">	 * atomic ops.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (irq_delta &gt; delta)</span><br><span class="line">		irq_delta = delta;</span><br><span class="line"></span><br><span class="line">	rq-&gt;prev_irq_time += irq_delta;</span><br><span class="line">	delta -= irq_delta;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line">	<span class="keyword">if</span> (static_key_false((&amp;paravirt_steal_rq_enabled))) &#123;</span><br><span class="line">		steal = paravirt_steal_clock(cpu_of(rq));</span><br><span class="line">		steal -= rq-&gt;prev_steal_time_rq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(steal &gt; delta))</span><br><span class="line">			steal = delta;</span><br><span class="line"></span><br><span class="line">		rq-&gt;prev_steal_time_rq += steal;</span><br><span class="line">		delta -= steal;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_task += delta;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_SCHED_AVG_IRQ</span></span><br><span class="line">	<span class="keyword">if</span> ((irq_delta + steal) &amp;&amp; sched_feat(NONTASK_CAPACITY))</span><br><span class="line">		update_irq_load_avg(rq, irq_delta + steal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	update_rq_clock_pelt(rq, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_rq_clock</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;clock_update_flags &amp; RQCF_ACT_SKIP)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(WARN_DOUBLE_CLOCK))</span><br><span class="line">		SCHED_WARN_ON(rq-&gt;clock_update_flags &amp; RQCF_UPDATED);</span><br><span class="line">	rq-&gt;clock_update_flags |= RQCF_UPDATED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	delta = sched_clock_cpu(cpu_of(rq)) - rq-&gt;clock;</span><br><span class="line">	<span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	rq-&gt;clock += delta;</span><br><span class="line">	update_rq_clock_task(rq, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rq_csd_init(struct rq *rq, <span class="keyword">call_single_data_t</span> *csd, <span class="keyword">smp_call_func_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	csd-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	csd-&gt;func = func;</span><br><span class="line">	csd-&gt;info = rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_HRTICK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use HR-timers to deliver accurate preemption points.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hrtick_clear</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hrtimer_active(&amp;rq-&gt;hrtick_timer))</span><br><span class="line">		hrtimer_cancel(&amp;rq-&gt;hrtick_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * High-resolution timer tick.</span></span><br><span class="line"><span class="comment"> * Runs from hardirq context with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> hrtimer_restart <span class="title">hrtick</span><span class="params">(struct hrtimer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">container_of</span>(<span class="title">timer</span>, <span class="title">struct</span> <span class="title">rq</span>, <span class="title">hrtick_timer</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	rq-&gt;curr-&gt;sched_class-&gt;task_tick(rq, rq-&gt;curr, <span class="number">1</span>);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> HRTIMER_NORESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __hrtick_restart(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">timer</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">hrtick_timer</span>;</span></span><br><span class="line"></span><br><span class="line">	hrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * called from hardirq (IPI) context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __hrtick_start(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">arg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	__hrtick_restart(rq);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called to set the hrtick timer state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * called with rq-&gt;lock held and irqs disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hrtick_start</span><span class="params">(struct rq *rq, u64 delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">timer</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">hrtick_timer</span>;</span></span><br><span class="line">	<span class="keyword">ktime_t</span> time;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't schedule slices shorter than 10000ns, that just</span></span><br><span class="line"><span class="comment">	 * doesn't make sense and can cause timer DoS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	delta = <span class="keyword">max_t</span>(s64, delay, <span class="number">10000L</span>L);</span><br><span class="line">	time = ktime_add_ns(timer-&gt;base-&gt;get_time(), delta);</span><br><span class="line"></span><br><span class="line">	hrtimer_set_expires(timer, time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq == this_rq())</span><br><span class="line">		__hrtick_restart(rq);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		smp_call_function_single_async(cpu_of(rq), &amp;rq-&gt;hrtick_csd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called to set the hrtick timer state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * called with rq-&gt;lock held and irqs disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hrtick_start</span><span class="params">(struct rq *rq, u64 delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't schedule slices shorter than 10000ns, that just</span></span><br><span class="line"><span class="comment">	 * doesn't make sense. Rely on vruntime for fairness.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	delay = <span class="keyword">max_t</span>(u64, delay, <span class="number">10000L</span>L);</span><br><span class="line">	hrtimer_start(&amp;rq-&gt;hrtick_timer, ns_to_ktime(delay),</span><br><span class="line">		      HRTIMER_MODE_REL_PINNED_HARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hrtick_rq_init</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq_csd_init(rq, &amp;rq-&gt;hrtick_csd, __hrtick_start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	hrtimer_init(&amp;rq-&gt;hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);</span><br><span class="line">	rq-&gt;hrtick_timer.function = hrtick;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* CONFIG_SCHED_HRTICK */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hrtick_clear</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hrtick_rq_init</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_SCHED_HRTICK */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cmpxchg based fetch_or, macro so it works for different integer types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fetch_or(ptr, mask)						\</span></span><br><span class="line">	(&#123;								\</span><br><span class="line">		typeof(ptr) _ptr = (ptr);				\</span><br><span class="line">		typeof(mask) _mask = (mask);				\</span><br><span class="line">		typeof(*_ptr) _old, _val = *_ptr;			\</span><br><span class="line">									\</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;						\</span><br><span class="line">			_old = cmpxchg(_ptr, _val, _val | _mask);	\</span><br><span class="line">			<span class="keyword">if</span> (_old == _val)				\</span><br><span class="line">				<span class="keyword">break</span>;					\</span><br><span class="line">			_val = _old;					\</span><br><span class="line">		&#125;							\</span><br><span class="line">	_old;								\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP) &amp;&amp; defined(TIF_POLLING_NRFLAG)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Atomically set TIF_NEED_RESCHED and test for TIF_POLLING_NRFLAG,</span></span><br><span class="line"><span class="comment"> * this avoids any races wrt polling state changes and thereby avoids</span></span><br><span class="line"><span class="comment"> * spurious IPIs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_and_not_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> = <span class="title">task_thread_info</span>(<span class="title">p</span>);</span></span><br><span class="line">	<span class="keyword">return</span> !(fetch_or(&amp;ti-&gt;flags, _TIF_NEED_RESCHED) &amp; _TIF_POLLING_NRFLAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Atomically set TIF_NEED_RESCHED if TIF_POLLING_NRFLAG is set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this returns true, then the idle task promises to call</span></span><br><span class="line"><span class="comment"> * sched_ttwu_pending() and reschedule soon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_if_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> = <span class="title">task_thread_info</span>(<span class="title">p</span>);</span></span><br><span class="line">	typeof(ti-&gt;flags) old, val = READ_ONCE(ti-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(val &amp; _TIF_POLLING_NRFLAG))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; _TIF_NEED_RESCHED)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		old = cmpxchg(&amp;ti-&gt;flags, val, val | _TIF_NEED_RESCHED);</span><br><span class="line">		<span class="keyword">if</span> (old == val)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		val = old;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_and_not_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_tsk_need_resched(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_if_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __wake_q_add(struct wake_q_head *head, struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> *<span class="title">node</span> = &amp;<span class="title">task</span>-&gt;<span class="title">wake_q</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Atomically grab the task, if -&gt;wake_q is !nil already it means</span></span><br><span class="line"><span class="comment">	 * its already queued (either by us or someone else) and will get the</span></span><br><span class="line"><span class="comment">	 * wakeup due to that.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In order to ensure that a pending wakeup will observe our pending</span></span><br><span class="line"><span class="comment">	 * state, even in the failed case, an explicit smp_mb() must be used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	<span class="keyword">if</span> (unlikely(cmpxchg_relaxed(&amp;node-&gt;next, <span class="literal">NULL</span>, WAKE_Q_TAIL)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The head is context local, there can be no concurrency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*head-&gt;lastp = node;</span><br><span class="line">	head-&gt;lastp = &amp;node-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_q_add() - queue a wakeup for 'later' waking.</span></span><br><span class="line"><span class="comment"> * @head: the wake_q_head to add @task to</span></span><br><span class="line"><span class="comment"> * @task: the task to queue for 'later' wakeup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue a task for later wakeup, most likely by the wake_up_q() call in the</span></span><br><span class="line"><span class="comment"> * same context, _HOWEVER_ this is not guaranteed, the wakeup can come</span></span><br><span class="line"><span class="comment"> * instantly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be used as-if it were wake_up_process(); IOW the task</span></span><br><span class="line"><span class="comment"> * must be ready to be woken at this location.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_q_add</span><span class="params">(struct wake_q_head *head, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__wake_q_add(head, task))</span><br><span class="line">		get_task_struct(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_q_add_safe() - safely queue a wakeup for 'later' waking.</span></span><br><span class="line"><span class="comment"> * @head: the wake_q_head to add @task to</span></span><br><span class="line"><span class="comment"> * @task: the task to queue for 'later' wakeup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue a task for later wakeup, most likely by the wake_up_q() call in the</span></span><br><span class="line"><span class="comment"> * same context, _HOWEVER_ this is not guaranteed, the wakeup can come</span></span><br><span class="line"><span class="comment"> * instantly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be used as-if it were wake_up_process(); IOW the task</span></span><br><span class="line"><span class="comment"> * must be ready to be woken at this location.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is essentially a task-safe equivalent to wake_q_add(). Callers</span></span><br><span class="line"><span class="comment"> * that already hold reference to @task can call the 'safe' version and trust</span></span><br><span class="line"><span class="comment"> * wake_q to do the right thing depending whether or not the @task is already</span></span><br><span class="line"><span class="comment"> * queued for wakeup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_q_add_safe</span><span class="params">(struct wake_q_head *head, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__wake_q_add(head, task))</span><br><span class="line">		put_task_struct(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_q</span><span class="params">(struct wake_q_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> *<span class="title">node</span> = <span class="title">head</span>-&gt;<span class="title">first</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (node != WAKE_Q_TAIL) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">		task = container_of(node, struct task_struct, wake_q);</span><br><span class="line">		BUG_ON(!task);</span><br><span class="line">		<span class="comment">/* Task can safely be re-inserted now: */</span></span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		task-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * wake_up_process() executes a full barrier, which pairs with</span></span><br><span class="line"><span class="comment">		 * the queueing in wake_q_add() so as not to miss wakeups.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		wake_up_process(task);</span><br><span class="line">		put_task_struct(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resched_curr - mark rq's current task 'to be rescheduled now'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP this means the setting of the need_resched flag, on SMP it</span></span><br><span class="line"><span class="comment"> * might also involve a cross-CPU call to trigger the scheduler on</span></span><br><span class="line"><span class="comment"> * the target CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resched_curr</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_tsk_need_resched(curr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	cpu = cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resched_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (cpu_online(cpu) || cpu == smp_processor_id())</span><br><span class="line">		resched_curr(rq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In the semi idle case, use the nearest busy CPU for migrating timers</span></span><br><span class="line"><span class="comment"> * from an idle CPU.  This is good for power-savings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We don't do similar optimization for completely idle system, as</span></span><br><span class="line"><span class="comment"> * selecting an idle CPU will add more delays to the timers than intended</span></span><br><span class="line"><span class="comment"> * (as that CPU's timer base may not be uptodate wrt jiffies etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nohz_timer_target</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, cpu = smp_processor_id(), default_cpu = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TIMER)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!idle_cpu(cpu))</span><br><span class="line">			<span class="keyword">return</span> cpu;</span><br><span class="line">		default_cpu = cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	for_each_domain(cpu, sd) &#123;</span><br><span class="line">		for_each_cpu_and(i, sched_domain_span(sd),</span><br><span class="line">			housekeeping_cpumask(HK_FLAG_TIMER)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cpu == i)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!idle_cpu(i)) &#123;</span><br><span class="line">				cpu = i;</span><br><span class="line">				<span class="keyword">goto</span> unlock;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (default_cpu == <span class="number">-1</span>)</span><br><span class="line">		default_cpu = housekeeping_any_cpu(HK_FLAG_TIMER);</span><br><span class="line">	cpu = default_cpu;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When add_timer_on() enqueues a timer into the timer wheel of an</span></span><br><span class="line"><span class="comment"> * idle CPU then this timer might expire before the next timer event</span></span><br><span class="line"><span class="comment"> * which is scheduled to wake up that CPU. In case of a completely</span></span><br><span class="line"><span class="comment"> * idle system the next event might even be infinite time into the</span></span><br><span class="line"><span class="comment"> * future. wake_up_idle_cpu() ensures that the CPU is woken up and</span></span><br><span class="line"><span class="comment"> * leaves the inner idle loop so the newly added timer is taken into</span></span><br><span class="line"><span class="comment"> * account when the CPU goes back to idle and evaluates the timer</span></span><br><span class="line"><span class="comment"> * wheel for the next timer event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wake_up_idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu == smp_processor_id())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">wake_up_full_nohz_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We just need the target to call irq_exit() and re-evaluate</span></span><br><span class="line"><span class="comment">	 * the next tick. The nohz full kick at least implies that.</span></span><br><span class="line"><span class="comment">	 * If needed we can still optimize that later with an</span></span><br><span class="line"><span class="comment">	 * empty IRQ.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_is_offline(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/* Don't try to wake offline CPUs. */</span></span><br><span class="line">	<span class="keyword">if</span> (tick_nohz_full_cpu(cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cpu != smp_processor_id() ||</span><br><span class="line">		    tick_nohz_tick_stopped())</span><br><span class="line">			tick_nohz_full_kick_cpu(cpu);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up the specified CPU.  If the CPU is going offline, it is the</span></span><br><span class="line"><span class="comment"> * caller's responsibility to deal with the lost wakeup, for example,</span></span><br><span class="line"><span class="comment"> * by hooking into the CPU_DEAD notifier like timers and hrtimers do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_nohz_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wake_up_full_nohz_cpu(cpu))</span><br><span class="line">		wake_up_idle_cpu(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nohz_csd_func</span><span class="params">(<span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu = cpu_of(rq);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release the rq::nohz_csd.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	flags = atomic_fetch_andnot(NOHZ_KICK_MASK, nohz_flags(cpu));</span><br><span class="line">	WARN_ON(!(flags &amp; NOHZ_KICK_MASK));</span><br><span class="line"></span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;idle_balance &amp;&amp; !need_resched()) &#123;</span><br><span class="line">		rq-&gt;nohz_idle_balance = flags;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_COMMON */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sched_can_stop_tick</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fifo_nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deadline tasks, even if single, need the tick */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;dl.dl_nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there are more than one RR tasks, we need the tick to effect the</span></span><br><span class="line"><span class="comment">	 * actual RR behaviour.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rt.rr_nr_running) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;rt.rr_nr_running == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there's no RR tasks, but FIFO tasks, we can skip the tick, no</span></span><br><span class="line"><span class="comment">	 * forced preemption between FIFO tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fifo_nr_running = rq-&gt;rt.rt_nr_running - rq-&gt;rt.rr_nr_running;</span><br><span class="line">	<span class="keyword">if</span> (fifo_nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;</span></span><br><span class="line"><span class="comment">	 * if there's more than one we need the tick for involuntary</span></span><br><span class="line"><span class="comment">	 * preemption.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_FULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) &amp;&amp; \</span></span><br><span class="line">			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Iterate task_group tree rooted at *from, calling @down when first entering a</span></span><br><span class="line"><span class="comment"> * node and @up when leaving it for the final time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Caller must hold rcu_lock or sufficient equivalent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">walk_tg_tree_from</span><span class="params">(struct task_group *from,</span></span></span><br><span class="line"><span class="function"><span class="params">			     tg_visitor down, tg_visitor up, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span>, *<span class="title">child</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	parent = from;</span><br><span class="line"></span><br><span class="line">down:</span><br><span class="line">	ret = (*down)(parent, data);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	list_for_each_entry_rcu(child, &amp;parent-&gt;children, siblings) &#123;</span><br><span class="line">		parent = child;</span><br><span class="line">		<span class="keyword">goto</span> down;</span><br><span class="line"></span><br><span class="line">up:</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = (*up)(parent, data);</span><br><span class="line">	<span class="keyword">if</span> (ret || parent == from)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	child = parent;</span><br><span class="line">	parent = parent-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		<span class="keyword">goto</span> up;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tg_nop</span><span class="params">(struct task_group *tg, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_load_weight</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> update_load)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio = p-&gt;static_prio - MAX_RT_PRIO;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> *<span class="title">load</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>.<span class="title">load</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SCHED_IDLE tasks get minimal weight:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_idle_policy(p)) &#123;</span><br><span class="line">		load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);</span><br><span class="line">		load-&gt;inv_weight = WMULT_IDLEPRIO;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SCHED_OTHER tasks have to update their load when changing their</span></span><br><span class="line"><span class="comment">	 * weight</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (update_load &amp;&amp; p-&gt;sched_class == &amp;fair_sched_class) &#123;</span><br><span class="line">		reweight_task(p, prio);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		load-&gt;weight = scale_load(sched_prio_to_weight[prio]);</span><br><span class="line">		load-&gt;inv_weight = sched_prio_to_wmult[prio];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Serializes updates of utilization clamp values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The (slow-path) user-space triggers utilization clamp value updates which</span></span><br><span class="line"><span class="comment"> * can require updates on (fast-path) scheduler's data structures used to</span></span><br><span class="line"><span class="comment"> * support enqueue/dequeue operations.</span></span><br><span class="line"><span class="comment"> * While the per-CPU rq lock protects fast-path update operations, user-space</span></span><br><span class="line"><span class="comment"> * requests are serialized using a mutex to reduce the risk of conflicting</span></span><br><span class="line"><span class="comment"> * updates or API abuses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(uclamp_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Max allowed minimum utilization */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_uclamp_util_min = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Max allowed maximum utilization */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_uclamp_util_max = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All clamps are required to be less or equal than these values */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uclamp_default</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Integer rounded range for each bucket */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_BUCKET_DELTA DIV_ROUND_CLOSEST(SCHED_CAPACITY_SCALE, UCLAMP_BUCKETS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_clamp_id(clamp_id) \</span></span><br><span class="line">	<span class="keyword">for</span> ((clamp_id) = <span class="number">0</span>; (clamp_id) &lt; UCLAMP_CNT; (clamp_id)++)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_bucket_id</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> clamp_value / UCLAMP_BUCKET_DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_bucket_base_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UCLAMP_BUCKET_DELTA * uclamp_bucket_id(clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_none</span><span class="params">(<span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (clamp_id == UCLAMP_MIN)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> SCHED_CAPACITY_SCALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_se_set</span><span class="params">(struct uclamp_se *uc_se,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">unsigned</span> <span class="keyword">int</span> value, <span class="keyword">bool</span> user_defined)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uc_se-&gt;value = value;</span><br><span class="line">	uc_se-&gt;bucket_id = uclamp_bucket_id(value);</span><br><span class="line">	uc_se-&gt;user_defined = user_defined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">uclamp_idle_value(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span><br><span class="line">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Avoid blocked utilization pushing up the frequency when we go</span></span><br><span class="line"><span class="comment">	 * idle (which drops the max-clamp) by retaining the last known</span></span><br><span class="line"><span class="comment">	 * max-clamp.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (clamp_id == UCLAMP_MAX) &#123;</span><br><span class="line">		rq-&gt;uclamp_flags |= UCLAMP_FLAG_IDLE;</span><br><span class="line">		<span class="keyword">return</span> clamp_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uclamp_none(UCLAMP_MIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_idle_reset</span><span class="params">(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Reset max-clamp retention only on idle exit */</span></span><br><span class="line">	<span class="keyword">if</span> (!(rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(rq-&gt;uclamp[clamp_id].value, clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_rq_max_value</span><span class="params">(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span> = <span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>].<span class="title">bucket</span>;</span></span><br><span class="line">	<span class="keyword">int</span> bucket_id = UCLAMP_BUCKETS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since both min and max clamps are max aggregated, find the</span></span><br><span class="line"><span class="comment">	 * top most bucket with tasks in.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; bucket_id &gt;= <span class="number">0</span>; bucket_id--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!bucket[bucket_id].tasks)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">return</span> bucket[bucket_id].value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* No tasks -- default clamp values */</span></span><br><span class="line">	<span class="keyword">return</span> uclamp_idle_value(rq, clamp_id, clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span></span></span><br><span class="line"><span class="class"><span class="title">uclamp_tg_restrict</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">enum</span> <span class="title">uclamp_id</span> <span class="title">clamp_id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_req</span> = <span class="title">p</span>-&gt;<span class="title">uclamp_req</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks in autogroups or root task group will be</span></span><br><span class="line"><span class="comment">	 * restricted by system defaults.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_group_is_autogroup(task_group(p)))</span><br><span class="line">		<span class="keyword">return</span> uc_req;</span><br><span class="line">	<span class="keyword">if</span> (task_group(p) == &amp;root_task_group)</span><br><span class="line">		<span class="keyword">return</span> uc_req;</span><br><span class="line"></span><br><span class="line">	uc_max = task_group(p)-&gt;uclamp[clamp_id];</span><br><span class="line">	<span class="keyword">if</span> (uc_req.value &gt; uc_max.value || !uc_req.user_defined)</span><br><span class="line">		<span class="keyword">return</span> uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uc_req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The effective clamp bucket index of a task depends on, by increasing</span></span><br><span class="line"><span class="comment"> * priority:</span></span><br><span class="line"><span class="comment"> * - the task specific clamp value, when explicitly requested from userspace</span></span><br><span class="line"><span class="comment"> * - the task group effective clamp value, for tasks not either in the root</span></span><br><span class="line"><span class="comment"> *   group or in an autogroup</span></span><br><span class="line"><span class="comment"> * - the system default clamp value, defined by the sysadmin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span></span></span><br><span class="line"><span class="class"><span class="title">uclamp_eff_get</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">enum</span> <span class="title">uclamp_id</span> <span class="title">clamp_id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_req</span> = <span class="title">uclamp_tg_restrict</span>(<span class="title">p</span>, <span class="title">clamp_id</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span> = <span class="title">uclamp_default</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* System default restrictions always apply */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(uc_req.value &gt; uc_max.value))</span><br><span class="line">		<span class="keyword">return</span> uc_max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uc_req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">uclamp_eff_value</span><span class="params">(struct task_struct *p, <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_eff</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Task currently refcounted: use back-annotated (effective) value */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;uclamp[clamp_id].active)</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)p-&gt;uclamp[clamp_id].value;</span><br><span class="line"></span><br><span class="line">	uc_eff = uclamp_eff_get(p, clamp_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)uc_eff.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When a task is enqueued on a rq, the clamp bucket currently defined by the</span></span><br><span class="line"><span class="comment"> * task's uclamp::bucket_id is refcounted on that rq. This also immediately</span></span><br><span class="line"><span class="comment"> * updates the rq's clamp value if required.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tasks can have a task-specific value requested from user-space, track</span></span><br><span class="line"><span class="comment"> * within each bucket the maximum value for tasks refcounted in it.</span></span><br><span class="line"><span class="comment"> * This "local max aggregation" allows to track the exact "requested" value</span></span><br><span class="line"><span class="comment"> * for each bucket when all its RUNNABLE tasks require the same clamp.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc_id</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span> *<span class="title">uc_rq</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update task effective clamp */</span></span><br><span class="line">	p-&gt;uclamp[clamp_id] = uclamp_eff_get(p, clamp_id);</span><br><span class="line"></span><br><span class="line">	bucket = &amp;uc_rq-&gt;bucket[uc_se-&gt;bucket_id];</span><br><span class="line">	bucket-&gt;tasks++;</span><br><span class="line">	uc_se-&gt;active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	uclamp_idle_reset(rq, clamp_id, uc_se-&gt;value);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Local max aggregation: rq buckets always track the max</span></span><br><span class="line"><span class="comment">	 * "requested" clamp value of its RUNNABLE tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bucket-&gt;tasks == <span class="number">1</span> || uc_se-&gt;value &gt; bucket-&gt;value)</span><br><span class="line">		bucket-&gt;value = uc_se-&gt;value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uc_se-&gt;value &gt; READ_ONCE(uc_rq-&gt;value))</span><br><span class="line">		WRITE_ONCE(uc_rq-&gt;value, uc_se-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When a task is dequeued from a rq, the clamp bucket refcounted by the task</span></span><br><span class="line"><span class="comment"> * is released. If this is the last task reference counting the rq's max</span></span><br><span class="line"><span class="comment"> * active clamp value, then the rq's clamp value is updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both refcounted tasks and rq's cached clamp values are expected to be</span></span><br><span class="line"><span class="comment"> * always valid. If it's detected they are not, as defensive programming,</span></span><br><span class="line"><span class="comment"> * enforce the expected state and warn.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec_id</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span> *<span class="title">uc_rq</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bkt_clamp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rq_clamp;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	bucket = &amp;uc_rq-&gt;bucket[uc_se-&gt;bucket_id];</span><br><span class="line">	SCHED_WARN_ON(!bucket-&gt;tasks);</span><br><span class="line">	<span class="keyword">if</span> (likely(bucket-&gt;tasks))</span><br><span class="line">		bucket-&gt;tasks--;</span><br><span class="line">	uc_se-&gt;active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep "local max aggregation" simple and accept to (possibly)</span></span><br><span class="line"><span class="comment">	 * overboost some RUNNABLE tasks in the same bucket.</span></span><br><span class="line"><span class="comment">	 * The rq clamp bucket value is reset to its base value whenever</span></span><br><span class="line"><span class="comment">	 * there are no more RUNNABLE tasks refcounting it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(bucket-&gt;tasks))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq_clamp = READ_ONCE(uc_rq-&gt;value);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defensive programming: this should never happen. If it happens,</span></span><br><span class="line"><span class="comment">	 * e.g. due to future modification, warn and fixup the expected value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SCHED_WARN_ON(bucket-&gt;value &gt; rq_clamp);</span><br><span class="line">	<span class="keyword">if</span> (bucket-&gt;value &gt;= rq_clamp) &#123;</span><br><span class="line">		bkt_clamp = uclamp_rq_max_value(rq, clamp_id, uc_se-&gt;value);</span><br><span class="line">		WRITE_ONCE(uc_rq-&gt;value, bkt_clamp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!p-&gt;sched_class-&gt;uclamp_enabled))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		uclamp_rq_inc_id(rq, p, clamp_id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset clamp idle holding when there is one RUNNABLE task */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE)</span><br><span class="line">		rq-&gt;uclamp_flags &amp;= ~UCLAMP_FLAG_IDLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!p-&gt;sched_class-&gt;uclamp_enabled))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		uclamp_rq_dec_id(rq, p, clamp_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">uclamp_update_active(struct task_struct *p, <span class="keyword">enum</span> uclamp_id clamp_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock the task and the rq where the task is (or was) queued.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We might lock the (previous) rq of a !RUNNABLE task, but that's the</span></span><br><span class="line"><span class="comment">	 * price to pay to safely serialize util_&#123;min,max&#125; updates with</span></span><br><span class="line"><span class="comment">	 * enqueues, dequeues and migration operations.</span></span><br><span class="line"><span class="comment">	 * This is the same locking schema used by __set_cpus_allowed_ptr().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setting the clamp bucket is serialized by task_rq_lock().</span></span><br><span class="line"><span class="comment">	 * If the task is not yet RUNNABLE and its task_struct is not</span></span><br><span class="line"><span class="comment">	 * affecting a valid clamp bucket, the next time it's enqueued,</span></span><br><span class="line"><span class="comment">	 * it will already see the updated clamp bucket value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;uclamp[clamp_id].active) &#123;</span><br><span class="line">		uclamp_rq_dec_id(rq, p, clamp_id);</span><br><span class="line">		uclamp_rq_inc_id(rq, p, clamp_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">uclamp_update_active_tasks(struct cgroup_subsys_state *css,</span><br><span class="line">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> clamps)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_task_iter</span> <span class="title">it</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	css_task_iter_start(css, <span class="number">0</span>, &amp;it);</span><br><span class="line">	<span class="keyword">while</span> ((p = css_task_iter_next(&amp;it))) &#123;</span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="number">0x1</span> &lt;&lt; clamp_id) &amp; clamps)</span><br><span class="line">				uclamp_update_active(p, clamp_id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	css_task_iter_end(&amp;it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_util_update_eff</span><span class="params">(struct cgroup_subsys_state *css)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_update_root_tg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = &amp;<span class="title">root_task_group</span>;</span></span><br><span class="line"></span><br><span class="line">	uclamp_se_set(&amp;tg-&gt;uclamp_req[UCLAMP_MIN],</span><br><span class="line">		      sysctl_sched_uclamp_util_min, <span class="literal">false</span>);</span><br><span class="line">	uclamp_se_set(&amp;tg-&gt;uclamp_req[UCLAMP_MAX],</span><br><span class="line">		      sysctl_sched_uclamp_util_max, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	cpu_util_update_eff(&amp;root_task_group.css);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_update_root_tg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_sched_uclamp_handler</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> update_root_tg = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> old_min, old_max;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;uclamp_mutex);</span><br><span class="line">	old_min = sysctl_sched_uclamp_util_min;</span><br><span class="line">	old_max = sysctl_sched_uclamp_util_max;</span><br><span class="line"></span><br><span class="line">	result = proc_dointvec(table, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> undo;</span><br><span class="line">	<span class="keyword">if</span> (!write)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysctl_sched_uclamp_util_min &gt; sysctl_sched_uclamp_util_max ||</span><br><span class="line">	    sysctl_sched_uclamp_util_max &gt; SCHED_CAPACITY_SCALE) &#123;</span><br><span class="line">		result = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> undo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_min != sysctl_sched_uclamp_util_min) &#123;</span><br><span class="line">		uclamp_se_set(&amp;uclamp_default[UCLAMP_MIN],</span><br><span class="line">			      sysctl_sched_uclamp_util_min, <span class="literal">false</span>);</span><br><span class="line">		update_root_tg = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (old_max != sysctl_sched_uclamp_util_max) &#123;</span><br><span class="line">		uclamp_se_set(&amp;uclamp_default[UCLAMP_MAX],</span><br><span class="line">			      sysctl_sched_uclamp_util_max, <span class="literal">false</span>);</span><br><span class="line">		update_root_tg = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (update_root_tg)</span><br><span class="line">		uclamp_update_root_tg();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We update all RUNNABLE tasks only when task groups are in use.</span></span><br><span class="line"><span class="comment">	 * Otherwise, keep it simple and do just a lazy update at each next</span></span><br><span class="line"><span class="comment">	 * task enqueue time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">undo:</span><br><span class="line">	sysctl_sched_uclamp_util_min = old_min;</span><br><span class="line">	sysctl_sched_uclamp_util_max = old_max;</span><br><span class="line">done:</span><br><span class="line">	mutex_unlock(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uclamp_validate</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lower_bound = p-&gt;uclamp_req[UCLAMP_MIN].value;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> upper_bound = p-&gt;uclamp_req[UCLAMP_MAX].value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MIN)</span><br><span class="line">		lower_bound = attr-&gt;sched_util_min;</span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MAX)</span><br><span class="line">		upper_bound = attr-&gt;sched_util_max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lower_bound &gt; upper_bound)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (upper_bound &gt; SCHED_CAPACITY_SCALE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_uclamp(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct sched_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On scheduling class change, reset to default clamps for tasks</span></span><br><span class="line"><span class="comment">	 * without a task-specific value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp_req</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value = uclamp_none(clamp_id);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Keep using defined clamps across class changes */</span></span><br><span class="line">		<span class="keyword">if</span> (uc_se-&gt;user_defined)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, RT tasks always get 100% boost */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(rt_task(p) &amp;&amp; clamp_id == UCLAMP_MIN))</span><br><span class="line">			clamp_value = uclamp_none(UCLAMP_MAX);</span><br><span class="line"></span><br><span class="line">		uclamp_se_set(uc_se, clamp_value, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!(attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MIN) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[UCLAMP_MIN],</span><br><span class="line">			      attr-&gt;sched_util_min, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MAX) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[UCLAMP_MAX],</span><br><span class="line">			      attr-&gt;sched_util_max, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_fork</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		p-&gt;uclamp[clamp_id].active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!p-&gt;sched_reset_on_fork))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_uclamp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span> = &#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;cpu_rq(cpu)-&gt;uclamp, <span class="number">0</span>,</span><br><span class="line">				<span class="keyword">sizeof</span>(struct uclamp_rq)*UCLAMP_CNT);</span><br><span class="line">		cpu_rq(cpu)-&gt;uclamp_flags = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;init_task.uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* System defaults allow max clamp values for both indexes */</span></span><br><span class="line">	uclamp_se_set(&amp;uc_max, uclamp_none(UCLAMP_MAX), <span class="literal">false</span>);</span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_default[clamp_id] = uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">		root_task_group.uclamp_req[clamp_id] = uc_max;</span><br><span class="line">		root_task_group.uclamp[clamp_id] = uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_UCLAMP_TASK */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc</span><span class="params">(struct rq *rq, struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec</span><span class="params">(struct rq *rq, struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">uclamp_validate</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_uclamp(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct sched_attr *attr) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_fork</span><span class="params">(struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_uclamp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_UCLAMP_TASK */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">enqueue_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_RESTORE)) &#123;</span><br><span class="line">		sched_info_queued(rq, p);</span><br><span class="line">		psi_enqueue(p, flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_inc(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dequeue_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DEQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DEQUEUE_SAVE)) &#123;</span><br><span class="line">		sched_info_dequeued(rq, p);</span><br><span class="line">		psi_dequeue(p, flags &amp; DEQUEUE_SLEEP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_dec(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activate_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">	p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deactivate_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;on_rq = (flags &amp; DEQUEUE_SLEEP) ? <span class="number">0</span> : TASK_ON_RQ_MIGRATING;</span><br><span class="line"></span><br><span class="line">	dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __normal_prio - return the priority that is based on the static prio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __normal_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the expected normal priority: i.e. priority</span></span><br><span class="line"><span class="comment"> * without taking RT-inheritance into account. Might be</span></span><br><span class="line"><span class="comment"> * boosted by interactivity modifiers. Changes upon fork,</span></span><br><span class="line"><span class="comment"> * setprio syscalls, and whenever the interactivity</span></span><br><span class="line"><span class="comment"> * estimator recalculates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">normal_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">		prio = MAX_DL_PRIO<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		prio = __normal_prio(p);</span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the current priority, i.e. the priority</span></span><br><span class="line"><span class="comment"> * taken into account by the scheduler. This value might</span></span><br><span class="line"><span class="comment"> * be boosted by RT tasks, or might be boosted by</span></span><br><span class="line"><span class="comment"> * interactivity modifiers. Will be RT if the task got</span></span><br><span class="line"><span class="comment"> * RT-boosted. If not then it returns p-&gt;normal_prio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">effective_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are RT tasks or we were boosted to RT priority,</span></span><br><span class="line"><span class="comment">	 * keep the priority unchanged. Otherwise, update priority</span></span><br><span class="line"><span class="comment">	 * to the normal priority:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> p-&gt;normal_prio;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_curr - is this task currently executing on a CPU?</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the task is currently executing. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">task_curr</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_curr(task_cpu(p)) == p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * switched_from, switched_to and prio_changed must _NOT_ drop rq-&gt;lock,</span></span><br><span class="line"><span class="comment"> * use the balance_callback list if you want balancing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this means any call to check_class_changed() must be followed by a call to</span></span><br><span class="line"><span class="comment"> * balance_callback().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check_class_changed</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">const</span> struct sched_class *prev_class,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">int</span> oldprio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (prev_class != p-&gt;sched_class) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prev_class-&gt;switched_from)</span><br><span class="line">			prev_class-&gt;switched_from(rq, p);</span><br><span class="line"></span><br><span class="line">		p-&gt;sched_class-&gt;switched_to(rq, p);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldprio != p-&gt;prio || dl_task(p))</span><br><span class="line">		p-&gt;sched_class-&gt;prio_changed(rq, p, oldprio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_preempt_curr</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class) &#123;</span><br><span class="line">		rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class == rq-&gt;curr-&gt;sched_class)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (class == p-&gt;sched_class) &#123;</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A queue event has occurred, and we're going to schedule.  In</span></span><br><span class="line"><span class="comment">	 * this case, we can save a useless back to back clock update.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(rq-&gt;curr) &amp;&amp; test_tsk_need_resched(rq-&gt;curr))</span><br><span class="line">		rq_clock_skip_update(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per-CPU kthreads are allowed to run on !active &amp;&amp; online CPUs, see</span></span><br><span class="line"><span class="comment"> * __set_cpus_allowed_ptr() and select_fallback_rq().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_cpu_allowed</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_per_cpu_kthread(p))</span><br><span class="line">		<span class="keyword">return</span> cpu_online(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cpu_active(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is how migration works:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) we invoke migration_cpu_stop() on the target CPU using</span></span><br><span class="line"><span class="comment"> *    stop_one_cpu().</span></span><br><span class="line"><span class="comment"> * 2) stopper starts to run (implicitly forcing the migrated thread</span></span><br><span class="line"><span class="comment"> *    off the CPU)</span></span><br><span class="line"><span class="comment"> * 3) it checks whether the migrated task is still in the wrong runqueue.</span></span><br><span class="line"><span class="comment"> * 4) if it's in the wrong runqueue then the migration thread removes</span></span><br><span class="line"><span class="comment"> *    it and puts it into the right queue.</span></span><br><span class="line"><span class="comment"> * 5) stopper completes and stop_one_cpu() returns and the migration</span></span><br><span class="line"><span class="comment"> *    is done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * move_queued_task - move a queued task to new rq.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns (locked) new rq. Old rq's lock is released.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct rq *<span class="title">move_queued_task</span><span class="params">(struct rq *rq, struct rq_flags *rf,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct task_struct *p, <span class="keyword">int</span> new_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(p-&gt;on_rq, TASK_ON_RQ_MIGRATING);</span><br><span class="line">	dequeue_task(rq, p, DEQUEUE_NOCLOCK);</span><br><span class="line">	set_task_cpu(p, new_cpu);</span><br><span class="line">	rq_unlock(rq, rf);</span><br><span class="line"></span><br><span class="line">	rq = cpu_rq(new_cpu);</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, rf);</span><br><span class="line">	BUG_ON(task_cpu(p) != new_cpu);</span><br><span class="line">	enqueue_task(rq, p, <span class="number">0</span>);</span><br><span class="line">	p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">	check_preempt_curr(rq, p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Move (not current) task off this CPU, onto the destination CPU. We're doing</span></span><br><span class="line"><span class="comment"> * this because either it can't run here any more (set_cpus_allowed()</span></span><br><span class="line"><span class="comment"> * away from this CPU, or CPU going down), or because we're</span></span><br><span class="line"><span class="comment"> * attempting to rebalance this task on exec (sched_exec).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So we race with normal scheduler movements, but that's OK, as long</span></span><br><span class="line"><span class="comment"> * as the task is no longer on this CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *__<span class="title">migrate_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>,</span></span><br><span class="line"><span class="class">				 <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">int</span> <span class="title">dest_cpu</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* Affinity changed (again). */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_cpu_allowed(p, dest_cpu))</span><br><span class="line">		<span class="keyword">return</span> rq;</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	rq = move_queued_task(rq, rf, p, dest_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * migration_cpu_stop - this will be executed by a highprio stopper thread</span></span><br><span class="line"><span class="comment"> * and performs thread migration by bumping thread off CPU then</span></span><br><span class="line"><span class="comment"> * 'pushing' onto another runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">migration_cpu_stop</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> *<span class="title">arg</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">arg</span>-&gt;<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The original target CPU might have gone down and we might</span></span><br><span class="line"><span class="comment">	 * be on another CPU but it doesn't matter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to explicitly wake pending tasks before running</span></span><br><span class="line"><span class="comment">	 * __migrate_task() such that we will not miss enforcing cpus_ptr</span></span><br><span class="line"><span class="comment">	 * during wakeups, see set_cpus_allowed_ptr()'s TASK_WAKING test.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	flush_smp_call_function_from_idle();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;p-&gt;pi_lock);</span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If task_rq(p) != rq, it cannot be migrated here, because we're</span></span><br><span class="line"><span class="comment">	 * holding rq-&gt;lock, if p-&gt;on_rq == 0 it cannot get enqueued because</span></span><br><span class="line"><span class="comment">	 * we're holding p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_rq(p) == rq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task_on_rq_queued(p))</span><br><span class="line">			rq = __migrate_task(rq, &amp;rf, p, arg-&gt;dest_cpu);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p-&gt;wake_cpu = arg-&gt;dest_cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">	raw_spin_unlock(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_class::set_cpus_allowed must do the below, but is not required to</span></span><br><span class="line"><span class="comment"> * actually call this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpus_allowed_common</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpumask_copy(&amp;p-&gt;cpus_mask, new_mask);</span><br><span class="line">	p-&gt;nr_cpus_allowed = cpumask_weight(new_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_set_cpus_allowed</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">task_rq</span>(<span class="title">p</span>);</span></span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because __kthread_bind() calls this on blocked tasks without</span></span><br><span class="line"><span class="comment">		 * holding rq-&gt;lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_class-&gt;set_cpus_allowed(p, new_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change a given task's CPU affinity. Migrate the thread to a</span></span><br><span class="line"><span class="comment"> * proper CPU and schedule it away if the CPU it's executing on</span></span><br><span class="line"><span class="comment"> * is removed from the allowed bitmask.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> the caller must have a valid reference to the task, the</span></span><br><span class="line"><span class="comment"> * task must not exit() &amp; deallocate itself prematurely. The</span></span><br><span class="line"><span class="comment"> * call is not atomic; no spinlocks may be held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __set_cpus_allowed_ptr(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct cpumask *new_mask, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">cpu_valid_mask</span> = <span class="title">cpu_active_mask</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dest_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Kernel threads are allowed on online &amp;&amp; !active CPUs</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpu_valid_mask = cpu_online_mask;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must re-check here, to close a race against __kthread_bind(),</span></span><br><span class="line"><span class="comment">	 * sched_setaffinity() is not guaranteed to observe the flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check &amp;&amp; (p-&gt;flags &amp; PF_NO_SETAFFINITY)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpumask_equal(&amp;p-&gt;cpus_mask, new_mask))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Picking a ~random cpu helps in cases where we are changing affinity</span></span><br><span class="line"><span class="comment">	 * for groups of tasks (ie. cpuset), so that load balancing is not</span></span><br><span class="line"><span class="comment">	 * immediately required to distribute the tasks within their new mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dest_cpu = cpumask_any_and_distribute(cpu_valid_mask, new_mask);</span><br><span class="line">	<span class="keyword">if</span> (dest_cpu &gt;= nr_cpu_ids) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	do_set_cpus_allowed(p, new_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For kernel threads that do indeed end up on online &amp;&amp;</span></span><br><span class="line"><span class="comment">		 * !active we want to ensure they are strict per-CPU threads.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON(cpumask_intersects(new_mask, cpu_online_mask) &amp;&amp;</span><br><span class="line">			!cpumask_intersects(new_mask, cpu_active_mask) &amp;&amp;</span><br><span class="line">			p-&gt;nr_cpus_allowed != <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can the task run on the task's current CPU? If so, we're done */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_test_cpu(task_cpu(p), new_mask))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_running(rq, p) || p-&gt;state == TASK_WAKING) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, dest_cpu &#125;;</span><br><span class="line">		<span class="comment">/* Need help from migration thread: drop lock and wait. */</span></span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &amp;arg);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, since we're going to drop the lock immediately</span></span><br><span class="line"><span class="comment">		 * afterwards anyway.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = move_queued_task(rq, &amp;rf, p, dest_cpu);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_cpus_allowed_ptr</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __set_cpus_allowed_ptr(p, new_mask, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_task_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> new_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We should never call set_task_cpu() on a blocked task,</span></span><br><span class="line"><span class="comment">	 * ttwu() will sort out the placement.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(p-&gt;state != TASK_RUNNING &amp;&amp; p-&gt;state != TASK_WAKING &amp;&amp;</span><br><span class="line">			!p-&gt;on_rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Migrating fair class task must have p-&gt;on_rq = TASK_ON_RQ_MIGRATING,</span></span><br><span class="line"><span class="comment">	 * because schedstat_wait_&#123;start,end&#125; rebase migrating task's wait_start</span></span><br><span class="line"><span class="comment">	 * time relying on p-&gt;on_rq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(p-&gt;state == TASK_RUNNING &amp;&amp;</span><br><span class="line">		     p-&gt;sched_class == &amp;fair_sched_class &amp;&amp;</span><br><span class="line">		     (p-&gt;on_rq &amp;&amp; !task_on_rq_migrating(p)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The caller should hold either p-&gt;pi_lock or rq-&gt;lock, when changing</span></span><br><span class="line"><span class="comment">	 * a task's CPU. -&gt;pi_lock for waking tasks, rq-&gt;lock for runnable tasks.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sched_move_task() holds both and thus holding either pins the cgroup,</span></span><br><span class="line"><span class="comment">	 * see task_group().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Furthermore, all task_rq users should acquire both locks, see</span></span><br><span class="line"><span class="comment">	 * task_rq_lock().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(debug_locks &amp;&amp; !(lockdep_is_held(&amp;p-&gt;pi_lock) ||</span><br><span class="line">				      lockdep_is_held(&amp;task_rq(p)-&gt;lock)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clearly, migrating tasks to offline CPUs is a fairly daft thing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!cpu_online(new_cpu));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	trace_sched_migrate_task(p, new_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) != new_cpu) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;sched_class-&gt;migrate_task_rq)</span><br><span class="line">			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);</span><br><span class="line">		p-&gt;se.nr_migrations++;</span><br><span class="line">		rseq_migrate(p);</span><br><span class="line">		perf_event_task_migrate(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__set_task_cpu(p, new_cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __migrate_swap_task(struct task_struct *p, <span class="keyword">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">src_rq</span>, *<span class="title">dst_rq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">srf</span>, <span class="title">drf</span>;</span></span><br><span class="line"></span><br><span class="line">		src_rq = task_rq(p);</span><br><span class="line">		dst_rq = cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">		rq_pin_lock(src_rq, &amp;srf);</span><br><span class="line">		rq_pin_lock(dst_rq, &amp;drf);</span><br><span class="line"></span><br><span class="line">		deactivate_task(src_rq, p, <span class="number">0</span>);</span><br><span class="line">		set_task_cpu(p, cpu);</span><br><span class="line">		activate_task(dst_rq, p, <span class="number">0</span>);</span><br><span class="line">		check_preempt_curr(dst_rq, p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		rq_unpin_lock(dst_rq, &amp;drf);</span><br><span class="line">		rq_unpin_lock(src_rq, &amp;srf);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Task isn't running anymore; make it appear like we migrated</span></span><br><span class="line"><span class="comment">		 * it before it went to sleep. This means on wakeup we make the</span></span><br><span class="line"><span class="comment">		 * previous CPU our target instead of where it really is.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;wake_cpu = cpu;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">src_task</span>, *<span class="title">dst_task</span>;</span></span><br><span class="line">	<span class="keyword">int</span> src_cpu, dst_cpu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">migrate_swap_stop</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> *<span class="title">arg</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">src_rq</span>, *<span class="title">dst_rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpu_active(arg-&gt;src_cpu) || !cpu_active(arg-&gt;dst_cpu))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	src_rq = cpu_rq(arg-&gt;src_cpu);</span><br><span class="line">	dst_rq = cpu_rq(arg-&gt;dst_cpu);</span><br><span class="line"></span><br><span class="line">	double_raw_lock(&amp;arg-&gt;src_task-&gt;pi_lock,</span><br><span class="line">			&amp;arg-&gt;dst_task-&gt;pi_lock);</span><br><span class="line">	double_rq_lock(src_rq, dst_rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(arg-&gt;dst_task) != arg-&gt;dst_cpu)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(arg-&gt;src_task) != arg-&gt;src_cpu)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg-&gt;dst_cpu, arg-&gt;src_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg-&gt;src_cpu, arg-&gt;dst_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	__migrate_swap_task(arg-&gt;src_task, arg-&gt;dst_cpu);</span><br><span class="line">	__migrate_swap_task(arg-&gt;dst_task, arg-&gt;src_cpu);</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	double_rq_unlock(src_rq, dst_rq);</span><br><span class="line">	raw_spin_unlock(&amp;arg-&gt;dst_task-&gt;pi_lock);</span><br><span class="line">	raw_spin_unlock(&amp;arg-&gt;src_task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cross migrate two tasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">migrate_swap</span><span class="params">(struct task_struct *cur, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> target_cpu, <span class="keyword">int</span> curr_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	arg = (struct migration_swap_arg)&#123;</span><br><span class="line">		.src_task = cur,</span><br><span class="line">		.src_cpu = curr_cpu,</span><br><span class="line">		.dst_task = p,</span><br><span class="line">		.dst_cpu = target_cpu,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arg.src_cpu == arg.dst_cpu)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These three tests are all lockless; this is OK since all of them</span></span><br><span class="line"><span class="comment">	 * will be re-checked with proper locks held further down the line.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg.dst_cpu, arg.src_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg.src_cpu, arg.dst_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);</span><br><span class="line">	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &amp;arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wait_task_inactive - wait for a thread to unschedule.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @match_state is nonzero, it's the @p-&gt;state value just checked and</span></span><br><span class="line"><span class="comment"> * not expected to change.  If it changes, i.e. @p might have woken up,</span></span><br><span class="line"><span class="comment"> * then return zero.  When we succeed in waiting for @p to be off its CPU,</span></span><br><span class="line"><span class="comment"> * we return a positive number (its total switch count).  If a second call</span></span><br><span class="line"><span class="comment"> * a short while later returns the same number, the caller can be sure that</span></span><br><span class="line"><span class="comment"> * @p has remained unscheduled the whole time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller must ensure that the task *will* unschedule sometime soon,</span></span><br><span class="line"><span class="comment"> * else this function might spin for a *long* time. This function can't</span></span><br><span class="line"><span class="comment"> * be called with interrupts off, or it may introduce deadlock with</span></span><br><span class="line"><span class="comment"> * smp_call_function() if an IPI is sent by the same process we are</span></span><br><span class="line"><span class="comment"> * waiting to become inactive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">wait_task_inactive</span><span class="params">(struct task_struct *p, <span class="keyword">long</span> match_state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> running, queued;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ncsw;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We do the initial early heuristics without holding</span></span><br><span class="line"><span class="comment">		 * any task-queue locks at all. We'll only try to get</span></span><br><span class="line"><span class="comment">		 * the runqueue lock when things look like they will</span></span><br><span class="line"><span class="comment">		 * work out!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = task_rq(p);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the task is actively running on another CPU</span></span><br><span class="line"><span class="comment">		 * still, just relax and busy-wait without holding</span></span><br><span class="line"><span class="comment">		 * any locks.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * NOTE! Since we don't hold any locks, it's not</span></span><br><span class="line"><span class="comment">		 * even sure that "rq" stays as the right runqueue!</span></span><br><span class="line"><span class="comment">		 * But we don't care, since "task_running()" will</span></span><br><span class="line"><span class="comment">		 * return false if the runqueue has changed and p</span></span><br><span class="line"><span class="comment">		 * is actually now running somewhere else!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (task_running(rq, p)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (match_state &amp;&amp; unlikely(p-&gt;state != match_state))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			cpu_relax();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ok, time to look more closely! We need the rq</span></span><br><span class="line"><span class="comment">		 * lock now, to be *sure*. If we're wrong, we'll</span></span><br><span class="line"><span class="comment">		 * just go back and repeat.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">		trace_sched_wait_task(p);</span><br><span class="line">		running = task_running(rq, p);</span><br><span class="line">		queued = task_on_rq_queued(p);</span><br><span class="line">		ncsw = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!match_state || p-&gt;state == match_state)</span><br><span class="line">			ncsw = p-&gt;nvcsw | LONG_MIN; <span class="comment">/* sets MSB */</span></span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If it changed from the expected state, bail out now.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!ncsw))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Was it really running after all now that we</span></span><br><span class="line"><span class="comment">		 * checked with the proper locks actually held?</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Oops. Go back and try again..</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(running)) &#123;</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It's not enough that it's not actively running,</span></span><br><span class="line"><span class="comment">		 * it must be off the runqueue _entirely_, and not</span></span><br><span class="line"><span class="comment">		 * preempted!</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * So if it was still runnable (but just not actively</span></span><br><span class="line"><span class="comment">		 * running right now), it's preempted, and we should</span></span><br><span class="line"><span class="comment">		 * yield - it could be a while.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(queued)) &#123;</span><br><span class="line">			<span class="keyword">ktime_t</span> to = NSEC_PER_SEC / HZ;</span><br><span class="line"></span><br><span class="line">			set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">			schedule_hrtimeout(&amp;to, HRTIMER_MODE_REL);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ahh, all good. It wasn't running, and it wasn't</span></span><br><span class="line"><span class="comment">		 * runnable, which means that it will never become</span></span><br><span class="line"><span class="comment">		 * running in the future either. We're all done!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ncsw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * kick_process - kick a running thread to enter/exit the kernel</span></span><br><span class="line"><span class="comment"> * @p: the to-be-kicked thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cause a process which is running on another CPU to enter</span></span><br><span class="line"><span class="comment"> * kernel-mode, without any delay. (to get signals handled.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this function doesn't have to take the runqueue lock,</span></span><br><span class="line"><span class="comment"> * because all it wants to ensure is that the remote task enters</span></span><br><span class="line"><span class="comment"> * the kernel. If the IPI races and the task has been migrated</span></span><br><span class="line"><span class="comment"> * to another CPU then no harm is done and the purpose has been</span></span><br><span class="line"><span class="comment"> * achieved as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kick_process</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = task_cpu(p);</span><br><span class="line">	<span class="keyword">if</span> ((cpu != smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;cpus_ptr is protected by both rq-&gt;lock and p-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A few notes on cpu_active vs cpu_online:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - cpu_active must be a subset of cpu_online</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - on CPU-up we allow per-CPU kthreads on the online &amp;&amp; !active CPU,</span></span><br><span class="line"><span class="comment"> *    see __set_cpus_allowed_ptr(). At this point the newly online</span></span><br><span class="line"><span class="comment"> *    CPU isn't yet part of the sched domains, and balancing will not</span></span><br><span class="line"><span class="comment"> *    see it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - on CPU-down we clear cpu_active() to mask the sched domains and</span></span><br><span class="line"><span class="comment"> *    avoid the load balancer to place new tasks on the to be removed</span></span><br><span class="line"><span class="comment"> *    CPU. Existing tasks will remain running there and will be taken</span></span><br><span class="line"><span class="comment"> *    off.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This means that fallback selection must not select !active CPUs.</span></span><br><span class="line"><span class="comment"> * And can assume that any active CPU must be online. Conversely</span></span><br><span class="line"><span class="comment"> * select_task_rq() below may allow selection of !active CPUs in order</span></span><br><span class="line"><span class="comment"> * to satisfy the above rules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_fallback_rq</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nid = cpu_to_node(cpu);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">nodemask</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; cpuset, possible, fail &#125; state = cpuset;</span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the node that the CPU is on has been offlined, cpu_to_node()</span></span><br><span class="line"><span class="comment">	 * will return -1. There is no CPU on the node, and we should</span></span><br><span class="line"><span class="comment">	 * select the CPU on the other node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nid != <span class="number">-1</span>) &#123;</span><br><span class="line">		nodemask = cpumask_of_node(nid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Look for allowed, online CPU in same node. */</span></span><br><span class="line">		for_each_cpu(dest_cpu, nodemask) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpu_active(dest_cpu))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (cpumask_test_cpu(dest_cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">return</span> dest_cpu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* Any allowed, online CPU? */</span></span><br><span class="line">		for_each_cpu(dest_cpu, p-&gt;cpus_ptr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_cpu_allowed(p, dest_cpu))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No more Mr. Nice Guy. */</span></span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">		<span class="keyword">case</span> cpuset:</span><br><span class="line">			<span class="keyword">if</span> (IS_ENABLED(CONFIG_CPUSETS)) &#123;</span><br><span class="line">				cpuset_cpus_allowed_fallback(p);</span><br><span class="line">				state = possible;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Fall-through */</span></span><br><span class="line">		<span class="keyword">case</span> possible:</span><br><span class="line">			do_set_cpus_allowed(p, cpu_possible_mask);</span><br><span class="line">			state = fail;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> fail:</span><br><span class="line">			BUG();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (state != cpuset) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don't tell them about moving exiting tasks or</span></span><br><span class="line"><span class="comment">		 * kernel threads (both mm NULL), since they never</span></span><br><span class="line"><span class="comment">		 * leave kernel.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;mm &amp;&amp; printk_ratelimit()) &#123;</span><br><span class="line">			printk_deferred(<span class="string">"process %d (%s) no longer affine to cpu%d\n"</span>,</span><br><span class="line">					task_pid_nr(p), p-&gt;comm, cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dest_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller (fork, wakeup) owns p-&gt;pi_lock, -&gt;cpus_ptr is stable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_task_rq</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> sd_flags, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;nr_cpus_allowed &gt; <span class="number">1</span>)</span><br><span class="line">		cpu = p-&gt;sched_class-&gt;select_task_rq(p, cpu, sd_flags, wake_flags);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cpu = cpumask_any(p-&gt;cpus_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order not to call set_task_cpu() on a blocking task we need</span></span><br><span class="line"><span class="comment">	 * to rely on ttwu() to place the task on a valid -&gt;cpus_ptr</span></span><br><span class="line"><span class="comment">	 * CPU.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since this is common to all placement strategies, this lives here.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * [ this allows -&gt;select_task() to simply return task_cpu(p) and</span></span><br><span class="line"><span class="comment">	 *   not worry about this generic constraint ]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!is_cpu_allowed(p, cpu)))</span><br><span class="line">		cpu = select_fallback_rq(task_cpu(p), p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_set_stop_task</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span> .sched_priority = MAX_RT_PRIO - <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">old_stop</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>)-&gt;<span class="title">stop</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stop) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make it appear like a SCHED_FIFO task, its something</span></span><br><span class="line"><span class="comment">		 * userspace knows about and won't get confused about.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Also, it will make PI more or less work without too</span></span><br><span class="line"><span class="comment">		 * much confusion -- but then, stop work should not</span></span><br><span class="line"><span class="comment">		 * rely on PI working anyway.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sched_setscheduler_nocheck(stop, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">		stop-&gt;sched_class = &amp;stop_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpu_rq(cpu)-&gt;stop = stop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_stop) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Reset it back to a normal scheduling class so that</span></span><br><span class="line"><span class="comment">		 * it can die in pieces.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		old_stop-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __set_cpus_allowed_ptr(struct task_struct *p,</span><br><span class="line">					 <span class="keyword">const</span> struct cpumask *new_mask, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> set_cpus_allowed_ptr(p, new_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ttwu_stat(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!schedstat_enabled())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq = this_rq();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (cpu == rq-&gt;cpu) &#123;</span><br><span class="line">		__schedstat_inc(rq-&gt;ttwu_local);</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_local);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct sched_domain *sd;</span><br><span class="line"></span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_remote);</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		for_each_domain(rq-&gt;cpu, sd) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cpumask_test_cpu(cpu, sched_domain_span(sd))) &#123;</span><br><span class="line">				__schedstat_inc(sd-&gt;ttwu_wake_remote);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_MIGRATED)</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_migrate);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	__schedstat_inc(rq-&gt;ttwu_count);</span><br><span class="line">	__schedstat_inc(p-&gt;se.statistics.nr_wakeups);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_SYNC)</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_sync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the task runnable and perform wakeup-preemption.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ttwu_do_wakeup</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line">	trace_sched_wakeup(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Our task @p is fully woken up and running; so its safe to</span></span><br><span class="line"><span class="comment">		 * drop the rq-&gt;lock, hereafter rq is only used for statistics.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unpin_lock(rq, rf);</span><br><span class="line">		p-&gt;sched_class-&gt;task_woken(rq, p);</span><br><span class="line">		rq_repin_lock(rq, rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;idle_stamp) &#123;</span><br><span class="line">		u64 delta = rq_clock(rq) - rq-&gt;idle_stamp;</span><br><span class="line">		u64 max = <span class="number">2</span>*rq-&gt;max_idle_balance_cost;</span><br><span class="line"></span><br><span class="line">		update_avg(&amp;rq-&gt;avg_idle, delta);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;avg_idle &gt; max)</span><br><span class="line">			rq-&gt;avg_idle = max;</span><br><span class="line"></span><br><span class="line">		rq-&gt;idle_stamp = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ttwu_do_activate(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wake_flags,</span><br><span class="line">		 struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_contributes_to_load)</span><br><span class="line">		rq-&gt;nr_uninterruptible--;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_MIGRATED)</span><br><span class="line">		en_flags |= ENQUEUE_MIGRATED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	activate_task(rq, p, en_flags);</span><br><span class="line">	ttwu_do_wakeup(rq, p, wake_flags, rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called in case the task @p isn't fully descheduled from its runqueue,</span></span><br><span class="line"><span class="comment"> * in this case we must do a remote wakeup. Its a 'light' wakeup though,</span></span><br><span class="line"><span class="comment"> * since all we need to do is flip p-&gt;state to TASK_RUNNING, since</span></span><br><span class="line"><span class="comment"> * the task is still -&gt;on_rq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ttwu_remote</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="comment">/* check_preempt_curr() may use rq clock */</span></span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line">		ttwu_do_wakeup(rq, p, wake_flags, &amp;rf);</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__task_rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_ttwu_pending</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">llist</span> = <span class="title">arg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!llist)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * rq::ttwu_pending racy indication of out-standing wakeups.</span></span><br><span class="line"><span class="comment">	 * Races such that false-negatives are possible, since they</span></span><br><span class="line"><span class="comment">	 * are shorter lived that false-positives would be.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(rq-&gt;ttwu_pending, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry.llist) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(p-&gt;on_cpu))</span><br><span class="line">			smp_cond_load_acquire(&amp;p-&gt;on_cpu, !VAL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))</span><br><span class="line">			set_task_cpu(p, cpu_of(rq));</span><br><span class="line"></span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : <span class="number">0</span>, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_call_function_single_ipi</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">		arch_send_call_function_single_ipi(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue a task on the target CPUs wake_list and wake the CPU via IPI if</span></span><br><span class="line"><span class="comment"> * necessary. The wakee CPU on receipt of the IPI will queue the task</span></span><br><span class="line"><span class="comment"> * via sched_ttwu_wakeup() for activation so the wakee incurs the cost</span></span><br><span class="line"><span class="comment"> * of the wakeup instead of the waker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ttwu_queue_wakelist(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup = !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(rq-&gt;ttwu_pending, <span class="number">1</span>);</span><br><span class="line">	__smp_call_single_queue(cpu, &amp;p-&gt;wake_entry.llist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_if_idle</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		<span class="comment">/* Else CPU is not idle, do nothing here: */</span></span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cpus_share_cache</span><span class="params">(<span class="keyword">int</span> this_cpu, <span class="keyword">int</span> that_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ttwu_queue_cond</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the CPU does not share cache, then queue the task on the</span></span><br><span class="line"><span class="comment">	 * remote rqs wakelist to avoid accessing remote data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpus_share_cache(smp_processor_id(), cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the task is descheduling and the only running task on the</span></span><br><span class="line"><span class="comment">	 * CPU then use the wakelist to offload the task activation to</span></span><br><span class="line"><span class="comment">	 * the soon-to-be-idle CPU as the current CPU is likely busy.</span></span><br><span class="line"><span class="comment">	 * nr_running is checked to avoid unnecessary task stacking.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((wake_flags &amp; WF_ON_CPU) &amp;&amp; cpu_rq(cpu)-&gt;nr_running &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ttwu_queue_wakelist</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sched_feat(TTWU_QUEUE) &amp;&amp; ttwu_queue_cond(cpu, wake_flags)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(cpu == smp_processor_id()))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		sched_clock_cpu(cpu); <span class="comment">/* Sync clocks across CPUs */</span></span><br><span class="line">		__ttwu_queue_wakelist(p, cpu, wake_flags);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ttwu_queue</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">	<span class="keyword">if</span> (ttwu_queue_wakelist(p, cpu, wake_flags))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notes on Program-Order guarantees on SMP systems.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  MIGRATION</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The basic program-order guarantee on SMP systems is that when a task [t]</span></span><br><span class="line"><span class="comment"> * migrates, all its activity on its old CPU [c0] happens-before any subsequent</span></span><br><span class="line"><span class="comment"> * execution on its new CPU [c1].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For migration (of runnable tasks) this is provided by the following means:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  A) UNLOCK of the rq(c0)-&gt;lock scheduling out task t</span></span><br><span class="line"><span class="comment"> *  B) migration for t is required to synchronize *both* rq(c0)-&gt;lock and</span></span><br><span class="line"><span class="comment"> *     rq(c1)-&gt;lock (if not at the same time, then in that order).</span></span><br><span class="line"><span class="comment"> *  C) LOCK of the rq(c1)-&gt;lock scheduling in task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release/acquire chaining guarantees that B happens after A and C after B.</span></span><br><span class="line"><span class="comment"> * Note: the CPU doing B need not be c0 or c1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   CPU0            CPU1            CPU2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   LOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *   sched-out X</span></span><br><span class="line"><span class="comment"> *   sched-in Y</span></span><br><span class="line"><span class="comment"> *   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                   LOCK rq(0)-&gt;lock // orders against CPU0</span></span><br><span class="line"><span class="comment"> *                                   dequeue X</span></span><br><span class="line"><span class="comment"> *                                   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                   LOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *                                   enqueue X</span></span><br><span class="line"><span class="comment"> *                                   UNLOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                   LOCK rq(1)-&gt;lock // orders against CPU2</span></span><br><span class="line"><span class="comment"> *                   sched-out Z</span></span><br><span class="line"><span class="comment"> *                   sched-in X</span></span><br><span class="line"><span class="comment"> *                   UNLOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  BLOCKING -- aka. SLEEP + WAKEUP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For blocking we (obviously) need to provide the same guarantee as for</span></span><br><span class="line"><span class="comment"> * migration. However the means are completely different as there is no lock</span></span><br><span class="line"><span class="comment"> * chain to provide order. Instead we do:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1) smp_store_release(X-&gt;on_cpu, 0)</span></span><br><span class="line"><span class="comment"> *   2) smp_cond_load_acquire(!X-&gt;on_cpu)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   CPU0 (schedule)  CPU1 (try_to_wake_up) CPU2 (schedule)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   LOCK rq(0)-&gt;lock LOCK X-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *   dequeue X</span></span><br><span class="line"><span class="comment"> *   sched-out X</span></span><br><span class="line"><span class="comment"> *   smp_store_release(X-&gt;on_cpu, 0);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    smp_cond_load_acquire(&amp;X-&gt;on_cpu, !VAL);</span></span><br><span class="line"><span class="comment"> *                    X-&gt;state = WAKING</span></span><br><span class="line"><span class="comment"> *                    set_task_cpu(X,2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    LOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *                    enqueue X</span></span><br><span class="line"><span class="comment"> *                    X-&gt;state = RUNNING</span></span><br><span class="line"><span class="comment"> *                    UNLOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                          LOCK rq(2)-&gt;lock // orders against CPU1</span></span><br><span class="line"><span class="comment"> *                                          sched-out Z</span></span><br><span class="line"><span class="comment"> *                                          sched-in X</span></span><br><span class="line"><span class="comment"> *                                          UNLOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    UNLOCK X-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, for wakeups there is a second guarantee we must provide, namely we</span></span><br><span class="line"><span class="comment"> * must ensure that CONDITION=1 done by the caller can not be reordered with</span></span><br><span class="line"><span class="comment"> * accesses to the task state; see try_to_wake_up() and set_current_state().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_wake_up - wake up a thread</span></span><br><span class="line"><span class="comment"> * @p: the thread to be awakened</span></span><br><span class="line"><span class="comment"> * @state: the mask of task states that can be woken</span></span><br><span class="line"><span class="comment"> * @wake_flags: wake modifier flags (WF_*)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If (@state &amp; @p-&gt;state) @p-&gt;state = TASK_RUNNING.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task was not queued/runnable, also place it back on a runqueue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomic against schedule() which would dequeue a task, also see</span></span><br><span class="line"><span class="comment"> * set_current_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function executes a full memory barrier before accessing the task</span></span><br><span class="line"><span class="comment"> * state; see set_current_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: %true if @p-&gt;state changes (an actual wakeup was done),</span></span><br><span class="line"><span class="comment"> *	   %false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">try_to_wake_up(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> cpu, success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (p == current) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We're waking current, this means 'p-&gt;on_rq' and 'task_cpu(p)</span></span><br><span class="line"><span class="comment">		 * == smp_processor_id()'. Together this means we can special</span></span><br><span class="line"><span class="comment">		 * case the whole 'p-&gt;on_rq &amp;&amp; ttwu_remote()' case below</span></span><br><span class="line"><span class="comment">		 * without taking any locks.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In particular:</span></span><br><span class="line"><span class="comment">		 *  - we rely on Program-Order guarantees for all the ordering,</span></span><br><span class="line"><span class="comment">		 *  - we're serialized against set_special_state() by virtue of</span></span><br><span class="line"><span class="comment">		 *    it disabling IRQs (this allows not taking -&gt;pi_lock).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		success = <span class="number">1</span>;</span><br><span class="line">		trace_sched_waking(p);</span><br><span class="line">		p-&gt;state = TASK_RUNNING;</span><br><span class="line">		trace_sched_wakeup(p);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are going to wake up a thread waiting for CONDITION we</span></span><br><span class="line"><span class="comment">	 * need to ensure that CONDITION=1 done by the caller can not be</span></span><br><span class="line"><span class="comment">	 * reordered with p-&gt;state check below. This pairs with mb() in</span></span><br><span class="line"><span class="comment">	 * set_current_state() the waiting thread does.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	trace_sched_waking(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We're going to change -&gt;state: */</span></span><br><span class="line">	success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would</span></span><br><span class="line"><span class="comment">	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck</span></span><br><span class="line"><span class="comment">	 * in smp_cond_load_acquire() below.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sched_ttwu_pending()			try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 1			  LOAD p-&gt;state</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * [task p]</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;state = UNINTERRUPTIBLE	  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A similar smb_rmb() lives in try_invoke_on_locked_down_task().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(p-&gt;on_rq) &amp;&amp; ttwu_remote(p, wake_flags))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;in_iowait) &#123;</span><br><span class="line">		delayacct_blkio_end(p);</span><br><span class="line">		atomic_dec(&amp;task_rq(p)-&gt;nr_iowait);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_cpu _after_ p-&gt;on_rq, otherwise it would be</span></span><br><span class="line"><span class="comment">	 * possible to, falsely, observe p-&gt;on_cpu == 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * One must be running (-&gt;on_cpu == 1) in order to remove oneself</span></span><br><span class="line"><span class="comment">	 * from the runqueue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')	try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_cpu = 1		  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (put 'p' to sleep)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 0			  LOAD p-&gt;on_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Form a control-dep-acquire with p-&gt;on_rq == 0 above, to ensure</span></span><br><span class="line"><span class="comment">	 * schedule()'s deactivate_task() has 'happened' and p will no longer</span></span><br><span class="line"><span class="comment">	 * care about it's own p-&gt;state. See the comment in __schedule().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_acquire__after_ctrl_dep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're doing the wakeup (@success == 1), they did a dequeue (p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 * == 0), which means we need to do an enqueue, change p-&gt;state to</span></span><br><span class="line"><span class="comment">	 * TASK_WAKING such that we can unlock p-&gt;pi_lock before doing the</span></span><br><span class="line"><span class="comment">	 * enqueue, such as ttwu_queue_wakelist().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;state = TASK_WAKING;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the owning (remote) CPU is still in the middle of schedule() with</span></span><br><span class="line"><span class="comment">	 * this task as prev, considering queueing p on the remote CPUs wake_list</span></span><br><span class="line"><span class="comment">	 * which potentially sends an IPI instead of spinning on p-&gt;on_cpu to</span></span><br><span class="line"><span class="comment">	 * let the waker make forward progress. This is safe because IRQs are</span></span><br><span class="line"><span class="comment">	 * disabled and the IPI will deliver after on_cpu is cleared.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ensure we load task_cpu(p) after p-&gt;on_cpu:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * set_task_cpu(p, cpu);</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;cpu = @cpu</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spin_lock()		smp_cond_load_acquire(&amp;p-&gt;on_cpu)</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_cpu = 1		LOAD p-&gt;cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * to ensure we observe the correct CPU on which the task is currently</span></span><br><span class="line"><span class="comment">	 * scheduling.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp;</span><br><span class="line">	    ttwu_queue_wakelist(p, task_cpu(p), wake_flags | WF_ON_CPU))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the owning (remote) CPU is still in the middle of schedule() with</span></span><br><span class="line"><span class="comment">	 * this task as prev, wait until its done referencing the task.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the smp_store_release() in finish_task().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This ensures that tasks getting woken will be fully ordered against</span></span><br><span class="line"><span class="comment">	 * their previous state and preserve Program Order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_cond_load_acquire(&amp;p-&gt;on_cpu, !VAL);</span><br><span class="line"></span><br><span class="line">	cpu = select_task_rq(p, p-&gt;wake_cpu, SD_BALANCE_WAKE, wake_flags);</span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) != cpu) &#123;</span><br><span class="line">		wake_flags |= WF_MIGRATED;</span><br><span class="line">		psi_ttwu_dequeue(p);</span><br><span class="line">		set_task_cpu(p, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	cpu = task_cpu(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	ttwu_queue(p, cpu, wake_flags);</span><br><span class="line">unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (success)</span><br><span class="line">		ttwu_stat(p, task_cpu(p), wake_flags);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_invoke_on_locked_down_task - Invoke a function on task in fixed state</span></span><br><span class="line"><span class="comment"> * @p: Process for which the function is to be invoked.</span></span><br><span class="line"><span class="comment"> * @func: Function to invoke.</span></span><br><span class="line"><span class="comment"> * @arg: Argument to function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the specified task can be quickly locked into a definite state</span></span><br><span class="line"><span class="comment"> * (either sleeping or on a given runqueue), arrange to keep it in that</span></span><br><span class="line"><span class="comment"> * state while invoking @func(@arg).  This function can use -&gt;on_rq and</span></span><br><span class="line"><span class="comment"> * task_curr() to work out what the state is, if required.  Given that</span></span><br><span class="line"><span class="comment"> * @func can be invoked with a runqueue lock held, it had better be quite</span></span><br><span class="line"><span class="comment"> * lightweight.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	@false if the task slipped out from under the locks.</span></span><br><span class="line"><span class="comment"> *	@true if the task was locked onto a runqueue or is sleeping.</span></span><br><span class="line"><span class="comment"> *		However, @func can override this by returning @false.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">try_invoke_on_locked_down_task</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> (*func)(struct task_struct *t, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line">	raw_spin_lock_irq(&amp;p-&gt;pi_lock);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;on_rq) &#123;</span><br><span class="line">		rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (task_rq(p) == rq)</span><br><span class="line">			ret = func(p, arg);</span><br><span class="line">		rq_unlock(rq, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">		<span class="keyword">case</span> TASK_RUNNING:</span><br><span class="line">		<span class="keyword">case</span> TASK_WAKING:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			smp_rmb(); <span class="comment">// See smp_rmb() comment in try_to_wake_up().</span></span><br><span class="line">			<span class="keyword">if</span> (!p-&gt;on_rq)</span><br><span class="line">				ret = func(p, arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irq(&amp;p-&gt;pi_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_up_process - Wake up a specific process</span></span><br><span class="line"><span class="comment"> * @p: The process to be woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Attempt to wake up the nominated process and move it to the set of runnable</span></span><br><span class="line"><span class="comment"> * processes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the process was woken up, 0 if it was already running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function executes a full memory barrier before accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_process</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(wake_up_process);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_state</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, state, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform scheduler related setup for a newly forked process p.</span></span><br><span class="line"><span class="comment"> * p is forked by current.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __sched_fork() is basic setup used by init_idle() too:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched_fork(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;on_rq			= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;se.on_rq			= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.exec_start		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.sum_exec_runtime		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.prev_sum_exec_runtime	= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.nr_migrations		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.vruntime			= <span class="number">0</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;se.group_node);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	p-&gt;se.cfs_rq			= <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">	<span class="comment">/* Even if schedstat is disabled, there should not be garbage */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;p-&gt;se.statistics, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;se.statistics));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	RB_CLEAR_NODE(&amp;p-&gt;dl.rb_node);</span><br><span class="line">	init_dl_task_timer(&amp;p-&gt;dl);</span><br><span class="line">	init_dl_inactive_task_timer(&amp;p-&gt;dl);</span><br><span class="line">	__dl_clear_params(p);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;rt.run_list);</span><br><span class="line">	p-&gt;rt.timeout		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;rt.time_slice	= sched_rr_timeslice;</span><br><span class="line">	p-&gt;rt.on_rq		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;rt.on_list		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	INIT_HLIST_HEAD(&amp;p-&gt;preempt_notifiers);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	p-&gt;capture_control = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_numa_balancing(clone_flags, p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	p-&gt;wake_entry.u_flags = CSD_TYPE_TTWU;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_STATIC_KEY_FALSE(sched_numa_balancing);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numabalancing_state</span><span class="params">(<span class="keyword">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (enabled)</span><br><span class="line">		static_branch_enable(&amp;sched_numa_balancing);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		static_branch_disable(&amp;sched_numa_balancing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_SYSCTL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_numa_balancing</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> state = static_branch_likely(&amp;sched_numa_balancing);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (write &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	t = *table;</span><br><span class="line">	t.data = &amp;state;</span><br><span class="line">	err = proc_dointvec_minmax(&amp;t, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		set_numabalancing_state(state);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line"></span><br><span class="line">DEFINE_STATIC_KEY_FALSE(sched_schedstats);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __initdata __sched_schedstats = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_schedstats</span><span class="params">(<span class="keyword">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (enabled)</span><br><span class="line">		static_branch_enable(&amp;sched_schedstats);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		static_branch_disable(&amp;sched_schedstats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force_schedstat_enabled</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!schedstat_enabled()) &#123;</span><br><span class="line">		pr_info(<span class="string">"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\n"</span>);</span><br><span class="line">		static_branch_enable(&amp;sched_schedstats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">setup_schedstats</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!str)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This code is called before jump labels have been set up, so we can't</span></span><br><span class="line"><span class="comment">	 * change the static branch directly just yet.  Instead set a temporary</span></span><br><span class="line"><span class="comment">	 * variable so init_schedstats() can do it later.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str, <span class="string">"enable"</span>)) &#123;</span><br><span class="line">		__sched_schedstats = <span class="literal">true</span>;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str, <span class="string">"disable"</span>)) &#123;</span><br><span class="line">		__sched_schedstats = <span class="literal">false</span>;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		pr_warn(<span class="string">"Unable to parse schedstats=\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">"schedstats="</span>, setup_schedstats);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_schedstats</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_schedstats(__sched_schedstats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_SYSCTL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_schedstats</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write, <span class="keyword">void</span> *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> state = static_branch_likely(&amp;sched_schedstats);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (write &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	t = *table;</span><br><span class="line">	t.data = &amp;state;</span><br><span class="line">	err = proc_dointvec_minmax(&amp;t, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		set_schedstats(state);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PROC_SYSCTL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !CONFIG_SCHEDSTATS */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_schedstats</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SCHEDSTATS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fork()/clone()-time setup:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	__sched_fork(clone_flags, p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We mark the process as NEW here. This guarantees that</span></span><br><span class="line"><span class="comment">	 * nobody will actually run it, and a signal or other external</span></span><br><span class="line"><span class="comment">	 * event cannot wake it up and insert it on the runqueue either.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;state = TASK_NEW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we do not leak PI boosting priority to the child.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;prio = current-&gt;normal_prio;</span><br><span class="line"></span><br><span class="line">	uclamp_fork(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Revert to default priority/policy on fork if requested.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p-&gt;sched_reset_on_fork)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) &#123;</span><br><span class="line">			p-&gt;policy = SCHED_NORMAL;</span><br><span class="line">			p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">			p-&gt;rt_priority = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PRIO_TO_NICE(p-&gt;static_prio) &lt; <span class="number">0</span>)</span><br><span class="line">			p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		p-&gt;prio = p-&gt;normal_prio = __normal_prio(p);</span><br><span class="line">		set_load_weight(p, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We don't need the reset flag anymore after the fork. It has</span></span><br><span class="line"><span class="comment">		 * fulfilled its duty:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;sched_reset_on_fork = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(p-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line"></span><br><span class="line">	init_entity_runnable_average(&amp;p-&gt;se);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The child is not yet in the pid-hash so no cgroup attach races,</span></span><br><span class="line"><span class="comment">	 * and the cgroup is pinned to this child due to cgroup_fork()</span></span><br><span class="line"><span class="comment">	 * is ran before sched_fork().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Silence PROVE_RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	rseq_migrate(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're setting the CPU for the first time, we don't migrate,</span></span><br><span class="line"><span class="comment">	 * so use __set_task_cpu().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__set_task_cpu(p, smp_processor_id());</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_fork)</span><br><span class="line">		p-&gt;sched_class-&gt;task_fork(p);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_INFO</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sched_info_on()))</span><br><span class="line">		<span class="built_in">memset</span>(&amp;p-&gt;sched_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;sched_info));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">	p-&gt;on_cpu = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_task_preempt_count(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	plist_node_init(&amp;p-&gt;pushable_tasks, MAX_PRIO);</span><br><span class="line">	RB_CLEAR_NODE(&amp;p-&gt;pushable_dl_tasks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">to_ratio</span><span class="params">(u64 period, u64 runtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (runtime == RUNTIME_INF)</span><br><span class="line">		<span class="keyword">return</span> BW_UNIT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Doing this here saves a lot of checks in all</span></span><br><span class="line"><span class="comment">	 * the calling paths, and returning zero seems</span></span><br><span class="line"><span class="comment">	 * safe for them anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (period == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> div64_u64(runtime &lt;&lt; BW_SHIFT, period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wake_up_new_task - wake up a newly created task for the first time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will do some initial scheduler statistics housekeeping</span></span><br><span class="line"><span class="comment"> * that must be done for every newly created context, then puts the task</span></span><br><span class="line"><span class="comment"> * on the runqueue and wakes it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_new_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);</span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fork balancing, do it here and not earlier because:</span></span><br><span class="line"><span class="comment">	 *  - cpus_ptr can change in the fork path</span></span><br><span class="line"><span class="comment">	 *  - any previously selected CPU might disappear through hotplug</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,</span></span><br><span class="line"><span class="comment">	 * as we're not fully set-up yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;recent_used_cpu = task_cpu(p);</span><br><span class="line">	rseq_migrate(p);</span><br><span class="line">	__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	post_init_entity_util_avg(p);</span><br><span class="line"></span><br><span class="line">	activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">	trace_sched_wakeup_new(p);</span><br><span class="line">	check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Nothing relies on rq-&gt;lock after this, so its fine to</span></span><br><span class="line"><span class="comment">		 * drop it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unpin_lock(rq, &amp;rf);</span><br><span class="line">		p-&gt;sched_class-&gt;task_woken(rq, p);</span><br><span class="line">		rq_repin_lock(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_STATIC_KEY_FALSE</span><span class="params">(preempt_notifier_key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_inc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	static_branch_inc(&amp;preempt_notifier_key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_inc);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_dec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	static_branch_dec(&amp;preempt_notifier_key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_dec);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">"registering preempt_notifier while notifiers disabled\n"</span>);</span><br><span class="line"></span><br><span class="line">	hlist_add_head(&amp;notifier-&gt;link, &amp;current-&gt;preempt_notifiers);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_unregister - no longer interested in preemption notifications</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to unregister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is *not* safe to call from within a preemption notifier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_unregister</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hlist_del(&amp;notifier-&gt;link);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_unregister);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __fire_sched_in_preempt_notifiers(struct task_struct *curr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">		notifier-&gt;ops-&gt;sched_in(notifier, raw_smp_processor_id());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">fire_sched_in_preempt_notifiers</span><span class="params">(struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		__fire_sched_in_preempt_notifiers(curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				   struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">		notifier-&gt;ops-&gt;sched_out(notifier, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				 struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		__fire_sched_out_preempt_notifiers(curr, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_PREEMPT_NOTIFIERS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fire_sched_in_preempt_notifiers</span><span class="params">(struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				 struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PREEMPT_NOTIFIERS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prepare_task</span><span class="params">(struct task_struct *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Claim the task as running, we do this before switching to it</span></span><br><span class="line"><span class="comment">	 * such that any running task will have this set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	next-&gt;on_cpu = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">finish_task</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * After -&gt;on_cpu is cleared, the task can be moved to a different CPU.</span></span><br><span class="line"><span class="comment">	 * We must ensure this doesn't happen until the switch is completely</span></span><br><span class="line"><span class="comment">	 * finished.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In particular, the load of prev-&gt;state in finish_task_switch() must</span></span><br><span class="line"><span class="comment">	 * happen before this.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_store_release(&amp;prev-&gt;on_cpu, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">prepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since the runqueue lock will be released by the next</span></span><br><span class="line"><span class="comment">	 * task (which is an invalid locking op but in the case</span></span><br><span class="line"><span class="comment">	 * of the scheduler it's an obvious special-case), so we</span></span><br><span class="line"><span class="comment">	 * do an early lockdep release here:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_unpin_lock(rq, rf);</span><br><span class="line">	spin_release(&amp;rq-&gt;lock.dep_map, _THIS_IP_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="comment">/* this is a valid case when another task releases the spinlock */</span></span><br><span class="line">	rq-&gt;lock.owner = next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">finish_lock_switch</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are tracking spinlock dependencies then we have to</span></span><br><span class="line"><span class="comment">	 * fix up the runqueue lock - which gets 'carried over' from</span></span><br><span class="line"><span class="comment">	 * prev into current:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_acquire(&amp;rq-&gt;lock.dep_map, <span class="number">0</span>, <span class="number">0</span>, _THIS_IP_);</span><br><span class="line">	raw_spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NOP if the arch has not defined these:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> prepare_arch_switch</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> prepare_arch_switch(next)	do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> finish_arch_post_lock_switch</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> finish_arch_post_lock_switch()	do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_task_switch - prepare to switch tasks</span></span><br><span class="line"><span class="comment"> * @rq: the runqueue preparing to switch</span></span><br><span class="line"><span class="comment"> * @prev: the current task that is being switched out</span></span><br><span class="line"><span class="comment"> * @next: the task we are going to switch to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called with the rq lock held and interrupts off. It must</span></span><br><span class="line"><span class="comment"> * be paired with a subsequent finish_task_switch after the context</span></span><br><span class="line"><span class="comment"> * switch.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * prepare_task_switch sets up locking and calls architecture specific</span></span><br><span class="line"><span class="comment"> * hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">prepare_task_switch(struct rq *rq, struct task_struct *prev,</span><br><span class="line">		    struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	kcov_prepare_switch(prev);</span><br><span class="line">	sched_info_switch(rq, prev, next);</span><br><span class="line">	perf_event_task_sched_out(prev, next);</span><br><span class="line">	rseq_preempt(prev);</span><br><span class="line">	fire_sched_out_preempt_notifiers(prev, next);</span><br><span class="line">	prepare_task(next);</span><br><span class="line">	prepare_arch_switch(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * finish_task_switch - clean up after a task-switch</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * finish_task_switch must be called after the context switch, paired</span></span><br><span class="line"><span class="comment"> * with a prepare_task_switch call before the context switch.</span></span><br><span class="line"><span class="comment"> * finish_task_switch will reconcile locking set up by prepare_task_switch,</span></span><br><span class="line"><span class="comment"> * and do any other architecture-specific cleanup actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we may have delayed dropping an mm in context_switch(). If</span></span><br><span class="line"><span class="comment"> * so, we finish that here outside of the runqueue lock. (Doing it</span></span><br><span class="line"><span class="comment"> * with the lock held can cause deadlocks; see schedule() for</span></span><br><span class="line"><span class="comment"> * details.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The context switch have flipped the stack from under us and restored the</span></span><br><span class="line"><span class="comment"> * local variables which were saved when this task called schedule() in the</span></span><br><span class="line"><span class="comment"> * past. prev == current is still correct but we need to recalculate this_rq</span></span><br><span class="line"><span class="comment"> * because prev may have moved to another CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct rq *<span class="title">finish_task_switch</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">rq</span>-&gt;<span class="title">prev_mm</span>;</span></span><br><span class="line">	<span class="keyword">long</span> prev_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The previous task will have left us with a preempt_count of 2</span></span><br><span class="line"><span class="comment">	 * because it left us after:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	schedule()</span></span><br><span class="line"><span class="comment">	 *	  preempt_disable();			// 1</span></span><br><span class="line"><span class="comment">	 *	  __schedule()</span></span><br><span class="line"><span class="comment">	 *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, see FORK_PREEMPT_COUNT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ONCE(preempt_count() != <span class="number">2</span>*PREEMPT_DISABLE_OFFSET,</span><br><span class="line">		      <span class="string">"corrupted preempt_count: %s/%d/0x%x\n"</span>,</span><br><span class="line">		      current-&gt;comm, current-&gt;pid, preempt_count()))</span><br><span class="line">		preempt_count_set(FORK_PREEMPT_COUNT);</span><br><span class="line"></span><br><span class="line">	rq-&gt;prev_mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A task struct has one reference for the use as "current".</span></span><br><span class="line"><span class="comment">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span></span><br><span class="line"><span class="comment">	 * schedule one last time. The schedule call will never return, and</span></span><br><span class="line"><span class="comment">	 * the scheduled task must drop that reference.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in</span></span><br><span class="line"><span class="comment">	 * finish_task), otherwise a concurrent wakeup can get prev</span></span><br><span class="line"><span class="comment">	 * running on another CPU and we could rave with its RUNNING -&gt; DEAD</span></span><br><span class="line"><span class="comment">	 * transition, resulting in a double drop.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev_state = prev-&gt;state;</span><br><span class="line">	vtime_task_switch(prev);</span><br><span class="line">	perf_event_task_sched_in(prev, current);</span><br><span class="line">	finish_task(prev);</span><br><span class="line">	finish_lock_switch(rq);</span><br><span class="line">	finish_arch_post_lock_switch();</span><br><span class="line">	kcov_finish_switch(current);</span><br><span class="line"></span><br><span class="line">	fire_sched_in_preempt_notifiers(current);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When switching through a kernel thread, the loop in</span></span><br><span class="line"><span class="comment">	 * membarrier_&#123;private,global&#125;_expedited() may have observed that</span></span><br><span class="line"><span class="comment">	 * kernel thread and not issued an IPI. It is therefore possible to</span></span><br><span class="line"><span class="comment">	 * schedule between user-&gt;kernel-&gt;user threads without passing though</span></span><br><span class="line"><span class="comment">	 * switch_mm(). Membarrier requires a barrier after storing to</span></span><br><span class="line"><span class="comment">	 * rq-&gt;curr, before returning to userspace, so provide them here:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - a full memory barrier for &#123;PRIVATE,GLOBAL&#125;_EXPEDITED, implicitly</span></span><br><span class="line"><span class="comment">	 *   provided by mmdrop(),</span></span><br><span class="line"><span class="comment">	 * - a sync_core for SYNC_CORE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		membarrier_mm_sync_core_before_usermode(mm);</span><br><span class="line">		mmdrop(mm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(prev_state == TASK_DEAD)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;sched_class-&gt;task_dead)</span><br><span class="line">			prev-&gt;sched_class-&gt;task_dead(prev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Remove function-return probe instances associated with this</span></span><br><span class="line"><span class="comment">		 * task and put them back on the free list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kprobe_flush_task(prev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Task is done with its stack. */</span></span><br><span class="line">		put_task_stack(prev);</span><br><span class="line"></span><br><span class="line">		put_task_struct_rcu_user(prev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tick_nohz_task_switch();</span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rq-&gt;lock is NOT held, but preemption is disabled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __balance_callback(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(struct rq *rq);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span><br><span class="line">	head = rq-&gt;balance_callback;</span><br><span class="line">	rq-&gt;balance_callback = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		func = (<span class="keyword">void</span> (*)(struct rq *))head-&gt;func;</span><br><span class="line">		next = head-&gt;next;</span><br><span class="line">		head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		head = next;</span><br><span class="line"></span><br><span class="line">		func(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">balance_callback</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(rq-&gt;balance_callback))</span><br><span class="line">		__balance_callback(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">balance_callback</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_tail - first thing a freshly forked thread must call.</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">schedule_tail</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * New tasks start with FORK_PREEMPT_COUNT, see there and</span></span><br><span class="line"><span class="comment">	 * finish_task_switch() for details.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count</span></span><br><span class="line"><span class="comment">	 * and the preempt_enable() will end up enabling preemption (on</span></span><br><span class="line"><span class="comment">	 * PREEMPT_COUNT kernels).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	rq = finish_task_switch(prev);</span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;set_child_tid)</span><br><span class="line">		put_user(task_pid_vnr(current), current-&gt;set_child_tid);</span><br><span class="line"></span><br><span class="line">	calculate_sigpending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context_switch - switch to the new MM and the new thread's register state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *</span></span><br><span class="line"><span class="class"><span class="title">context_switch</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>,</span></span><br><span class="line"><span class="class">	       <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	prepare_task_switch(rq, prev, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For paravirt, this is coupled with an exit in switch_to to</span></span><br><span class="line"><span class="comment">	 * combine the page table reload and the switch backend into</span></span><br><span class="line"><span class="comment">	 * one hypercall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	arch_start_context_switch(prev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kernel -&gt; kernel   lazy + transfer active</span></span><br><span class="line"><span class="comment">	 *   user -&gt; kernel   lazy + mmgrab() active</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * kernel -&gt;   user   switch + mmdrop() active</span></span><br><span class="line"><span class="comment">	 *   user -&gt;   user   switch</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!next-&gt;mm) &#123;                                <span class="comment">// to kernel</span></span><br><span class="line">		enter_lazy_tlb(prev-&gt;active_mm, next);</span><br><span class="line"></span><br><span class="line">		next-&gt;active_mm = prev-&gt;active_mm;</span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;mm)                           <span class="comment">// from user</span></span><br><span class="line">			mmgrab(prev-&gt;active_mm);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;                                        <span class="comment">// to user</span></span><br><span class="line">		membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * sys_membarrier() requires an smp_mb() between setting</span></span><br><span class="line"><span class="comment">		 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The below provides this either through switch_mm(), or in</span></span><br><span class="line"><span class="comment">		 * case 'prev-&gt;active_mm == next-&gt;mm' through</span></span><br><span class="line"><span class="comment">		 * finish_task_switch()'s mmdrop().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!prev-&gt;mm) &#123;                        <span class="comment">// from kernel</span></span><br><span class="line">			<span class="comment">/* will mmdrop() in finish_task_switch(). */</span></span><br><span class="line">			rq-&gt;prev_mm = prev-&gt;active_mm;</span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line"></span><br><span class="line">	prepare_lock_switch(rq, next, rf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">	switch_to(prev, next, prev);</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nr_running and nr_context_switches:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * externally visible scheduler statistics: current number of runnable</span></span><br><span class="line"><span class="comment"> * threads, total number of context switches performed since bootup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_online_cpu(i)</span><br><span class="line">		sum += cpu_rq(i)-&gt;nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if only the current task is running on the CPU.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Caution: this function does not check that the caller has disabled</span></span><br><span class="line"><span class="comment"> * preemption, thus the result might have a time-of-check-to-time-of-use</span></span><br><span class="line"><span class="comment"> * race.  The caller is responsible to use it correctly, for example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - from a non-preemptible section (of course)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - from a thread that is bound to a single CPU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - in a loop with very short iterations (e.g. a polling loop)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">single_task_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> raw_rq()-&gt;nr_running == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_task_running);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">nr_context_switches</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		sum += cpu_rq(i)-&gt;nr_switches;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Consumers of these two interfaces, like for example the cpuidle menu</span></span><br><span class="line"><span class="comment"> * governor, are using nonsensical data. Preferring shallow idle state selection</span></span><br><span class="line"><span class="comment"> * for a CPU that has IO-wait which might not even end up running the task when</span></span><br><span class="line"><span class="comment"> * it does become runnable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_iowait_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> atomic_read(&amp;cpu_rq(cpu)-&gt;nr_iowait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO-wait accounting, and how its mostly bollocks (on SMP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The idea behind IO-wait account is to account the idle time that we could</span></span><br><span class="line"><span class="comment"> * have spend running if it were not for IO. That is, if we were to improve the</span></span><br><span class="line"><span class="comment"> * storage performance, we'd have a proportional reduction in IO-wait time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This all works nicely on UP, where, when a task blocks on IO, we account</span></span><br><span class="line"><span class="comment"> * idle time as IO-wait, because if the storage were faster, it could've been</span></span><br><span class="line"><span class="comment"> * running and we'd not be idle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This has been extended to SMP, by doing the same for each CPU. This however</span></span><br><span class="line"><span class="comment"> * is broken.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Imagine for instance the case where two tasks block on one CPU, only the one</span></span><br><span class="line"><span class="comment"> * CPU will have IO-wait accounted, while the other has regular idle. Even</span></span><br><span class="line"><span class="comment"> * though, if the storage were faster, both could've ran at the same time,</span></span><br><span class="line"><span class="comment"> * utilising both CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This means, that when looking globally, the current IO-wait accounting on</span></span><br><span class="line"><span class="comment"> * SMP is a lower bound, by reason of under accounting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Worse, since the numbers are provided per CPU, they are sometimes</span></span><br><span class="line"><span class="comment"> * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly</span></span><br><span class="line"><span class="comment"> * associated with any one particular CPU, it can wake to another CPU than it</span></span><br><span class="line"><span class="comment"> * blocked on. This means the per CPU IO-wait number is meaningless.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Task CPU affinities can make all that even more 'interesting'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_iowait</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		sum += nr_iowait_cpu(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_exec - execve() is a valuable balancing opportunity, because at</span></span><br><span class="line"><span class="comment"> * this point the task has the smallest effective memory and cache footprint.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_exec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	dest_cpu = p-&gt;sched_class-&gt;select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dest_cpu == smp_processor_id())</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(cpu_active(dest_cpu))) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, dest_cpu &#125;;</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">		stop_one_cpu(task_cpu(p), migration_cpu_stop, &amp;arg);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(struct kernel_stat, kstat);</span><br><span class="line">DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);</span><br><span class="line"></span><br><span class="line">EXPORT_PER_CPU_SYMBOL(kstat);</span><br><span class="line">EXPORT_PER_CPU_SYMBOL(kernel_cpustat);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The function fair_sched_class.update_curr accesses the struct curr</span></span><br><span class="line"><span class="comment"> * and its field curr-&gt;exec_start; when called from task_sched_runtime(),</span></span><br><span class="line"><span class="comment"> * we observe a high rate of cache misses in practice.</span></span><br><span class="line"><span class="comment"> * Prefetching this data results in improved performance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prefetch_curr_exec_start</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = (&amp;<span class="title">p</span>-&gt;<span class="title">se</span>)-&gt;<span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = (&amp;<span class="title">task_rq</span>(<span class="title">p</span>)-&gt;<span class="title">cfs</span>)-&gt;<span class="title">curr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	prefetch(curr);</span><br><span class="line">	prefetch(&amp;curr-&gt;exec_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return accounted runtime for the task.</span></span><br><span class="line"><span class="comment"> * In case the task is currently running, return the runtime plus current's</span></span><br><span class="line"><span class="comment"> * pending runtime that have not been accounted yet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">task_sched_runtime</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	u64 ns;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_64BIT) &amp;&amp; defined(CONFIG_SMP)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 64-bit doesn't need locks to atomically read a 64-bit value.</span></span><br><span class="line"><span class="comment">	 * So we have a optimization chance when the task's delta_exec is 0.</span></span><br><span class="line"><span class="comment">	 * Reading -&gt;on_cpu is racy, but this is ok.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If we race with it leaving CPU, we'll take a lock. So we're correct.</span></span><br><span class="line"><span class="comment">	 * If we race with it entering CPU, unaccounted time is 0. This is</span></span><br><span class="line"><span class="comment">	 * indistinguishable from the read occurring a few cycles earlier.</span></span><br><span class="line"><span class="comment">	 * If we see -&gt;on_cpu without -&gt;on_rq, the task is leaving, and has</span></span><br><span class="line"><span class="comment">	 * been accounted, so we're correct here as well.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;on_cpu || !task_on_rq_queued(p))</span><br><span class="line">		<span class="keyword">return</span> p-&gt;se.sum_exec_runtime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be -&gt;curr _and_ -&gt;on_rq.  If dequeued, we would</span></span><br><span class="line"><span class="comment">	 * project cycles that may never be accounted to this</span></span><br><span class="line"><span class="comment">	 * thread, breaking clock_gettime().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_current(rq, p) &amp;&amp; task_on_rq_queued(p)) &#123;</span><br><span class="line">		prefetch_curr_exec_start(p);</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line">		p-&gt;sched_class-&gt;update_curr(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	ns = p-&gt;se.sum_exec_runtime;</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">unsigned</span> <span class="keyword">long</span>, thermal_pressure);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_set_thermal_pressure</span><span class="params">(struct cpumask *cpus,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> th_pressure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(cpu, cpus)</span><br><span class="line">		WRITE_ONCE(per_cpu(thermal_pressure, cpu), th_pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function gets called by the timer code, with HZ frequency.</span></span><br><span class="line"><span class="comment"> * We call it with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler_tick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> thermal_pressure;</span><br><span class="line"></span><br><span class="line">	arch_scale_freq_tick();</span><br><span class="line">	sched_clock_tick();</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	thermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));</span><br><span class="line">	update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure);</span><br><span class="line">	curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line">	calc_global_load_tick(rq);</span><br><span class="line">	psi_task_tick(rq);</span><br><span class="line"></span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	perf_event_task_tick();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	trigger_load_balance(rq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;</span><br><span class="line">	<span class="keyword">atomic_t</span>		state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Values for -&gt;state, see diagram below. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_OFFLINE	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_OFFLINING	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_RUNNING	2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * State diagram for -&gt;state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          TICK_SCHED_REMOTE_OFFLINE</span></span><br><span class="line"><span class="comment"> *                    |   ^</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    |   | sched_tick_remote()</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    +--TICK_SCHED_REMOTE_OFFLINING</span></span><br><span class="line"><span class="comment"> *                    |   ^</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> * sched_tick_start() |   | sched_tick_stop()</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    V   |</span></span><br><span class="line"><span class="comment"> *          TICK_SCHED_REMOTE_RUNNING</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()</span></span><br><span class="line"><span class="comment"> * and sched_tick_start() are happy to leave the state in RUNNING.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> __<span class="title">percpu</span> *<span class="title">tick_work_cpu</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_remote</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = <span class="title">to_delayed_work</span>(<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span> = <span class="title">container_of</span>(<span class="title">dwork</span>, <span class="title">struct</span> <span class="title">tick_work</span>, <span class="title">work</span>);</span></span><br><span class="line">	<span class="keyword">int</span> cpu = twork-&gt;cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	u64 delta;</span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Handle the tick only if it appears the remote CPU is running in full</span></span><br><span class="line"><span class="comment">	 * dynticks mode. The check is racy by nature, but missing a tick or</span></span><br><span class="line"><span class="comment">	 * having one too much is no big deal because the scheduler tick updates</span></span><br><span class="line"><span class="comment">	 * statistics and checks timeslices in a time-independent way, regardless</span></span><br><span class="line"><span class="comment">	 * of when exactly it is running.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!tick_nohz_tick_stopped_cpu(cpu))</span><br><span class="line">		<span class="keyword">goto</span> out_requeue;</span><br><span class="line"></span><br><span class="line">	rq_lock_irq(rq, &amp;rf);</span><br><span class="line">	curr = rq-&gt;curr;</span><br><span class="line">	<span class="keyword">if</span> (cpu_is_offline(cpu))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_idle_task(curr)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make sure the next tick runs within a reasonable</span></span><br><span class="line"><span class="comment">		 * amount of time.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		delta = rq_clock_task(rq) - curr-&gt;se.exec_start;</span><br><span class="line">		WARN_ON_ONCE(delta &gt; (u64)NSEC_PER_SEC * <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	calc_load_nohz_remote(rq);</span><br><span class="line">out_unlock:</span><br><span class="line">	rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">out_requeue:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Run the remote tick once per second (1Hz). This arbitrary</span></span><br><span class="line"><span class="comment">	 * frequency is large enough to avoid overload but short enough</span></span><br><span class="line"><span class="comment">	 * to keep scheduler internal stats reasonably up to date.  But</span></span><br><span class="line"><span class="comment">	 * first update state to reflect hotplug activity if required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	os = atomic_fetch_add_unless(&amp;twork-&gt;state, <span class="number">-1</span>, TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_OFFLINE);</span><br><span class="line">	<span class="keyword">if</span> (os == TICK_SCHED_REMOTE_RUNNING)</span><br><span class="line">		queue_delayed_work(system_unbound_wq, dwork, HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_start</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TICK))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!tick_work_cpu);</span><br><span class="line"></span><br><span class="line">	twork = per_cpu_ptr(tick_work_cpu, cpu);</span><br><span class="line">	os = atomic_xchg(&amp;twork-&gt;state, TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	<span class="keyword">if</span> (os == TICK_SCHED_REMOTE_OFFLINE) &#123;</span><br><span class="line">		twork-&gt;cpu = cpu;</span><br><span class="line">		INIT_DELAYED_WORK(&amp;twork-&gt;work, sched_tick_remote);</span><br><span class="line">		queue_delayed_work(system_unbound_wq, &amp;twork-&gt;work, HZ);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_stop</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span>;</span></span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TICK))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!tick_work_cpu);</span><br><span class="line"></span><br><span class="line">	twork = per_cpu_ptr(tick_work_cpu, cpu);</span><br><span class="line">	<span class="comment">/* There cannot be competing actions, but don't rely on stop-machine. */</span></span><br><span class="line">	os = atomic_xchg(&amp;twork-&gt;state, TICK_SCHED_REMOTE_OFFLINING);</span><br><span class="line">	WARN_ON_ONCE(os != TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	<span class="comment">/* Don't cancel, as this would mess up the state machine. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_HOTPLUG_CPU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">sched_tick_offload_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tick_work_cpu = alloc_percpu(struct tick_work);</span><br><span class="line">	BUG_ON(!tick_work_cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_NO_HZ_FULL */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_tick_start</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_tick_stop</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PREEMPTION) &amp;&amp; (defined(CONFIG_DEBUG_PREEMPT) || \</span></span><br><span class="line">				defined(CONFIG_TRACE_PREEMPT_TOGGLE))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the value passed in is equal to the current preempt count</span></span><br><span class="line"><span class="comment"> * then we just disabled preemption. Start timing the latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_start</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preempt_count() == val) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> ip = get_lock_parent_ip();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">		current-&gt;preempt_disable_ip = ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		trace_preempt_off(CALLER_ADDR0, ip);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_count_add</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Underflow?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON((preempt_count() &lt; <span class="number">0</span>)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__preempt_count_add(val);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Spinlock count overflowing soon?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DEBUG_LOCKS_WARN_ON((preempt_count() &amp; PREEMPT_MASK) &gt;=</span><br><span class="line">				PREEMPT_MASK - <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	preempt_latency_start(val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(preempt_count_add);</span><br><span class="line">NOKPROBE_SYMBOL(preempt_count_add);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the value passed in equals to the current preempt count</span></span><br><span class="line"><span class="comment"> * then we just enabled preemption. Stop timing the latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_stop</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preempt_count() == val)</span><br><span class="line">		trace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_count_sub</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Underflow?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON(val &gt; preempt_count()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Is the spinlock portion underflowing?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON((val &lt; PREEMPT_MASK) &amp;&amp;</span><br><span class="line">			!(preempt_count() &amp; PREEMPT_MASK)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	preempt_latency_stop(val);</span><br><span class="line">	__preempt_count_sub(val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(preempt_count_sub);</span><br><span class="line">NOKPROBE_SYMBOL(preempt_count_sub);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_start</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_stop</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_preempt_disable_ip</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Print scheduling while atomic bug:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __schedule_bug(struct task_struct *prev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Save this before calling printk(), since that will clobber it */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip = get_preempt_disable_ip(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oops_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR <span class="string">"BUG: scheduling while atomic: %s/%d/0x%08x\n"</span>,</span><br><span class="line">		prev-&gt;comm, prev-&gt;pid, preempt_count());</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(prev);</span><br><span class="line">	print_modules();</span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		print_irqtrace_events(prev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_PREEMPT)</span><br><span class="line">	    &amp;&amp; in_atomic_preempt_off()) &#123;</span><br><span class="line">		pr_err(<span class="string">"Preemption disabled at:"</span>);</span><br><span class="line">		print_ip_sym(KERN_ERR, preempt_disable_ip);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (panic_on_warn)</span><br><span class="line">		panic(<span class="string">"scheduling while atomic\n"</span>);</span><br><span class="line"></span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Various schedule()-time debugging checks and statistics:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">schedule_debug</span><span class="params">(struct task_struct *prev, <span class="keyword">bool</span> preempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_STACK_END_CHECK</span></span><br><span class="line">	<span class="keyword">if</span> (task_stack_end_corrupted(prev))</span><br><span class="line">		panic(<span class="string">"corrupted stack end detected inside scheduler\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_scs_end_corrupted(prev))</span><br><span class="line">		panic(<span class="string">"corrupted shadow stack detected inside scheduler\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state &amp;&amp; prev-&gt;non_block_count) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"BUG: scheduling in a non-blocking section: %s/%d/%i\n"</span>,</span><br><span class="line">			prev-&gt;comm, prev-&gt;pid, prev-&gt;non_block_count);</span><br><span class="line">		dump_stack();</span><br><span class="line">		add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic_preempt_off())) &#123;</span><br><span class="line">		__schedule_bug(prev);</span><br><span class="line">		preempt_count_set(PREEMPT_DISABLED);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_sleep_check();</span><br><span class="line"></span><br><span class="line">	profile_hit(SCHED_PROFILING, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	schedstat_inc(this_rq()-&gt;sched_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_prev_task_balance</span><span class="params">(struct rq *rq, struct task_struct *prev,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must do the balancing pass before put_prev_task(), such</span></span><br><span class="line"><span class="comment">	 * that when we release the rq-&gt;lock the task is in the same</span></span><br><span class="line"><span class="comment">	 * state as before we took rq-&gt;lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We can terminate the balance pass as soon as we know there is</span></span><br><span class="line"><span class="comment">	 * a runnable task of @class priority or higher.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class) &#123;</span><br><span class="line">		<span class="keyword">if</span> (class-&gt;balance(rq, prev, rf))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	put_prev_task(rq, prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">pick_next_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment">	 * call that function directly, but only if the @prev task wasn't of a</span></span><br><span class="line"><span class="comment">	 * higher scheduling class, because otherwise those loose the</span></span><br><span class="line"><span class="comment">	 * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">		    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line"></span><br><span class="line">		p = pick_next_task_fair(rq, prev, rf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			put_prev_task(rq, prev);</span><br><span class="line">			p = pick_next_task_idle(rq);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	put_prev_task_balance(rq, prev, rf);</span><br><span class="line"></span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">	BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __schedule() is the main scheduler function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The main means of driving the scheduler and thus entering this function are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return</span></span><br><span class="line"><span class="comment"> *      paths. For example, see arch/x86/entry_64.S.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      To drive preemption between tasks, the scheduler sets the flag in timer</span></span><br><span class="line"><span class="comment"> *      interrupt handler scheduler_tick().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   3. Wakeups don't really cause entry into schedule(). They add a</span></span><br><span class="line"><span class="comment"> *      task to the run-queue and that's it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Now, if the new task added to the run-queue preempts the current</span></span><br><span class="line"><span class="comment"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets</span></span><br><span class="line"><span class="comment"> *      called on the nearest possible occasion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is preemptible (CONFIG_PREEMPTION=y):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in syscall or exception context, at the next outmost</span></span><br><span class="line"><span class="comment"> *           preempt_enable(). (this might be as soon as the wake_up()'s</span></span><br><span class="line"><span class="comment"> *           spin_unlock()!)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in IRQ context, return from interrupt-handler to</span></span><br><span class="line"><span class="comment"> *           preemptible context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is not preemptible (CONFIG_PREEMPTION is not set)</span></span><br><span class="line"><span class="comment"> *         then at the next:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          - cond_resched() call</span></span><br><span class="line"><span class="comment"> *          - explicit schedule() call</span></span><br><span class="line"><span class="comment"> *          - return from syscall or exception to user-space</span></span><br><span class="line"><span class="comment"> *          - return from interrupt-handler to user-space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: must be called with preemption disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace __schedule(<span class="keyword">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	schedule_debug(prev, preempt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	rcu_note_context_switch(preempt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure that signal_pending_state()-&gt;signal_pending() below</span></span><br><span class="line"><span class="comment">	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">	 * done by the caller to avoid the race with signal_wake_up():</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __set_current_state(@state)		signal_wake_up()</span></span><br><span class="line"><span class="comment">	 * schedule()				  set_tsk_thread_flag(p, TIF_SIGPENDING)</span></span><br><span class="line"><span class="comment">	 *					  wake_up_state(p, state)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			    LOCK p-&gt;pi_state</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock()		    smp_mb__after_spinlock()</span></span><br><span class="line"><span class="comment">	 *     if (signal_pending_state())	    if (p-&gt;state &amp; @state)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, the membarrier system call requires a full memory barrier</span></span><br><span class="line"><span class="comment">	 * after coming from user-space, before storing to rq-&gt;curr.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">	rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must load prev-&gt;state once (task_struct::state is volatile), such</span></span><br><span class="line"><span class="comment">	 * that:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - we form a control dependency vs deactivate_task() below.</span></span><br><span class="line"><span class="comment">	 *  - ptrace_&#123;,un&#125;freeze_traced() can change -&gt;state underneath us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev_state = prev-&gt;state;</span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev_state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(prev_state, prev)) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			prev-&gt;sched_contributes_to_load =</span><br><span class="line">				(prev_state &amp; TASK_UNINTERRUPTIBLE) &amp;&amp;</span><br><span class="line">				!(prev_state &amp; TASK_NOLOAD) &amp;&amp;</span><br><span class="line">				!(prev-&gt;flags &amp; PF_FROZEN);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;sched_contributes_to_load)</span><br><span class="line">				rq-&gt;nr_uninterruptible++;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * __schedule()			ttwu()</span></span><br><span class="line"><span class="comment">			 *   prev_state = prev-&gt;state;    if (p-&gt;on_rq &amp;&amp; ...)</span></span><br><span class="line"><span class="comment">			 *   if (prev_state)		    goto out;</span></span><br><span class="line"><span class="comment">			 *     p-&gt;on_rq = 0;		  smp_acquire__after_ctrl_dep();</span></span><br><span class="line"><span class="comment">			 *				  p-&gt;state = TASK_WAKING</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Where __schedule() and ttwu() have matching control dependencies.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * After this, schedule() must not care about p-&gt;state any more.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">				atomic_inc(&amp;rq-&gt;nr_iowait);</span><br><span class="line">				delayacct_blkio_start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * RCU users of rcu_dereference(rq-&gt;curr) may not see</span></span><br><span class="line"><span class="comment">		 * changes to task_struct made by pick_next_task().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RCU_INIT_POINTER(rq-&gt;curr, next);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The membarrier system call requires each architecture</span></span><br><span class="line"><span class="comment">		 * to have a full memory barrier after updating</span></span><br><span class="line"><span class="comment">		 * rq-&gt;curr, before returning to user-space.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Here are the schemes providing that barrier on the</span></span><br><span class="line"><span class="comment">		 * various architectures:</span></span><br><span class="line"><span class="comment">		 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.</span></span><br><span class="line"><span class="comment">		 *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.</span></span><br><span class="line"><span class="comment">		 * - finish_lock_switch() for weakly-ordered</span></span><br><span class="line"><span class="comment">		 *   architectures where spin_unlock is a full barrier,</span></span><br><span class="line"><span class="comment">		 * - switch_to() for arm64 (weakly-ordered, spin_unlock</span></span><br><span class="line"><span class="comment">		 *   is a RELEASE barrier),</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		++*switch_count;</span><br><span class="line"></span><br><span class="line">		psi_sched_switch(prev, next, !task_on_rq_queued(prev));</span><br><span class="line"></span><br><span class="line">		trace_sched_switch(preempt, prev, next);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">do_task_dead</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Causes final put_task_struct in finish_task_switch(): */</span></span><br><span class="line">	set_special_state(TASK_DEAD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell freezer to ignore us: */</span></span><br><span class="line">	current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line"></span><br><span class="line">	__schedule(<span class="literal">false</span>);</span><br><span class="line">	BUG();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid "noreturn function does return" - but don't continue if BUG() is a NOP: */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		cpu_relax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_submit_work</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tsk-&gt;state)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If a worker went to sleep, notify and ask workqueue whether</span></span><br><span class="line"><span class="comment">	 * it wants to wake up a task to maintain concurrency.</span></span><br><span class="line"><span class="comment">	 * As this function is called inside the schedule() context,</span></span><br><span class="line"><span class="comment">	 * we disable preemption to avoid it calling schedule() again</span></span><br><span class="line"><span class="comment">	 * in the possible wakeup of a kworker and because wq_worker_sleeping()</span></span><br><span class="line"><span class="comment">	 * requires it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;flags &amp; (PF_WQ_WORKER | PF_IO_WORKER)) &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">			wq_worker_sleeping(tsk);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_wq_worker_sleeping(tsk);</span><br><span class="line">		preempt_enable_no_resched();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk_is_pi_blocked(tsk))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are going to sleep and we have plugged IO queued,</span></span><br><span class="line"><span class="comment">	 * make sure to submit it to avoid deadlocks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blk_needs_flush_plug(tsk))</span><br><span class="line">		blk_schedule_flush_plug(tsk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_update_worker</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;flags &amp; (PF_WQ_WORKER | PF_IO_WORKER)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">			wq_worker_running(tsk);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_wq_worker_running(tsk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">	sched_submit_work(tsk);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">	sched_update_worker(tsk);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * synchronize_rcu_tasks() makes sure that no task is stuck in preempted</span></span><br><span class="line"><span class="comment"> * state (have scheduled out non-voluntarily) by making sure that all</span></span><br><span class="line"><span class="comment"> * tasks have either left the run queue or have gone into user space.</span></span><br><span class="line"><span class="comment"> * As idle tasks do not do either, they must not ever be preempted</span></span><br><span class="line"><span class="comment"> * (schedule out non-voluntarily).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * schedule_idle() is similar to schedule_preempt_disable() except that it</span></span><br><span class="line"><span class="comment"> * never enables preemption because it does not call sched_submit_work().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">schedule_idle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As this skips calling sched_submit_work(), which the idle task does</span></span><br><span class="line"><span class="comment">	 * regardless because that function is a nop when the task is in a</span></span><br><span class="line"><span class="comment">	 * TASK_RUNNING state, make sure this isn't used someplace that the</span></span><br><span class="line"><span class="comment">	 * current task can be in any other state. Note, idle is always in the</span></span><br><span class="line"><span class="comment">	 * TASK_RUNNING state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(current-&gt;state);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONTEXT_TRACKING</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule_user</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we come here after a random call to set_need_resched(),</span></span><br><span class="line"><span class="comment">	 * or we have been woken up remotely but the IPI has not yet arrived,</span></span><br><span class="line"><span class="comment">	 * we haven't yet exited the RCU idle mode. Do it here manually until</span></span><br><span class="line"><span class="comment">	 * we find a better solution.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NB: There are buggy callers of this function.  Ideally we</span></span><br><span class="line"><span class="comment">	 * should warn if prev_state != CONTEXT_USER, but that will trigger</span></span><br><span class="line"><span class="comment">	 * too frequently to make sense yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_state = exception_enter();</span><br><span class="line">	schedule();</span><br><span class="line">	exception_exit(prev_state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_preempt_disabled - called with preemption disabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns with preemption disabled. Note: preempt_count must be 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">schedule_preempt_disabled</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	schedule();</span><br><span class="line">	preempt_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule_common</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because the function tracer can trace preempt_count_sub()</span></span><br><span class="line"><span class="comment">		 * and it also uses preempt_enable/disable_notrace(), if</span></span><br><span class="line"><span class="comment">		 * NEED_RESCHED is set, the preempt_enable_notrace() called</span></span><br><span class="line"><span class="comment">		 * by the function tracer will call this function again and</span></span><br><span class="line"><span class="comment">		 * cause infinite recursion.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Preemption must be disabled here before the function</span></span><br><span class="line"><span class="comment">		 * tracer can trace. Break up preempt_disable() into two</span></span><br><span class="line"><span class="comment">		 * calls. One to disable preemption without fear of being</span></span><br><span class="line"><span class="comment">		 * traced. The other to still record the preemption latency,</span></span><br><span class="line"><span class="comment">		 * which can also be traced by the function tracer.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		preempt_disable_notrace();</span><br><span class="line">		preempt_latency_start(<span class="number">1</span>);</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		preempt_latency_stop(<span class="number">1</span>);</span><br><span class="line">		preempt_enable_no_resched_notrace();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment">		 * between schedule and now.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPTION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the entry point to schedule() from in-kernel preemption</span></span><br><span class="line"><span class="comment"> * off of preempt_enable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is a non-zero preempt_count or interrupts are disabled,</span></span><br><span class="line"><span class="comment">	 * we do not want to preempt the current task. Just return..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	preempt_schedule_common();</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(preempt_schedule);</span><br><span class="line">EXPORT_SYMBOL(preempt_schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_schedule_notrace - preempt_schedule called by tracing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The tracing infrastructure uses preempt_enable_notrace to prevent</span></span><br><span class="line"><span class="comment"> * recursion and tracing preempt enabling caused by the tracing</span></span><br><span class="line"><span class="comment"> * infrastructure itself. But as tracing can happen in areas coming</span></span><br><span class="line"><span class="comment"> * from userspace or just about to enter userspace, a preempt enable</span></span><br><span class="line"><span class="comment"> * can occur before user_exit() is called. This will cause the scheduler</span></span><br><span class="line"><span class="comment"> * to be called when the system is still in usermode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To prevent this, the preempt_enable_notrace will use this function</span></span><br><span class="line"><span class="comment"> * instead of preempt_schedule() to exit user context if needed before</span></span><br><span class="line"><span class="comment"> * calling the scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule_notrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because the function tracer can trace preempt_count_sub()</span></span><br><span class="line"><span class="comment">		 * and it also uses preempt_enable/disable_notrace(), if</span></span><br><span class="line"><span class="comment">		 * NEED_RESCHED is set, the preempt_enable_notrace() called</span></span><br><span class="line"><span class="comment">		 * by the function tracer will call this function again and</span></span><br><span class="line"><span class="comment">		 * cause infinite recursion.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Preemption must be disabled here before the function</span></span><br><span class="line"><span class="comment">		 * tracer can trace. Break up preempt_disable() into two</span></span><br><span class="line"><span class="comment">		 * calls. One to disable preemption without fear of being</span></span><br><span class="line"><span class="comment">		 * traced. The other to still record the preemption latency,</span></span><br><span class="line"><span class="comment">		 * which can also be traced by the function tracer.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		preempt_disable_notrace();</span><br><span class="line">		preempt_latency_start(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Needs preempt disabled in case user_exit() is traced</span></span><br><span class="line"><span class="comment">		 * and the tracer calls preempt_enable_notrace() causing</span></span><br><span class="line"><span class="comment">		 * an infinite recursion.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		prev_ctx = exception_enter();</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		exception_exit(prev_ctx);</span><br><span class="line"></span><br><span class="line">		preempt_latency_stop(<span class="number">1</span>);</span><br><span class="line">		preempt_enable_no_resched_notrace();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_schedule_notrace);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PREEMPTION */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the entry point to schedule() from kernel preemption</span></span><br><span class="line"><span class="comment"> * off of irq context.</span></span><br><span class="line"><span class="comment"> * Note, that this is called and return with irqs disabled. This will</span></span><br><span class="line"><span class="comment"> * protect us against recursive calling from irq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">preempt_schedule_irq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Catch callers which need to be fixed */</span></span><br><span class="line">	BUG_ON(preempt_count() || !irqs_disabled());</span><br><span class="line"></span><br><span class="line">	prev_state = exception_enter();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		local_irq_disable();</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line"></span><br><span class="line">	exception_exit(prev_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *curr, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) &amp;&amp; wake_flags &amp; ~WF_SYNC);</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(curr-&gt;<span class="keyword">private</span>, mode, wake_flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(default_wake_function);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __rt_effective_prio(struct task_struct *pi_task, <span class="keyword">int</span> prio)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pi_task)</span><br><span class="line">		prio = min(prio, pi_task-&gt;prio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rt_effective_prio</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pi_task</span> = <span class="title">rt_mutex_get_top_task</span>(<span class="title">p</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __rt_effective_prio(pi_task, prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rt_mutex_setprio - set the current priority of a task</span></span><br><span class="line"><span class="comment"> * @p: task to boost</span></span><br><span class="line"><span class="comment"> * @pi_task: donor task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function changes the 'effective' priority of a task. It does</span></span><br><span class="line"><span class="comment"> * not touch -&gt;normal_prio like __setscheduler().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used by the rt_mutex code to implement priority inheritance</span></span><br><span class="line"><span class="comment"> * logic. Call site only calls if the priority of the task changed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_mutex_setprio</span><span class="params">(struct task_struct *p, struct task_struct *pi_task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio, oldprio, queued, running, queue_flag =</span><br><span class="line">		DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">prev_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XXX used to be waiter-&gt;prio, not waiter-&gt;task-&gt;prio */</span></span><br><span class="line">	prio = __rt_effective_prio(pi_task, p-&gt;normal_prio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If nothing changed; bail early.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;pi_top_task == pi_task &amp;&amp; prio == p-&gt;prio &amp;&amp; !dl_prio(prio))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set under pi_lock &amp;&amp; rq-&gt;lock, such that the value can be used under</span></span><br><span class="line"><span class="comment">	 * either lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note that there is loads of tricky to make this pointer cache work</span></span><br><span class="line"><span class="comment">	 * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to</span></span><br><span class="line"><span class="comment">	 * ensure a task is de-boosted (pi_task is set to NULL) before the</span></span><br><span class="line"><span class="comment">	 * task is allowed to run again (and can exit). This ensures the pointer</span></span><br><span class="line"><span class="comment">	 * points to a blocked task -- which guaratees the task is present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;pi_top_task = pi_task;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For FIFO/RR we only need to set prio, if that matches we're done.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (prio == p-&gt;prio &amp;&amp; !dl_prio(prio))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Idle task boosting is a nono in general. There is one</span></span><br><span class="line"><span class="comment">	 * exception, when PREEMPT_RT and NOHZ is active:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The idle task calls get_next_timer_interrupt() and holds</span></span><br><span class="line"><span class="comment">	 * the timer wheel base-&gt;lock on the CPU and another CPU wants</span></span><br><span class="line"><span class="comment">	 * to access the timer (probably to cancel it). We can safely</span></span><br><span class="line"><span class="comment">	 * ignore the boosting request, as the idle CPU runs this code</span></span><br><span class="line"><span class="comment">	 * with interrupts disabled and will complete the lock</span></span><br><span class="line"><span class="comment">	 * protected section without being interrupted. So there is no</span></span><br><span class="line"><span class="comment">	 * real need to boost.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p == rq-&gt;idle)) &#123;</span><br><span class="line">		WARN_ON(p != rq-&gt;curr);</span><br><span class="line">		WARN_ON(p-&gt;pi_blocked_on);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_sched_pi_setprio(p, pi_task);</span><br><span class="line">	oldprio = p-&gt;prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldprio == prio)</span><br><span class="line">		queue_flag &amp;= ~DEQUEUE_MOVE;</span><br><span class="line"></span><br><span class="line">	prev_class = p-&gt;sched_class;</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, queue_flag);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Boosting condition are:</span></span><br><span class="line"><span class="comment">	 * 1. -rt task is running and holds mutex A</span></span><br><span class="line"><span class="comment">	 *      --&gt; -dl task blocks on mutex A</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2. -dl task is running and holds mutex A</span></span><br><span class="line"><span class="comment">	 *      --&gt; -dl task blocks on mutex A and could preempt the</span></span><br><span class="line"><span class="comment">	 *          running task</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(prio)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dl_prio(p-&gt;normal_prio) ||</span><br><span class="line">		    (pi_task &amp;&amp; dl_prio(pi_task-&gt;prio) &amp;&amp;</span><br><span class="line">		     dl_entity_preempt(&amp;pi_task-&gt;dl, &amp;p-&gt;dl))) &#123;</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">1</span>;</span><br><span class="line">			queue_flag |= ENQUEUE_REPLENISH;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		p-&gt;sched_class = &amp;dl_sched_class;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(prio)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_prio(oldprio))</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (oldprio &lt; prio)</span><br><span class="line">			queue_flag |= ENQUEUE_HEAD;</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_prio(oldprio))</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (rt_prio(oldprio))</span><br><span class="line">			p-&gt;rt.timeout = <span class="number">0</span>;</span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;prio = prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, queue_flag);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	check_class_changed(rq, p, prev_class, oldprio);</span><br><span class="line">out_unlock:</span><br><span class="line">	<span class="comment">/* Avoid rq from going away on us: */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	__task_rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rt_effective_prio</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_user_nice</span><span class="params">(struct task_struct *p, <span class="keyword">long</span> nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line">	<span class="keyword">int</span> old_prio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_nice(p) == nice || nice &lt; MIN_NICE || nice &gt; MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to be careful, if called from sys_setpriority(),</span></span><br><span class="line"><span class="comment">	 * the task might be in the middle of scheduling on another CPU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The RT priorities are set via sched_setscheduler(), but we still</span></span><br><span class="line"><span class="comment">	 * allow the 'normal' nice value to be set - but as expected</span></span><br><span class="line"><span class="comment">	 * it wont have any effect on scheduling until the task is</span></span><br><span class="line"><span class="comment">	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) &#123;</span><br><span class="line">		p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">	old_prio = p-&gt;prio;</span><br><span class="line">	p-&gt;prio = effective_prio(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the task increased its priority or is running and</span></span><br><span class="line"><span class="comment">	 * lowered its priority, then reschedule its CPU:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;sched_class-&gt;prio_changed(rq, p, old_prio);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(set_user_nice);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * can_nice - check if a task can reduce its nice value</span></span><br><span class="line"><span class="comment"> * @p: task</span></span><br><span class="line"><span class="comment"> * @nice: nice value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_nice</span><span class="params">(<span class="keyword">const</span> struct task_struct *p, <span class="keyword">const</span> <span class="keyword">int</span> nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Convert nice value [19,-20] to rlimit style value [1,40]: */</span></span><br><span class="line">	<span class="keyword">int</span> nice_rlim = nice_to_rlimit(nice);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (nice_rlim &lt;= task_rlimit(p, RLIMIT_NICE) ||</span><br><span class="line">		capable(CAP_SYS_NICE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_SYS_NICE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_nice - change the priority of the current process.</span></span><br><span class="line"><span class="comment"> * @increment: priority increment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sys_setpriority is a more generic, but much slower function that</span></span><br><span class="line"><span class="comment"> * does similar things.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(nice, <span class="keyword">int</span>, increment)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> nice, retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setpriority might change our priority at the same moment.</span></span><br><span class="line"><span class="comment">	 * We don't have to worry. Conceptually one call occurs first</span></span><br><span class="line"><span class="comment">	 * and we have a single winner.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	increment = clamp(increment, -NICE_WIDTH, NICE_WIDTH);</span><br><span class="line">	nice = task_nice(current) + increment;</span><br><span class="line"></span><br><span class="line">	nice = clamp_val(nice, MIN_NICE, MAX_NICE);</span><br><span class="line">	<span class="keyword">if</span> (increment &lt; <span class="number">0</span> &amp;&amp; !can_nice(current, nice))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	retval = security_task_setnice(current, nice);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	set_user_nice(current, nice);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_prio - return the priority value of a given task.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The priority value as seen by users in /proc.</span></span><br><span class="line"><span class="comment"> * RT tasks are offset by -200. Normal tasks are centered</span></span><br><span class="line"><span class="comment"> * around 0, value goes from -16 to +15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task_prio</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;prio - MAX_RT_PRIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idle_cpu - is a given CPU idle currently?</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the CPU is currently idle. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;curr != rq-&gt;idle)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;ttwu_pending)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * available_idle_cpu - is a given CPU idle for enqueuing work.</span></span><br><span class="line"><span class="comment"> * @cpu: the CPU in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the CPU is currently idle. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available_idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!idle_cpu(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vcpu_is_preempted(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idle_task - return the idle task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The idle task for the CPU @cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">idle_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_rq(cpu)-&gt;idle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find_process_by_pid - find a process with a matching PID value.</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The task of @pid, if found. %NULL otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">find_process_by_pid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pid ? find_task_by_vpid(pid) : current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_setparam() passes in -1 for its policy, to let the functions</span></span><br><span class="line"><span class="comment"> * it calls know not to change it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETPARAM_POLICY	-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_params(struct task_struct *p,</span><br><span class="line">		<span class="keyword">const</span> struct sched_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> policy = attr-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (policy == SETPARAM_POLICY)</span><br><span class="line">		policy = p-&gt;policy;</span><br><span class="line"></span><br><span class="line">	p-&gt;policy = policy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_policy(policy))</span><br><span class="line">		__setparam_dl(p, attr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fair_policy(policy))</span><br><span class="line">		p-&gt;static_prio = NICE_TO_PRIO(attr-&gt;sched_nice);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * __sched_setscheduler() ensures attr-&gt;sched_priority == 0 when</span></span><br><span class="line"><span class="comment">	 * !rt_policy. Always setting this ensures that things like</span></span><br><span class="line"><span class="comment">	 * getparam()/getattr() don't report silly values for !rt tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;rt_priority = attr-&gt;sched_priority;</span><br><span class="line">	p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Actually do priority change: must hold pi &amp; rq lock. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler(struct rq *rq, struct task_struct *p,</span><br><span class="line">			   <span class="keyword">const</span> struct sched_attr *attr, <span class="keyword">bool</span> keep_boost)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If params can't change scheduling class changes aren't allowed</span></span><br><span class="line"><span class="comment">	 * either.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_KEEP_PARAMS)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__setscheduler_params(p, attr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep a potential priority boosting if called from</span></span><br><span class="line"><span class="comment">	 * sched_setscheduler().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;prio = normal_prio(p);</span><br><span class="line">	<span class="keyword">if</span> (keep_boost)</span><br><span class="line">		p-&gt;prio = rt_effective_prio(p, p-&gt;prio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;dl_sched_class;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check the target process has a UID that matches the current process's:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">check_same_owner</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> = <span class="title">current_cred</span>(), *<span class="title">pcred</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> match;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	pcred = __task_cred(p);</span><br><span class="line">	match = (uid_eq(cred-&gt;euid, pcred-&gt;euid) ||</span><br><span class="line">		 uid_eq(cred-&gt;euid, pcred-&gt;uid));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __sched_setscheduler(struct task_struct *p,</span><br><span class="line">				<span class="keyword">const</span> struct sched_attr *attr,</span><br><span class="line">				<span class="keyword">bool</span> user, <span class="keyword">bool</span> pi)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> newprio = dl_policy(attr-&gt;sched_policy) ? MAX_DL_PRIO - <span class="number">1</span> :</span><br><span class="line">		      MAX_RT_PRIO - <span class="number">1</span> - attr-&gt;sched_priority;</span><br><span class="line">	<span class="keyword">int</span> retval, oldprio, oldpolicy = <span class="number">-1</span>, queued, running;</span><br><span class="line">	<span class="keyword">int</span> new_effective_prio, policy = attr-&gt;sched_policy;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">prev_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> reset_on_fork;</span><br><span class="line">	<span class="keyword">int</span> queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The pi code expects interrupts enabled */</span></span><br><span class="line">	BUG_ON(pi &amp;&amp; in_interrupt());</span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* Double check policy once rq lock held: */</span></span><br><span class="line">	<span class="keyword">if</span> (policy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		reset_on_fork = p-&gt;sched_reset_on_fork;</span><br><span class="line">		policy = oldpolicy = p-&gt;policy;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reset_on_fork = !!(attr-&gt;sched_flags &amp; SCHED_FLAG_RESET_ON_FORK);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!valid_policy(policy))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Valid priorities for SCHED_FIFO and SCHED_RR are</span></span><br><span class="line"><span class="comment">	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,</span></span><br><span class="line"><span class="comment">	 * SCHED_BATCH and SCHED_IDLE is 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;mm &amp;&amp; attr-&gt;sched_priority &gt; MAX_USER_RT_PRIO<span class="number">-1</span>) ||</span><br><span class="line">	    (!p-&gt;mm &amp;&amp; attr-&gt;sched_priority &gt; MAX_RT_PRIO<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> ((dl_policy(policy) &amp;&amp; !__checkparam_dl(attr)) ||</span><br><span class="line">	    (rt_policy(policy) != (attr-&gt;sched_priority != <span class="number">0</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Allow unprivileged RT tasks to decrease priority:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (user &amp;&amp; !capable(CAP_SYS_NICE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fair_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (attr-&gt;sched_nice &lt; task_nice(p) &amp;&amp;</span><br><span class="line">			    !can_nice(p, attr-&gt;sched_nice))</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rt_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_rtprio =</span><br><span class="line">					task_rlimit(p, RLIMIT_RTPRIO);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Can't set/change the rt policy: */</span></span><br><span class="line">			<span class="keyword">if</span> (policy != p-&gt;policy &amp;&amp; !rlim_rtprio)</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Can't increase priority: */</span></span><br><span class="line">			<span class="keyword">if</span> (attr-&gt;sched_priority &gt; p-&gt;rt_priority &amp;&amp;</span><br><span class="line">			    attr-&gt;sched_priority &gt; rlim_rtprio)</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">		  * Can't set/change SCHED_DEADLINE policy at all for now</span></span><br><span class="line"><span class="comment">		  * (safest behavior); in the future we would like to allow</span></span><br><span class="line"><span class="comment">		  * unprivileged DL tasks to increase their relative deadline</span></span><br><span class="line"><span class="comment">		  * or reduce their runtime (both ways reducing utilization)</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		<span class="keyword">if</span> (dl_policy(policy))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Treat SCHED_IDLE as nice 20. Only allow a switch to</span></span><br><span class="line"><span class="comment">		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (task_has_idle_policy(p) &amp;&amp; !idle_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!can_nice(p, task_nice(p)))</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Can't change other user's priorities: */</span></span><br><span class="line">		<span class="keyword">if</span> (!check_same_owner(p))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Normal users shall not reset the sched_reset_on_fork flag: */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;sched_reset_on_fork &amp;&amp; !reset_on_fork)</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (user) &#123;</span><br><span class="line">		<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_SUGOV)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		retval = security_task_setscheduler(p);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update task specific "requested" clamps */</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP) &#123;</span><br><span class="line">		retval = uclamp_validate(p, attr);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi)</span><br><span class="line">		cpuset_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure no PI-waiters arrive (or leave) while we are</span></span><br><span class="line"><span class="comment">	 * changing the priority of the task:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * To be able to change p-&gt;policy safely, the appropriate</span></span><br><span class="line"><span class="comment">	 * runqueue lock must be held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Changing the policy of the stop threads its a very bad idea:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p == rq-&gt;stop) &#123;</span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If not changing anything there's no need to proceed further,</span></span><br><span class="line"><span class="comment">	 * but store a possible modification of reset_on_fork.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(policy == p-&gt;policy)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fair_policy(policy) &amp;&amp; attr-&gt;sched_nice != task_nice(p))</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (rt_policy(policy) &amp;&amp; attr-&gt;sched_priority != p-&gt;rt_priority)</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (dl_policy(policy) &amp;&amp; dl_param_changed(p, attr))</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP)</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line"></span><br><span class="line">		p-&gt;sched_reset_on_fork = reset_on_fork;</span><br><span class="line">		retval = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">change:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (user) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Do not allow realtime tasks into groups that have no runtime</span></span><br><span class="line"><span class="comment">		 * assigned.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rt_bandwidth_enabled() &amp;&amp; rt_policy(policy) &amp;&amp;</span><br><span class="line">				task_group(p)-&gt;rt_bandwidth.rt_runtime == <span class="number">0</span> &amp;&amp;</span><br><span class="line">				!task_group_is_autogroup(task_group(p))) &#123;</span><br><span class="line">			retval = -EPERM;</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		<span class="keyword">if</span> (dl_bandwidth_enabled() &amp;&amp; dl_policy(policy) &amp;&amp;</span><br><span class="line">				!(attr-&gt;sched_flags &amp; SCHED_FLAG_SUGOV)) &#123;</span><br><span class="line">			<span class="keyword">cpumask_t</span> *span = rq-&gt;rd-&gt;span;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Don't allow tasks with an affinity mask smaller than</span></span><br><span class="line"><span class="comment">			 * the entire root_domain to become SCHED_DEADLINE. We</span></span><br><span class="line"><span class="comment">			 * will also fail if there's no bandwidth available.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!cpumask_subset(span, p-&gt;cpus_ptr) ||</span><br><span class="line">			    rq-&gt;rd-&gt;dl_bw.bw == <span class="number">0</span>) &#123;</span><br><span class="line">				retval = -EPERM;</span><br><span class="line">				<span class="keyword">goto</span> unlock;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Re-check policy now with rq lock held: */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(oldpolicy != <span class="number">-1</span> &amp;&amp; oldpolicy != p-&gt;policy)) &#123;</span><br><span class="line">		policy = oldpolicy = <span class="number">-1</span>;</span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (pi)</span><br><span class="line">			cpuset_read_unlock();</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If setscheduling to SCHED_DEADLINE (or changing the parameters</span></span><br><span class="line"><span class="comment">	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth</span></span><br><span class="line"><span class="comment">	 * is available.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((dl_policy(policy) || dl_task(p)) &amp;&amp; sched_dl_overflow(p, policy, attr)) &#123;</span><br><span class="line">		retval = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_reset_on_fork = reset_on_fork;</span><br><span class="line">	oldprio = p-&gt;prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Take priority boosted tasks into account. If the new</span></span><br><span class="line"><span class="comment">		 * effective priority is unchanged, we just store the new</span></span><br><span class="line"><span class="comment">		 * normal parameters and do not touch the scheduler class and</span></span><br><span class="line"><span class="comment">		 * the runqueue. This will be done when the task deboost</span></span><br><span class="line"><span class="comment">		 * itself.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		new_effective_prio = rt_effective_prio(p, newprio);</span><br><span class="line">		<span class="keyword">if</span> (new_effective_prio == oldprio)</span><br><span class="line">			queue_flags &amp;= ~DEQUEUE_MOVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	prev_class = p-&gt;sched_class;</span><br><span class="line"></span><br><span class="line">	__setscheduler(rq, p, attr, pi);</span><br><span class="line">	__setscheduler_uclamp(p, attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We enqueue to tail when the priority of a task is</span></span><br><span class="line"><span class="comment">		 * increased (user space view).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (oldprio &lt; p-&gt;prio)</span><br><span class="line">			queue_flags |= ENQUEUE_HEAD;</span><br><span class="line"></span><br><span class="line">		enqueue_task(rq, p, queue_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	check_class_changed(rq, p, prev_class, oldprio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid rq from going away on us: */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi) &#123;</span><br><span class="line">		cpuset_read_unlock();</span><br><span class="line">		rt_mutex_adjust_pi(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Run balance callbacks after we've adjusted the PI chain: */</span></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (pi)</span><br><span class="line">		cpuset_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _sched_setscheduler(struct task_struct *p, <span class="keyword">int</span> policy,</span><br><span class="line">			       <span class="keyword">const</span> struct sched_param *param, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span> = &#123;</span></span><br><span class="line">		.sched_policy   = policy,</span><br><span class="line">		.sched_priority = param-&gt;sched_priority,</span><br><span class="line">		.sched_nice	= PRIO_TO_NICE(p-&gt;static_prio),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fixup the legacy SCHED_RESET_ON_FORK hack. */</span></span><br><span class="line">	<span class="keyword">if</span> ((policy != SETPARAM_POLICY) &amp;&amp; (policy &amp; SCHED_RESET_ON_FORK)) &#123;</span><br><span class="line">		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;</span><br><span class="line">		policy &amp;= ~SCHED_RESET_ON_FORK;</span><br><span class="line">		attr.sched_policy = policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, &amp;attr, check, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE that the task may be already dead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setscheduler</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> policy,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> struct sched_param *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _sched_setscheduler(p, policy, param, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setscheduler);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setattr</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, attr, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setattr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setattr_nocheck</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, attr, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Just like sched_setscheduler, only don't bother checking if the</span></span><br><span class="line"><span class="comment"> * current context has permission.  For example, this is needed in</span></span><br><span class="line"><span class="comment"> * stop_machine(): we create temporary high priority worker threads,</span></span><br><span class="line"><span class="comment"> * but our caller might not have that capability.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setscheduler_nocheck</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> policy,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">const</span> struct sched_param *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _sched_setscheduler(p, policy, param, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setscheduler_nocheck);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_sched_setscheduler(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> policy, struct sched_param __user *param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">lparam</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param || pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;lparam, param, <span class="keyword">sizeof</span>(struct sched_param)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (likely(p))</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(p)) &#123;</span><br><span class="line">		retval = sched_setscheduler(p, policy, &amp;lparam);</span><br><span class="line">		put_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mimics kernel/events/core.c perf_copy_attr().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sched_copy_attr</span><span class="params">(struct sched_attr __user *uattr, struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 size;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Zero the full structure, so that a short copy will be nice: */</span></span><br><span class="line">	<span class="built_in">memset</span>(attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line"></span><br><span class="line">	ret = get_user(size, &amp;uattr-&gt;size);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ABI compatibility quirk: */</span></span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		size = SCHED_ATTR_SIZE_VER0;</span><br><span class="line">	<span class="keyword">if</span> (size &lt; SCHED_ATTR_SIZE_VER0 || size &gt; PAGE_SIZE)</span><br><span class="line">		<span class="keyword">goto</span> err_size;</span><br><span class="line"></span><br><span class="line">	ret = copy_struct_from_user(attr, <span class="keyword">sizeof</span>(*attr), uattr, size);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == -E2BIG)</span><br><span class="line">			<span class="keyword">goto</span> err_size;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP) &amp;&amp;</span><br><span class="line">	    size &lt; SCHED_ATTR_SIZE_VER1)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">XXX:</span> Do we want to be lenient like existing syscalls; or do we want</span></span><br><span class="line"><span class="comment">	 * to be strict and return an error on out-of-bounds values?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	attr-&gt;sched_nice = clamp(attr-&gt;sched_nice, MIN_NICE, MAX_NICE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_size:</span><br><span class="line">	put_user(<span class="keyword">sizeof</span>(*attr), &amp;uattr-&gt;size);</span><br><span class="line">	<span class="keyword">return</span> -E2BIG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setscheduler - set/change the scheduler policy and RT priority</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setscheduler, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, policy, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (policy &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_sched_setscheduler(pid, policy, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setparam - set/change the RT priority of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_setparam, <span class="keyword">pid_t</span>, pid, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_sched_setscheduler(pid, SETPARAM_POLICY, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setattr - same as above, but with extended sched_attr</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @uattr: structure containing the extended parameters.</span></span><br><span class="line"><span class="comment"> * @flags: for future extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setattr, <span class="keyword">pid_t</span>, pid, struct sched_attr __user *, uattr,</span><br><span class="line">			       <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uattr || pid &lt; <span class="number">0</span> || flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = sched_copy_attr(uattr, &amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">int</span>)attr.sched_policy &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (attr.sched_flags &amp; SCHED_FLAG_KEEP_POLICY)</span><br><span class="line">		attr.sched_policy = SETPARAM_POLICY;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (likely(p))</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(p)) &#123;</span><br><span class="line">		retval = sched_setattr(p, &amp;attr);</span><br><span class="line">		put_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getscheduler - get the policy (scheduling class) of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, the policy of the thread. Otherwise, a negative error</span></span><br><span class="line"><span class="comment"> * code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_getscheduler, <span class="keyword">pid_t</span>, pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		retval = security_task_getscheduler(p);</span><br><span class="line">		<span class="keyword">if</span> (!retval)</span><br><span class="line">			retval = p-&gt;policy</span><br><span class="line">				| (p-&gt;sched_reset_on_fork ? SCHED_RESET_ON_FORK : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getparam - get the RT priority of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, 0 and the RT priority is in @param. Otherwise, an error</span></span><br><span class="line"><span class="comment"> * code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_getparam, <span class="keyword">pid_t</span>, pid, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">lp</span> = &#123;</span> .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param || pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		lp.sched_priority = p-&gt;rt_priority;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This one might sleep, we cannot do it with a spinlock held ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = copy_to_user(param, &amp;lp, <span class="keyword">sizeof</span>(*param)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the kernel size attribute structure (which might be larger</span></span><br><span class="line"><span class="comment"> * than what user-space knows about) to user-space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that all cases are valid: user-space buffer can be larger or</span></span><br><span class="line"><span class="comment"> * smaller than the kernel-space buffer. The usual case is that both</span></span><br><span class="line"><span class="comment"> * have the same size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sched_attr_copy_to_user(struct sched_attr __user *uattr,</span><br><span class="line">			struct sched_attr *kattr,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> usize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ksize = <span class="keyword">sizeof</span>(*kattr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!access_ok(uattr, usize))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * sched_getattr() ABI forwards and backwards compatibility:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize == ksize then we just copy everything to user-space and all is good.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize &lt; ksize then we only copy as much as user-space has space for,</span></span><br><span class="line"><span class="comment">	 * this keeps ABI compatibility as well. We skip the rest.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize &gt; ksize then user-space is using a newer version of the ABI,</span></span><br><span class="line"><span class="comment">	 * which part the kernel doesn't know about. Just ignore it - tooling can</span></span><br><span class="line"><span class="comment">	 * detect the kernel's knowledge of attributes from the attr-&gt;size value</span></span><br><span class="line"><span class="comment">	 * which is set to ksize in this case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kattr-&gt;size = min(usize, ksize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(uattr, kattr, kattr-&gt;size))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getattr - similar to sched_getparam, but with sched_attr</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @uattr: structure containing the extended parameters.</span></span><br><span class="line"><span class="comment"> * @usize: sizeof(attr) for fwd/bwd comp.</span></span><br><span class="line"><span class="comment"> * @flags: for future extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(sched_getattr, <span class="keyword">pid_t</span>, pid, struct sched_attr __user *, uattr,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>, usize, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">kattr</span> = &#123;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uattr || pid &lt; <span class="number">0</span> || usize &gt; PAGE_SIZE ||</span><br><span class="line">	    usize &lt; SCHED_ATTR_SIZE_VER0 || flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	kattr.sched_policy = p-&gt;policy;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_reset_on_fork)</span><br><span class="line">		kattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;</span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">		__getparam_dl(p, &amp;kattr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		kattr.sched_priority = p-&gt;rt_priority;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kattr.sched_nice = task_nice(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	kattr.sched_util_min = p-&gt;uclamp_req[UCLAMP_MIN].value;</span><br><span class="line">	kattr.sched_util_max = p-&gt;uclamp_req[UCLAMP_MAX].value;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_attr_copy_to_user(uattr, &amp;kattr, usize);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> struct cpumask *in_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> cpus_allowed, new_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> -ESRCH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevent p going away */</span></span><br><span class="line">	get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_NO_SETAFFINITY) &#123;</span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_put_task;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_put_task;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free_cpus_allowed;</span><br><span class="line">	&#125;</span><br><span class="line">	retval = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (!check_same_owner(p)) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		<span class="keyword">if</span> (!ns_capable(__task_cred(p)-&gt;user_ns, CAP_SYS_NICE)) &#123;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = security_task_setscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cpuset_cpus_allowed(p, cpus_allowed);</span><br><span class="line">	cpumask_and(new_mask, in_mask, cpus_allowed);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since bandwidth control happens on root_domain basis,</span></span><br><span class="line"><span class="comment">	 * if admission test is enabled, we only admit -deadline</span></span><br><span class="line"><span class="comment">	 * tasks allowed to run on all the CPUs in the task's</span></span><br><span class="line"><span class="comment">	 * root_domain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) &amp;&amp; dl_bandwidth_enabled()) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		<span class="keyword">if</span> (!cpumask_subset(task_rq(p)-&gt;rd-&gt;span, new_mask)) &#123;</span><br><span class="line">			retval = -EBUSY;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">again:</span><br><span class="line">	retval = __set_cpus_allowed_ptr(p, new_mask, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">		cpuset_cpus_allowed(p, cpus_allowed);</span><br><span class="line">		<span class="keyword">if</span> (!cpumask_subset(new_mask, cpus_allowed)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We must have raced with a concurrent cpuset</span></span><br><span class="line"><span class="comment">			 * update. Just reset the cpus_allowed to the</span></span><br><span class="line"><span class="comment">			 * cpuset's cpus_allowed</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			cpumask_copy(new_mask, cpus_allowed);</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_free_new_mask:</span><br><span class="line">	free_cpumask_var(new_mask);</span><br><span class="line">out_free_cpus_allowed:</span><br><span class="line">	free_cpumask_var(cpus_allowed);</span><br><span class="line">out_put_task:</span><br><span class="line">	put_task_struct(p);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_user_cpu_mask</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *user_mask_ptr, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; cpumask_size())</span><br><span class="line">		cpumask_clear(new_mask);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; cpumask_size())</span><br><span class="line">		len = cpumask_size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setaffinity - set the CPU affinity of a process</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process</span></span><br><span class="line"><span class="comment"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span></span><br><span class="line"><span class="comment"> * @user_mask_ptr: user-space pointer to the new CPU mask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setaffinity, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, len,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, user_mask_ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> new_mask;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = sched_setaffinity(pid, new_mask);</span><br><span class="line">	free_cpumask_var(new_mask);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, struct cpumask *mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	cpumask_and(mask, &amp;p-&gt;cpus_mask, cpu_active_mask);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getaffinity - get the CPU affinity of a process</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process</span></span><br><span class="line"><span class="comment"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span></span><br><span class="line"><span class="comment"> * @user_mask_ptr: user-space pointer to hold the current CPU mask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: size of CPU mask copied to user_mask_ptr on success. An</span></span><br><span class="line"><span class="comment"> * error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_getaffinity, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, len,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, user_mask_ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((len * BITS_PER_BYTE) &lt; nr_cpu_ids)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (len &amp; (<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ret = sched_getaffinity(pid, mask);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> retlen = min(len, cpumask_size());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(user_mask_ptr, mask, retlen))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = retlen;</span><br><span class="line">	&#125;</span><br><span class="line">	free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_yield - yield the current processor to other threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function yields the current CPU to other tasks. If there are no</span></span><br><span class="line"><span class="comment"> * other threads running on this CPU then this function will return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = this_rq_lock_irq(&amp;rf);</span><br><span class="line"></span><br><span class="line">	schedstat_inc(rq-&gt;yld_count);</span><br><span class="line">	current-&gt;sched_class-&gt;yield_task(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we are going to call schedule() anyway, there's</span></span><br><span class="line"><span class="comment">	 * no need to preempt or enable interrupts:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE0(sched_yield)</span><br><span class="line">&#123;</span><br><span class="line">	do_sched_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_PREEMPTION</span></span><br><span class="line"><span class="keyword">int</span> __sched _cond_resched(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (should_resched(<span class="number">0</span>)) &#123;</span><br><span class="line">		preempt_schedule_common();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_all_qs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(_cond_resched);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __cond_resched_lock() - if a reschedule is pending, drop the given lock,</span></span><br><span class="line"><span class="comment"> * call schedule, and on return reacquire the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level</span></span><br><span class="line"><span class="comment"> * operations here to prevent schedule() from being called twice (once via</span></span><br><span class="line"><span class="comment"> * spin_unlock(), once by hand).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __cond_resched_lock(<span class="keyword">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> resched = should_resched(PREEMPT_LOCK_OFFSET);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (spin_needbreak(lock) || resched) &#123;</span><br><span class="line">		spin_unlock(lock);</span><br><span class="line">		<span class="keyword">if</span> (resched)</span><br><span class="line">			preempt_schedule_common();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cpu_relax();</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		spin_lock(lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__cond_resched_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield - yield the current processor to other threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not ever use this function, there's a 99% chance you're doing it wrong.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The scheduler is at all times free to pick the calling task as the most</span></span><br><span class="line"><span class="comment"> * eligible task to run, if removing the yield() call from your code breaks</span></span><br><span class="line"><span class="comment"> * it, its already broken.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typical broken usage is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * while (!event)</span></span><br><span class="line"><span class="comment"> *	yield();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * where one assumes that yield() will let 'the other' process run that will</span></span><br><span class="line"><span class="comment"> * make event true. If the current task is a SCHED_FIFO task that will never</span></span><br><span class="line"><span class="comment"> * happen. Never use yield() as a progress guarantee!!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you want to use yield() to wait for something, use wait_event().</span></span><br><span class="line"><span class="comment"> * If you want to use yield() to be 'nice' for others, use cond_resched().</span></span><br><span class="line"><span class="comment"> * If you still want to use yield(), do not!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_current_state(TASK_RUNNING);</span><br><span class="line">	do_sched_yield();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(yield);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield_to - yield the current processor to another thread in</span></span><br><span class="line"><span class="comment"> * your thread group, or accelerate that thread toward the</span></span><br><span class="line"><span class="comment"> * processor it's on.</span></span><br><span class="line"><span class="comment"> * @p: target task</span></span><br><span class="line"><span class="comment"> * @preempt: whether task preemption is allowed or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It's the caller's job to ensure that the target task struct</span></span><br><span class="line"><span class="comment"> * can't go away on us before we can do any checks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *	true (&gt;0) if we indeed boosted the target task.</span></span><br><span class="line"><span class="comment"> *	false (0) if we failed to boost the target.</span></span><br><span class="line"><span class="comment"> *	-ESRCH if there's no task to yield to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __sched <span class="title">yield_to</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> preempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, *<span class="title">p_rq</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> yielded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	rq = this_rq();</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	p_rq = task_rq(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we're the only runnable task on the rq and target rq also</span></span><br><span class="line"><span class="comment">	 * has only one task, there's absolutely no point in yielding.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running == <span class="number">1</span> &amp;&amp; p_rq-&gt;nr_running == <span class="number">1</span>) &#123;</span><br><span class="line">		yielded = -ESRCH;</span><br><span class="line">		<span class="keyword">goto</span> out_irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	double_rq_lock(rq, p_rq);</span><br><span class="line">	<span class="keyword">if</span> (task_rq(p) != p_rq) &#123;</span><br><span class="line">		double_rq_unlock(rq, p_rq);</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!curr-&gt;sched_class-&gt;yield_to_task)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curr-&gt;sched_class != p-&gt;sched_class)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_running(p_rq, p) || p-&gt;state)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	yielded = curr-&gt;sched_class-&gt;yield_to_task(rq, p, preempt);</span><br><span class="line">	<span class="keyword">if</span> (yielded) &#123;</span><br><span class="line">		schedstat_inc(rq-&gt;yld_count);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make p's CPU reschedule; pick_next_entity takes care of</span></span><br><span class="line"><span class="comment">		 * fairness.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (preempt &amp;&amp; rq != p_rq)</span><br><span class="line">			resched_curr(p_rq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	double_rq_unlock(rq, p_rq);</span><br><span class="line">out_irq:</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (yielded &gt; <span class="number">0</span>)</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> yielded;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(yield_to);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_schedule_prepare</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_iowait = current-&gt;in_iowait;</span><br><span class="line"></span><br><span class="line">	current-&gt;in_iowait = <span class="number">1</span>;</span><br><span class="line">	blk_schedule_flush_plug(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> old_iowait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_schedule_finish</span><span class="params">(<span class="keyword">int</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	current-&gt;in_iowait = token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This task is about to go to sleep on IO. Increment rq-&gt;nr_iowait so</span></span><br><span class="line"><span class="comment"> * that process accounting knows that this is a task in IO wait state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> __sched <span class="title">io_schedule_timeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line">	<span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">	token = io_schedule_prepare();</span><br><span class="line">	ret = schedule_timeout(timeout);</span><br><span class="line">	io_schedule_finish(token);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(io_schedule_timeout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">io_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line"></span><br><span class="line">	token = io_schedule_prepare();</span><br><span class="line">	schedule();</span><br><span class="line">	io_schedule_finish(token);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(io_schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_get_priority_max - return maximum RT priority.</span></span><br><span class="line"><span class="comment"> * @policy: scheduling class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, this syscall returns the maximum</span></span><br><span class="line"><span class="comment"> * rt_priority that can be used by a given scheduling class.</span></span><br><span class="line"><span class="comment"> * On failure, a negative error code is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_get_priority_max, <span class="keyword">int</span>, policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">	<span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">	<span class="keyword">case</span> SCHED_RR:</span><br><span class="line">		ret = MAX_USER_RT_PRIO<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SCHED_DEADLINE:</span><br><span class="line">	<span class="keyword">case</span> SCHED_NORMAL:</span><br><span class="line">	<span class="keyword">case</span> SCHED_BATCH:</span><br><span class="line">	<span class="keyword">case</span> SCHED_IDLE:</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_get_priority_min - return minimum RT priority.</span></span><br><span class="line"><span class="comment"> * @policy: scheduling class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, this syscall returns the minimum</span></span><br><span class="line"><span class="comment"> * rt_priority that can be used by a given scheduling class.</span></span><br><span class="line"><span class="comment"> * On failure, a negative error code is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_get_priority_min, <span class="keyword">int</span>, policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">	<span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">	<span class="keyword">case</span> SCHED_RR:</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SCHED_DEADLINE:</span><br><span class="line">	<span class="keyword">case</span> SCHED_NORMAL:</span><br><span class="line">	<span class="keyword">case</span> SCHED_BATCH:</span><br><span class="line">	<span class="keyword">case</span> SCHED_IDLE:</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sched_rr_get_interval</span><span class="params">(<span class="keyword">pid_t</span> pid, struct timespec64 *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	time_slice = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;get_rr_interval)</span><br><span class="line">		time_slice = p-&gt;sched_class-&gt;get_rr_interval(rq, p);</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	jiffies_to_timespec64(time_slice, t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_rr_get_interval - return the default timeslice of a process.</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process.</span></span><br><span class="line"><span class="comment"> * @interval: userspace pointer to the timeslice value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this syscall writes the default timeslice value of a given process</span></span><br><span class="line"><span class="comment"> * into the user-space timespec buffer. A value of '0' means infinity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, 0 and the timeslice is in @interval. Otherwise,</span></span><br><span class="line"><span class="comment"> * an error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_rr_get_interval, <span class="keyword">pid_t</span>, pid,</span><br><span class="line">		struct __kernel_timespec __user *, interval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = sched_rr_get_interval(pid, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = put_timespec64(&amp;t, interval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_32BIT_TIME</span></span><br><span class="line">SYSCALL_DEFINE2(sched_rr_get_interval_time32, <span class="keyword">pid_t</span>, pid,</span><br><span class="line">		struct old_timespec32 __user *, interval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = sched_rr_get_interval(pid, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = put_old_timespec32(&amp;t, interval);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_show_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ppid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_get_task_stack(p))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">"%-15.15s %c"</span>, p-&gt;comm, task_state_to_char(p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == TASK_RUNNING)</span><br><span class="line">		printk(KERN_CONT <span class="string">"  running task    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_STACK_USAGE</span></span><br><span class="line">	<span class="built_in">free</span> = stack_not_used(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ppid = <span class="number">0</span>;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (pid_alive(p))</span><br><span class="line">		ppid = task_pid_nr(rcu_dereference(p-&gt;real_parent));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	printk(KERN_CONT <span class="string">"%5lu %5d %6d 0x%08lx\n"</span>, <span class="built_in">free</span>,</span><br><span class="line">		task_pid_nr(p), ppid,</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_thread_info(p)-&gt;flags);</span><br><span class="line"></span><br><span class="line">	print_worker_info(KERN_INFO, p);</span><br><span class="line">	show_stack(p, <span class="literal">NULL</span>, KERN_INFO);</span><br><span class="line">	put_task_stack(p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_show_task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">state_filter_match(<span class="keyword">unsigned</span> <span class="keyword">long</span> state_filter, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* no filter, everything matches */</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* filter, but doesn't match */</span></span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;state &amp; state_filter))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows</span></span><br><span class="line"><span class="comment">	 * TASK_KILLABLE).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (state_filter == TASK_UNINTERRUPTIBLE &amp;&amp; p-&gt;state == TASK_IDLE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_state_filter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> state_filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line">	printk(KERN_INFO</span><br><span class="line">		<span class="string">"  task                PC stack   pid father\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	printk(KERN_INFO</span><br><span class="line">		<span class="string">"  task                        PC stack   pid father\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	for_each_process_thread(g, p) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * reset the NMI-timeout, listing all files on a slow</span></span><br><span class="line"><span class="comment">		 * console might take a lot of time:</span></span><br><span class="line"><span class="comment">		 * Also, reset softlockup watchdogs on all CPUs, because</span></span><br><span class="line"><span class="comment">		 * another CPU might be blocked waiting for us to process</span></span><br><span class="line"><span class="comment">		 * an IPI.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		touch_nmi_watchdog();</span><br><span class="line">		touch_all_softlockup_watchdogs();</span><br><span class="line">		<span class="keyword">if</span> (state_filter_match(state_filter, p))</span><br><span class="line">			sched_show_task(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		sysrq_sched_debug_show();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only show locks if all tasks are dumped:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		debug_show_all_locks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init_idle - set up an idle thread for a given CPU</span></span><br><span class="line"><span class="comment"> * @idle: task in question</span></span><br><span class="line"><span class="comment"> * @cpu: CPU the idle task belongs to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this function does not set the idle thread's NEED_RESCHED</span></span><br><span class="line"><span class="comment"> * flag, to make booting more robust.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_idle</span><span class="params">(struct task_struct *idle, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	__sched_fork(<span class="number">0</span>, idle);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;idle-&gt;pi_lock, flags);</span><br><span class="line">	raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	idle-&gt;state = TASK_RUNNING;</span><br><span class="line">	idle-&gt;se.exec_start = sched_clock();</span><br><span class="line">	idle-&gt;flags |= PF_IDLE;</span><br><span class="line"></span><br><span class="line">	scs_task_reset(idle);</span><br><span class="line">	kasan_unpoison_task_stack(idle);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Its possible that init_idle() gets called multiple times on a task,</span></span><br><span class="line"><span class="comment">	 * in that case do_set_cpus_allowed() will not do the right thing.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * And since this is boot we can forgo the serialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_cpus_allowed_common(idle, cpumask_of(cpu));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're having a chicken and egg problem, even though we are</span></span><br><span class="line"><span class="comment">	 * holding rq-&gt;lock, the CPU isn't yet set to this CPU so the</span></span><br><span class="line"><span class="comment">	 * lockdep check in task_group() will fail.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Similar case to sched_fork(). / Alternatively we could</span></span><br><span class="line"><span class="comment">	 * use task_rq_lock() here and obtain the other rq-&gt;lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Silence PROVE_RCU</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	__set_task_cpu(idle, cpu);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	rq-&gt;idle = idle;</span><br><span class="line">	rcu_assign_pointer(rq-&gt;curr, idle);</span><br><span class="line">	idle-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	idle-&gt;on_cpu = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;idle-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the preempt count _outside_ the spinlocks! */</span></span><br><span class="line">	init_idle_preempt_count(idle, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The idle tasks have their own, simple scheduling class:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	idle-&gt;sched_class = &amp;idle_sched_class;</span><br><span class="line">	ftrace_graph_init_idle_task(idle, cpu);</span><br><span class="line">	vtime_init_idle(idle, cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="built_in">sprintf</span>(idle-&gt;comm, <span class="string">"%s/%d"</span>, INIT_TASK_COMM, cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpuset_cpumask_can_shrink</span><span class="params">(<span class="keyword">const</span> struct cpumask *cur,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">const</span> struct cpumask *trial)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_weight(cur))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = dl_cpuset_cpumask_can_shrink(cur, trial);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task_can_attach</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">const</span> struct cpumask *cs_cpus_allowed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Kthreads which disallow setaffinity shouldn't be moved</span></span><br><span class="line"><span class="comment">	 * to a new cpuset; we don't want to change their CPU</span></span><br><span class="line"><span class="comment">	 * affinity and isolating such threads by their set of</span></span><br><span class="line"><span class="comment">	 * allowed nodes is unnecessary.  Thus, cpusets are not</span></span><br><span class="line"><span class="comment">	 * applicable for such threads.  This prevents checking for</span></span><br><span class="line"><span class="comment">	 * success of set_cpus_allowed_ptr() on all attached tasks</span></span><br><span class="line"><span class="comment">	 * before cpus_mask may be changed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_NO_SETAFFINITY) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_task(p) &amp;&amp; !cpumask_intersects(task_rq(p)-&gt;rd-&gt;span,</span><br><span class="line">					      cs_cpus_allowed))</span><br><span class="line">		ret = dl_task_can_attach(p, cs_cpus_allowed);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> sched_smp_initialized __read_mostly;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="comment">/* Migrate current task p to target_cpu */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">migrate_task_to</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> target_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, target_cpu &#125;;</span><br><span class="line">	<span class="keyword">int</span> curr_cpu = task_cpu(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curr_cpu == target_cpu)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(target_cpu, p-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> This is not properly updating schedstats */</span></span><br><span class="line"></span><br><span class="line">	trace_sched_move_numa(p, curr_cpu, target_cpu);</span><br><span class="line">	<span class="keyword">return</span> stop_one_cpu(curr_cpu, migration_cpu_stop, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Requeue a task on a given node and accurately track the number of NUMA</span></span><br><span class="line"><span class="comment"> * tasks on the runqueues</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_setnuma</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> nid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;numa_preferred_nid = nid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that the idle task is using init_mm right before its CPU goes</span></span><br><span class="line"><span class="comment"> * offline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idle_task_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(cpu_online(smp_processor_id()));</span><br><span class="line">	BUG_ON(current != this_rq()-&gt;idle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm != &amp;init_mm) &#123;</span><br><span class="line">		switch_mm(mm, &amp;init_mm, current);</span><br><span class="line">		finish_arch_post_lock_switch();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* finish_cpu(), as ran on the BP, will clean up the active_mm state */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since this CPU is going 'away' for a while, fold any nr_active delta</span></span><br><span class="line"><span class="comment"> * we might have. Assumes we're called after migrate_tasks() so that the</span></span><br><span class="line"><span class="comment"> * nr_active count is stable. We need to take the teardown thread which</span></span><br><span class="line"><span class="comment"> * is calling this into account, so we hand in adjust = 1 to the load</span></span><br><span class="line"><span class="comment"> * calculation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also see the comment "Global load-average calculations".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc_load_migrate</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> delta = calc_load_fold_active(rq, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (delta)</span><br><span class="line">		atomic_long_add(delta, &amp;calc_load_tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">pick_migrate_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		next = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (next) &#123;</span><br><span class="line">			next-&gt;sched_class-&gt;put_prev_task(rq, next);</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The idle class should always have a runnable task */</span></span><br><span class="line">	BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Migrate all tasks from the rq, sleeping tasks will be migrated by</span></span><br><span class="line"><span class="comment"> * try_to_wake_up()-&gt;select_task_rq().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called with rq-&gt;lock held even though we'er in stop_machine() and</span></span><br><span class="line"><span class="comment"> * there's no concurrency possible, we hold the required locks anyway</span></span><br><span class="line"><span class="comment"> * because of lock validation efforts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">migrate_tasks</span><span class="params">(struct rq *dead_rq, struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">dead_rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>, *<span class="title">stop</span> = <span class="title">rq</span>-&gt;<span class="title">stop</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">orf</span> = *<span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fudge the rq selection such that the below task selection loop</span></span><br><span class="line"><span class="comment">	 * doesn't get stuck on the currently eligible stop task.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We're currently inside stop_machine() and the rq is either stuck</span></span><br><span class="line"><span class="comment">	 * in the stop_machine_cpu_stop() loop, or we're executing this code,</span></span><br><span class="line"><span class="comment">	 * either way we should never end up calling schedule() until we're</span></span><br><span class="line"><span class="comment">	 * done here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq-&gt;stop = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * put_prev_task() and pick_next_task() sched</span></span><br><span class="line"><span class="comment">	 * class method both need to have an up-to-date</span></span><br><span class="line"><span class="comment">	 * value of rq-&gt;clock[_task]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * There's this thread running, bail when that's the only</span></span><br><span class="line"><span class="comment">		 * remaining thread:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;nr_running == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		next = __pick_migrate_task(rq);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Rules for changing task_struct::cpus_mask are holding</span></span><br><span class="line"><span class="comment">		 * both pi_lock and rq-&gt;lock, such that holding either</span></span><br><span class="line"><span class="comment">		 * stabilizes the mask.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Drop rq-&gt;lock is not quite as disastrous as it usually is</span></span><br><span class="line"><span class="comment">		 * because !cpu_active at this point, which means load-balance</span></span><br><span class="line"><span class="comment">		 * will not interfere. Also, stop-machine.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unlock(rq, rf);</span><br><span class="line">		raw_spin_lock(&amp;next-&gt;pi_lock);</span><br><span class="line">		rq_relock(rq, rf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Since we're inside stop-machine, _nothing_ should have</span></span><br><span class="line"><span class="comment">		 * changed the task, WARN if weird stuff happened, because in</span></span><br><span class="line"><span class="comment">		 * that case the above rq-&gt;lock drop is a fail too.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Find suitable destination for @next, with force if needed. */</span></span><br><span class="line">		dest_cpu = select_fallback_rq(dead_rq-&gt;cpu, next);</span><br><span class="line">		rq = __migrate_task(rq, rf, next, dest_cpu);</span><br><span class="line">		<span class="keyword">if</span> (rq != dead_rq) &#123;</span><br><span class="line">			rq_unlock(rq, rf);</span><br><span class="line">			rq = dead_rq;</span><br><span class="line">			*rf = orf;</span><br><span class="line">			rq_relock(rq, rf);</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;stop = stop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_HOTPLUG_CPU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_rq_online</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rq-&gt;online) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">		cpumask_set_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span><br><span class="line">		rq-&gt;online = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class-&gt;rq_online)</span><br><span class="line">				<span class="class"><span class="keyword">class</span>-&gt;<span class="title">rq_online</span>(<span class="title">rq</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_rq_offline</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;online) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class-&gt;rq_offline)</span><br><span class="line">				<span class="class"><span class="keyword">class</span>-&gt;<span class="title">rq_offline</span>(<span class="title">rq</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cpumask_clear_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span><br><span class="line">		rq-&gt;online = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * used to mark begin/end of suspend/resume:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_cpus_frozen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update cpusets according to cpu_active mask.  If cpusets are</span></span><br><span class="line"><span class="comment"> * disabled, cpuset_update_active_cpus() becomes a simple wrapper</span></span><br><span class="line"><span class="comment"> * around partition_sched_domains().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we come here as part of a suspend/resume, don't touch cpusets because we</span></span><br><span class="line"><span class="comment"> * want to restore it back to its original state upon resume anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpuset_cpu_active</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cpuhp_tasks_frozen) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * num_cpus_frozen tracks how many CPUs are involved in suspend</span></span><br><span class="line"><span class="comment">		 * resume sequence. As long as this is not the last online</span></span><br><span class="line"><span class="comment">		 * operation in the resume sequence, just build a single sched</span></span><br><span class="line"><span class="comment">		 * domain, ignoring cpusets.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		partition_sched_domains(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (--num_cpus_frozen)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is the last CPU online operation. So fall through and</span></span><br><span class="line"><span class="comment">		 * restore the original sched domains by considering the</span></span><br><span class="line"><span class="comment">		 * cpuset configurations.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpuset_force_rebuild();</span><br><span class="line">	&#125;</span><br><span class="line">	cpuset_update_active_cpus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpuset_cpu_inactive</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cpuhp_tasks_frozen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_cpu_busy(cpu))</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		cpuset_update_active_cpus();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		num_cpus_frozen++;</span><br><span class="line">		partition_sched_domains(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_activate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_SMT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When going up, increment the number of cores with SMT present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_weight(cpu_smt_mask(cpu)) == <span class="number">2</span>)</span><br><span class="line">		static_branch_inc_cpuslocked(&amp;sched_smt_present);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_smp_initialized) &#123;</span><br><span class="line">		sched_domains_numa_masks_set(cpu);</span><br><span class="line">		cpuset_cpu_active();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Put the rq online, if not already. This happens:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1) In the early boot process, because we build the real domains</span></span><br><span class="line"><span class="comment">	 *    after all CPUs have been brought up.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2) At runtime, if cpuset_cpu_active() fails to rebuild the</span></span><br><span class="line"><span class="comment">	 *    domains.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rd) &#123;</span><br><span class="line">		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span><br><span class="line">		set_rq_online(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_deactivate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	set_cpu_active(cpu, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We've cleared cpu_active_mask, wait for all preempt-disabled and RCU</span></span><br><span class="line"><span class="comment">	 * users of this state to go away such that all new such users will</span></span><br><span class="line"><span class="comment">	 * observe it.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Do sync before park smpboot threads to take care the rcu boost case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	synchronize_rcu();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_SMT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When going down, decrement the number of cores with SMT present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_weight(cpu_smt_mask(cpu)) == <span class="number">2</span>)</span><br><span class="line">		static_branch_dec_cpuslocked(&amp;sched_smt_present);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sched_smp_initialized)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = cpuset_cpu_inactive(cpu);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	sched_domains_numa_masks_clear(cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_rq_cpu_starting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	rq-&gt;calc_load_update = calc_load_update;</span><br><span class="line">	update_max_interval();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_starting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_rq_cpu_starting(cpu);</span><br><span class="line">	sched_tick_start(cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_dying</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle pending wakeups and then migrate everything off */</span></span><br><span class="line">	sched_tick_stop(cpu);</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rd) &#123;</span><br><span class="line">		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span><br><span class="line">		set_rq_offline(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	migrate_tasks(rq, &amp;rf);</span><br><span class="line">	BUG_ON(rq-&gt;nr_running != <span class="number">1</span>);</span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	calc_load_migrate(rq);</span><br><span class="line">	update_max_interval();</span><br><span class="line">	nohz_balance_exit_idle(rq);</span><br><span class="line">	hrtick_clear(rq);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init_smp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_init_numa();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There's no userspace yet to cause hotplug operations; hence all the</span></span><br><span class="line"><span class="comment">	 * CPU masks are stable and all blatant races in the below code cannot</span></span><br><span class="line"><span class="comment">	 * happen.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;sched_domains_mutex);</span><br><span class="line">	sched_init_domains(cpu_active_mask);</span><br><span class="line">	mutex_unlock(&amp;sched_domains_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Move init over to a non-isolated CPU */</span></span><br><span class="line">	<span class="keyword">if</span> (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) &lt; <span class="number">0</span>)</span><br><span class="line">		BUG();</span><br><span class="line">	sched_init_granularity();</span><br><span class="line"></span><br><span class="line">	init_sched_rt_class();</span><br><span class="line">	init_sched_dl_class();</span><br><span class="line"></span><br><span class="line">	sched_smp_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">migration_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_cpu_starting(smp_processor_id());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(migration_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init_smp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_init_granularity();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_sched_functions</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> in_lock_functions(addr) ||</span><br><span class="line">		(addr &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__sched_text_start</span><br><span class="line">		&amp;&amp; addr &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__sched_text_end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default task group.</span></span><br><span class="line"><span class="comment"> * Every task in system belongs to this group at bootup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> <span class="title">root_task_group</span>;</span></span><br><span class="line">LIST_HEAD(task_groups);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cacheline aligned slab cache for task_group */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_group_cache</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">cpumask_var_t</span>, load_balance_mask);</span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">cpumask_var_t</span>, select_idle_mask);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	wait_bit_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	ptr += <span class="number">2</span> * nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	ptr += <span class="number">2</span> * nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)kzalloc(ptr, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">		root_task_group.se = (struct sched_entity **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.cfs_rq = (struct cfs_rq **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.shares = ROOT_TASK_GROUP_LOAD;</span><br><span class="line">		init_cfs_bandwidth(&amp;root_task_group.cfs_bandwidth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		root_task_group.rt_se = (struct sched_rt_entity **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.rt_rq = (struct rt_rq **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUMASK_OFFSTACK</span></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		per_cpu(load_balance_mask, i) = (<span class="keyword">cpumask_var_t</span>)kzalloc_node(</span><br><span class="line">			cpumask_size(), GFP_KERNEL, cpu_to_node(i));</span><br><span class="line">		per_cpu(select_idle_mask, i) = (<span class="keyword">cpumask_var_t</span>)kzalloc_node(</span><br><span class="line">			cpumask_size(), GFP_KERNEL, cpu_to_node(i));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CPUMASK_OFFSTACK */</span></span></span><br><span class="line"></span><br><span class="line">	init_rt_bandwidth(&amp;def_rt_bandwidth, global_rt_period(), global_rt_runtime());</span><br><span class="line">	init_dl_bandwidth(&amp;def_dl_bandwidth, global_rt_period(), global_rt_runtime());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	init_defrootdomain();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	init_rt_bandwidth(&amp;root_task_group.rt_bandwidth,</span><br><span class="line">			global_rt_period(), global_rt_runtime());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">	task_group_cache = KMEM_CACHE(task_group, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	list_add(&amp;root_task_group.<span class="built_in">list</span>, &amp;task_groups);</span><br><span class="line">	INIT_LIST_HEAD(&amp;root_task_group.children);</span><br><span class="line">	INIT_LIST_HEAD(&amp;root_task_group.siblings);</span><br><span class="line">	autogroup_init(&amp;init_task);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CGROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">		rq = cpu_rq(i);</span><br><span class="line">		raw_spin_lock_init(&amp;rq-&gt;lock);</span><br><span class="line">		rq-&gt;nr_running = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;calc_load_active = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;calc_load_update = jiffies + LOAD_FREQ;</span><br><span class="line">		init_cfs_rq(&amp;rq-&gt;cfs);</span><br><span class="line">		init_rt_rq(&amp;rq-&gt;rt);</span><br><span class="line">		init_dl_rq(&amp;rq-&gt;dl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;rq-&gt;leaf_cfs_rq_list);</span><br><span class="line">		rq-&gt;tmp_alone_branch = &amp;rq-&gt;leaf_cfs_rq_list;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * How much CPU bandwidth does root_task_group get?</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In case of task-groups formed thr' the cgroup filesystem, it</span></span><br><span class="line"><span class="comment">		 * gets 100% of the CPU resources in the system. This overall</span></span><br><span class="line"><span class="comment">		 * system CPU resource is divided among the tasks of</span></span><br><span class="line"><span class="comment">		 * root_task_group and its child task-groups in a fair manner,</span></span><br><span class="line"><span class="comment">		 * based on each entity's (task or task-group's) weight</span></span><br><span class="line"><span class="comment">		 * (se-&gt;load.weight).</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In other words, if root_task_group has 10 tasks of weight</span></span><br><span class="line"><span class="comment">		 * 1024) and two child groups A0 and A1 (of weight 1024 each),</span></span><br><span class="line"><span class="comment">		 * then A0's share of the CPU resource is:</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We achieve this by letting root_task_group's tasks sit</span></span><br><span class="line"><span class="comment">		 * directly in rq-&gt;cfs (i.e root_task_group-&gt;se[] = NULL).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		init_tg_cfs_entry(&amp;root_task_group, &amp;rq-&gt;cfs, <span class="literal">NULL</span>, i, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">		rq-&gt;rt.rt_runtime = def_rt_bandwidth.rt_runtime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		init_tg_rt_entry(&amp;root_task_group, &amp;rq-&gt;rt, <span class="literal">NULL</span>, i, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		rq-&gt;sd = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;rd = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;cpu_capacity = rq-&gt;cpu_capacity_orig = SCHED_CAPACITY_SCALE;</span><br><span class="line">		rq-&gt;balance_callback = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;active_balance = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;next_balance = jiffies;</span><br><span class="line">		rq-&gt;push_cpu = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;cpu = i;</span><br><span class="line">		rq-&gt;online = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;idle_stamp = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;avg_idle = <span class="number">2</span>*sysctl_sched_migration_cost;</span><br><span class="line">		rq-&gt;max_idle_balance_cost = sysctl_sched_migration_cost;</span><br><span class="line"></span><br><span class="line">		INIT_LIST_HEAD(&amp;rq-&gt;cfs_tasks);</span><br><span class="line"></span><br><span class="line">		rq_attach_root(rq, &amp;def_root_domain);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">		rq-&gt;last_blocked_load_update_tick = jiffies;</span><br><span class="line">		atomic_set(&amp;rq-&gt;nohz_flags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		rq_csd_init(rq, &amp;rq-&gt;nohz_csd, nohz_csd_func);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">		hrtick_rq_init(rq);</span><br><span class="line">		atomic_set(&amp;rq-&gt;nr_iowait, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set_load_weight(&amp;init_task, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot idle thread does lazy MMU switching as well:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mmgrab(&amp;init_mm);</span><br><span class="line">	enter_lazy_tlb(&amp;init_mm, current);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make us the idle thread. Technically, schedule() should not be</span></span><br><span class="line"><span class="comment">	 * called from this thread, however somewhere below it might be,</span></span><br><span class="line"><span class="comment">	 * but because we are the idle thread, we just pick up running again</span></span><br><span class="line"><span class="comment">	 * when this runqueue becomes "idle".</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_idle(current, smp_processor_id());</span><br><span class="line"></span><br><span class="line">	calc_load_update = jiffies + LOAD_FREQ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	idle_thread_set_boot_cpu();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_sched_fair_class();</span><br><span class="line"></span><br><span class="line">	init_schedstats();</span><br><span class="line"></span><br><span class="line">	psi_init();</span><br><span class="line"></span><br><span class="line">	init_uclamp();</span><br><span class="line"></span><br><span class="line">	scheduler_running = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">preempt_count_equals</span><span class="params">(<span class="keyword">int</span> preempt_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nested = preempt_count() + rcu_preempt_depth();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (nested == preempt_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __might_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Blocking primitives will set (and therefore destroy) current-&gt;state,</span></span><br><span class="line"><span class="comment">	 * since we will exit with TASK_RUNNING make sure we enter with it,</span></span><br><span class="line"><span class="comment">	 * otherwise we will destroy state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ONCE(current-&gt;state != TASK_RUNNING &amp;&amp; current-&gt;task_state_change,</span><br><span class="line">			<span class="string">"do not call blocking ops when !TASK_RUNNING; "</span></span><br><span class="line">			<span class="string">"state=%lx set at [&lt;%p&gt;] %pS\n"</span>,</span><br><span class="line">			current-&gt;state,</span><br><span class="line">			(<span class="keyword">void</span> *)current-&gt;task_state_change,</span><br><span class="line">			(<span class="keyword">void</span> *)current-&gt;task_state_change);</span><br><span class="line"></span><br><span class="line">	___might_sleep(file, line, preempt_offset);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__might_sleep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ___might_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Ratelimiting timestamp: */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> prev_jiffy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* WARN_ON_ONCE() by default, no rate limit required: */</span></span><br><span class="line">	rcu_sleep_check();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((preempt_count_equals(preempt_offset) &amp;&amp; !irqs_disabled() &amp;&amp;</span><br><span class="line">	     !is_idle_task(current) &amp;&amp; !current-&gt;non_block_count) ||</span><br><span class="line">	    system_state == SYSTEM_BOOTING || system_state &gt; SYSTEM_RUNNING ||</span><br><span class="line">	    oops_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time_before(jiffies, prev_jiffy + HZ) &amp;&amp; prev_jiffy)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	prev_jiffy = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save this before calling printk(), since that will clobber it: */</span></span><br><span class="line">	preempt_disable_ip = get_preempt_disable_ip(current);</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR</span><br><span class="line">		<span class="string">"BUG: sleeping function called from invalid context at %s:%d\n"</span>,</span><br><span class="line">			file, line);</span><br><span class="line">	printk(KERN_ERR</span><br><span class="line">		<span class="string">"in_atomic(): %d, irqs_disabled(): %d, non_block: %d, pid: %d, name: %s\n"</span>,</span><br><span class="line">			in_atomic(), irqs_disabled(), current-&gt;non_block_count,</span><br><span class="line">			current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_stack_end_corrupted(current))</span><br><span class="line">		printk(KERN_EMERG <span class="string">"Thread overran stack, or stack corrupted\n"</span>);</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(current);</span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		print_irqtrace_events(current);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_PREEMPT)</span><br><span class="line">	    &amp;&amp; !preempt_count_equals(preempt_offset)) &#123;</span><br><span class="line">		pr_err(<span class="string">"Preemption disabled at:"</span>);</span><br><span class="line">		print_ip_sym(KERN_ERR, preempt_disable_ip);</span><br><span class="line">	&#125;</span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(___might_sleep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __cant_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> prev_jiffy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_COUNT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (preempt_count() &gt; preempt_offset)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time_before(jiffies, prev_jiffy + HZ) &amp;&amp; prev_jiffy)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	prev_jiffy = jiffies;</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR <span class="string">"BUG: assuming atomic context at %s:%d\n"</span>, file, line);</span><br><span class="line">	printk(KERN_ERR <span class="string">"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n"</span>,</span><br><span class="line">			in_atomic(), irqs_disabled(),</span><br><span class="line">			current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(current);</span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__cant_sleep);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MAGIC_SYSRQ</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize_rt_tasks</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span> = &#123;</span></span><br><span class="line">		.sched_policy = SCHED_NORMAL,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;tasklist_lock);</span><br><span class="line">	for_each_process_thread(g, p) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Only normalize user tasks:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		p-&gt;se.exec_start = <span class="number">0</span>;</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.wait_start,  <span class="number">0</span>);</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.sleep_start, <span class="number">0</span>);</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.block_start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dl_task(p) &amp;&amp; !rt_task(p)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Renice negative nice level userspace</span></span><br><span class="line"><span class="comment">			 * tasks back to 0:</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (task_nice(p) &lt; <span class="number">0</span>)</span><br><span class="line">				set_user_nice(p, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		__sched_setscheduler(p, &amp;attr, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_MAGIC_SYSRQ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These functions are only useful for the IA64 MCA handling, or kdb.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They can only be called when the whole system has been</span></span><br><span class="line"><span class="comment"> * stopped - every CPU needs to be quiescent, and no scheduling</span></span><br><span class="line"><span class="comment"> * activity can take place. Using them for anything else would</span></span><br><span class="line"><span class="comment"> * be a serious bug, and as a result, they aren't even visible</span></span><br><span class="line"><span class="comment"> * under any other configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * curr_task - return the current task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The current task for @cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">curr_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_curr(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA64</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ia64_set_curr_task - set the current task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> * @p: the task pointer to set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: This function must only be used when non-maskable interrupts</span></span><br><span class="line"><span class="comment"> * are serviced on a separate stack. It allows the architecture to switch the</span></span><br><span class="line"><span class="comment"> * notion of the current task on a CPU in a non-blocking manner. This function</span></span><br><span class="line"><span class="comment"> * must be called with all CPU's synchronized, and interrupts disabled, the</span></span><br><span class="line"><span class="comment"> * and caller must save the original value of the current task (see</span></span><br><span class="line"><span class="comment"> * curr_task() above) and restore that value before reenabling interrupts and</span></span><br><span class="line"><span class="comment"> * re-starting the system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ia64_set_curr_task</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_curr(cpu) = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="comment">/* task_group_lock serializes the addition/removal of task groups */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(task_group_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">alloc_uclamp_sched_group</span><span class="params">(struct task_group *tg,</span></span></span><br><span class="line"><span class="function"><span class="params">					    struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;tg-&gt;uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">		tg-&gt;uclamp[clamp_id] = parent-&gt;uclamp[clamp_id];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_free_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	free_fair_sched_group(tg);</span><br><span class="line">	free_rt_sched_group(tg);</span><br><span class="line">	autogroup_free(tg);</span><br><span class="line">	kmem_cache_free(task_group_cache, tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate runqueue etc for a new task group */</span></span><br><span class="line"><span class="function">struct task_group *<span class="title">sched_create_group</span><span class="params">(struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	tg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (!tg)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_fair_sched_group(tg, parent))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_rt_sched_group(tg, parent))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	alloc_uclamp_sched_group(tg, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	sched_free_group(tg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_online_group</span><span class="params">(struct task_group *tg, struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;task_group_lock, flags);</span><br><span class="line">	list_add_rcu(&amp;tg-&gt;<span class="built_in">list</span>, &amp;task_groups);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Root should already exist: */</span></span><br><span class="line">	WARN_ON(!parent);</span><br><span class="line"></span><br><span class="line">	tg-&gt;parent = parent;</span><br><span class="line">	INIT_LIST_HEAD(&amp;tg-&gt;children);</span><br><span class="line">	list_add_rcu(&amp;tg-&gt;siblings, &amp;parent-&gt;children);</span><br><span class="line">	spin_unlock_irqrestore(&amp;task_group_lock, flags);</span><br><span class="line"></span><br><span class="line">	online_fair_sched_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rcu callback to free various structures associated with a task group */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_free_group_rcu</span><span class="params">(struct rcu_head *rhp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Now it should be safe to free those cfs_rqs: */</span></span><br><span class="line">	sched_free_group(container_of(rhp, struct task_group, rcu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_destroy_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Wait for possible concurrent references to cfs_rqs complete: */</span></span><br><span class="line">	call_rcu(&amp;tg-&gt;rcu, sched_free_group_rcu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_offline_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End participation in shares distribution: */</span></span><br><span class="line">	unregister_fair_sched_group(tg);</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;task_group_lock, flags);</span><br><span class="line">	list_del_rcu(&amp;tg-&gt;<span class="built_in">list</span>);</span><br><span class="line">	list_del_rcu(&amp;tg-&gt;siblings);</span><br><span class="line">	spin_unlock_irqrestore(&amp;task_group_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_change_group</span><span class="params">(struct task_struct *tsk, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All callers are synchronized by task_rq_lock(); we do not use RCU</span></span><br><span class="line"><span class="comment">	 * which is pointless here. Thus, we pass "true" to task_css_check()</span></span><br><span class="line"><span class="comment">	 * to prevent lockdep warnings.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tg = container_of(task_css_check(tsk, cpu_cgrp_id, <span class="literal">true</span>),</span><br><span class="line">			  struct task_group, css);</span><br><span class="line">	tg = autogroup_task_group(tsk, tg);</span><br><span class="line">	tsk-&gt;sched_task_group = tg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;sched_class-&gt;task_change_group)</span><br><span class="line">		tsk-&gt;sched_class-&gt;task_change_group(tsk, type);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">		set_task_rq(tsk, task_cpu(tsk));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change task's runqueue when it moves between groups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller of this function should have put the task in its new group by</span></span><br><span class="line"><span class="comment"> * now. This function just updates tsk-&gt;se.cfs_rq and tsk-&gt;se.parent to reflect</span></span><br><span class="line"><span class="comment"> * its new group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_move_task</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> queued, running, queue_flags =</span><br><span class="line">		DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(tsk, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	running = task_current(rq, tsk);</span><br><span class="line">	queued = task_on_rq_queued(tsk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, tsk, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, tsk);</span><br><span class="line"></span><br><span class="line">	sched_change_group(tsk, TASK_MOVE_GROUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, tsk, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running) &#123;</span><br><span class="line">		set_next_task(rq, tsk);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * After changing group, the running task may have joined a</span></span><br><span class="line"><span class="comment">		 * throttled one but it's still the running task. Trigger a</span></span><br><span class="line"><span class="comment">		 * resched to make sure that task can still run.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		resched_curr(rq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, tsk, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_group *<span class="title">css_tg</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> css ? container_of(css, struct task_group, css) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *</span></span><br><span class="line"><span class="class"><span class="title">cpu_cgroup_css_alloc</span>(<span class="title">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">parent_css</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span> = <span class="title">css_tg</span>(<span class="title">parent_css</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">		<span class="comment">/* This is early initialization for the top cgroup */</span></span><br><span class="line">		<span class="keyword">return</span> &amp;root_task_group.css;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tg = sched_create_group(parent);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tg))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;tg-&gt;css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expose task group only after completing cgroup initialization */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cgroup_css_online</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span> = <span class="title">css_tg</span>(<span class="title">css</span>-&gt;<span class="title">parent</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		sched_online_group(tg, parent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="comment">/* Propagate the effective uclamp value for the new group */</span></span><br><span class="line">	cpu_util_update_eff(css);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_css_released</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	sched_offline_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_css_free</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Relies on the RCU grace period between css_released() and this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_free_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called before wake_up_new_task(), therefore we really only</span></span><br><span class="line"><span class="comment"> * have to set its group bits, all the other stuff does not apply.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_fork</span><span class="params">(struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(task, &amp;rf);</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	sched_change_group(task, TASK_SET_GROUP);</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, task, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cgroup_can_attach</span><span class="params">(struct cgroup_taskset *tset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">css</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cgroup_taskset_for_each(task, css, tset) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		<span class="keyword">if</span> (!sched_rt_can_attach(css_tg(css), task))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Serialize against wake_up_new_task() such that if its</span></span><br><span class="line"><span class="comment">		 * running, we're sure to observe its full state.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		raw_spin_lock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Avoid calling sched_move_task() before wake_up_new_task()</span></span><br><span class="line"><span class="comment">		 * has happened. This would lead to problems with PELT, due to</span></span><br><span class="line"><span class="comment">		 * move wanting to detach+attach while we're not attached yet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (task-&gt;state == TASK_NEW)</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_attach</span><span class="params">(struct cgroup_taskset *tset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">css</span>;</span></span><br><span class="line"></span><br><span class="line">	cgroup_taskset_for_each(task, css, tset)</span><br><span class="line">		sched_move_task(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_util_update_eff</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">top_css</span> = <span class="title">css</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> eff[UCLAMP_CNT];</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> clamps;</span><br><span class="line"></span><br><span class="line">	css_for_each_descendant_pre(css, top_css) &#123;</span><br><span class="line">		uc_parent = css_tg(css)-&gt;parent</span><br><span class="line">			? css_tg(css)-&gt;parent-&gt;uclamp : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="comment">/* Assume effective clamps matches requested clamps */</span></span><br><span class="line">			eff[clamp_id] = css_tg(css)-&gt;uclamp_req[clamp_id].value;</span><br><span class="line">			<span class="comment">/* Cap effective clamps with parent's effective clamps */</span></span><br><span class="line">			<span class="keyword">if</span> (uc_parent &amp;&amp;</span><br><span class="line">			    eff[clamp_id] &gt; uc_parent[clamp_id].value) &#123;</span><br><span class="line">				eff[clamp_id] = uc_parent[clamp_id].value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Ensure protection is always capped by limit */</span></span><br><span class="line">		eff[UCLAMP_MIN] = min(eff[UCLAMP_MIN], eff[UCLAMP_MAX]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Propagate most restrictive effective clamps */</span></span><br><span class="line">		clamps = <span class="number">0x0</span>;</span><br><span class="line">		uc_se = css_tg(css)-&gt;uclamp;</span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="keyword">if</span> (eff[clamp_id] == uc_se[clamp_id].value)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			uc_se[clamp_id].value = eff[clamp_id];</span><br><span class="line">			uc_se[clamp_id].bucket_id = uclamp_bucket_id(eff[clamp_id]);</span><br><span class="line">			clamps |= (<span class="number">0x1</span> &lt;&lt; clamp_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!clamps) &#123;</span><br><span class="line">			css = css_rightmost_descendant(css);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Immediately update descendants RUNNABLE tasks */</span></span><br><span class="line">		uclamp_update_active_tasks(css, clamps);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer 10^N with a given N exponent by casting to integer the literal "1eN"</span></span><br><span class="line"><span class="comment"> * C expression. Since there is no way to convert a macro argument (N) into a</span></span><br><span class="line"><span class="comment"> * character constant, use two levels of macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POW10(exp) ((unsigned int)1e##exp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POW10(exp) _POW10(exp)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_PERCENT_SHIFT	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_PERCENT_SCALE	(100 * POW10(UCLAMP_PERCENT_SHIFT))</span></span><br><span class="line">	s64 percent;</span><br><span class="line">	u64 util;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span></span></span><br><span class="line"><span class="class"><span class="title">capacity_from_percent</span>(<span class="title">char</span> *<span class="title">buf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> <span class="title">req</span> = &#123;</span></span><br><span class="line">		.percent = UCLAMP_PERCENT_SCALE,</span><br><span class="line">		.util = SCHED_CAPACITY_SCALE,</span><br><span class="line">		.ret = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	buf = strim(buf);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">"max"</span>)) &#123;</span><br><span class="line">		req.ret = cgroup_parse_float(buf, UCLAMP_PERCENT_SHIFT,</span><br><span class="line">					     &amp;req.percent);</span><br><span class="line">		<span class="keyword">if</span> (req.ret)</span><br><span class="line">			<span class="keyword">return</span> req;</span><br><span class="line">		<span class="keyword">if</span> ((u64)req.percent &gt; UCLAMP_PERCENT_SCALE) &#123;</span><br><span class="line">			req.ret = -ERANGE;</span><br><span class="line">			<span class="keyword">return</span> req;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req.util = req.percent &lt;&lt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">		req.util = DIV_ROUND_CLOSEST_ULL(req.util, UCLAMP_PERCENT_SCALE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_write</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">size_t</span> nbytes, <span class="keyword">loff_t</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> <span class="title">req</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	req = capacity_from_percent(buf);</span><br><span class="line">	<span class="keyword">if</span> (req.ret)</span><br><span class="line">		<span class="keyword">return</span> req.ret;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;uclamp_mutex);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	tg = css_tg(of_css(of));</span><br><span class="line">	<span class="keyword">if</span> (tg-&gt;uclamp_req[clamp_id].value != req.util)</span><br><span class="line">		uclamp_se_set(&amp;tg-&gt;uclamp_req[clamp_id], req.util, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because of not recoverable conversion rounding we keep track of the</span></span><br><span class="line"><span class="comment">	 * exact requested value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tg-&gt;uclamp_pct[clamp_id] = req.percent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update effective clamps to track the most restrictive value */</span></span><br><span class="line">	cpu_util_update_eff(of_css(of));</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	mutex_unlock(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_min_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_max_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpu_uclamp_print</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line">	u64 util_clamp;</span><br><span class="line">	u64 percent;</span><br><span class="line">	u32 rem;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	tg = css_tg(seq_css(sf));</span><br><span class="line">	util_clamp = tg-&gt;uclamp_req[clamp_id].value;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util_clamp == SCHED_CAPACITY_SCALE) &#123;</span><br><span class="line">		seq_puts(sf, <span class="string">"max\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	percent = tg-&gt;uclamp_pct[clamp_id];</span><br><span class="line">	percent = div_u64_rem(percent, POW10(UCLAMP_PERCENT_SHIFT), &amp;rem);</span><br><span class="line">	seq_printf(sf, <span class="string">"%llu.%0*u\n"</span>, percent, UCLAMP_PERCENT_SHIFT, rem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_uclamp_min_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_uclamp_print(sf, UCLAMP_MIN);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_uclamp_max_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_uclamp_print(sf, UCLAMP_MAX);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_UCLAMP_TASK_GROUP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_shares_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cftype, u64 shareval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (shareval &gt; scale_load_down(ULONG_MAX))</span><br><span class="line">		shareval = MAX_SHARES;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(shareval));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_shares_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (u64) scale_load_down(tg-&gt;shares);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(cfs_constraints_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u64 max_cfs_quota_period = <span class="number">1</span> * NSEC_PER_SEC; <span class="comment">/* 1s */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 min_cfs_quota_period = <span class="number">1</span> * NSEC_PER_MSEC; <span class="comment">/* 1ms */</span></span><br><span class="line"><span class="comment">/* More than 203 days if BW_SHIFT equals 20. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 max_cfs_runtime = MAX_BW * NSEC_PER_USEC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_bandwidth</span><span class="params">(struct task_group *tg, u64 period, u64 quota)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, ret = <span class="number">0</span>, runtime_enabled, runtime_was_enabled;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg == &amp;root_task_group)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we have at some amount of bandwidth every period.  This is</span></span><br><span class="line"><span class="comment">	 * to prevent reaching a state of large arrears when throttled via</span></span><br><span class="line"><span class="comment">	 * entity_tick() resulting in prolonged exit starvation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (quota &lt; min_cfs_quota_period || period &lt; min_cfs_quota_period)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Likewise, bound things on the otherside by preventing insane quota</span></span><br><span class="line"><span class="comment">	 * periods.  This also allows us to normalize in computing quota</span></span><br><span class="line"><span class="comment">	 * feasibility.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (period &gt; max_cfs_quota_period)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bound quota to defend quota against overflow during bandwidth shift.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (quota != RUNTIME_INF &amp;&amp; quota &gt; max_cfs_runtime)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prevent race between setting of cfs_rq-&gt;runtime_enabled and</span></span><br><span class="line"><span class="comment">	 * unthrottle_offline_cfs_rqs().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	get_online_cpus();</span><br><span class="line">	mutex_lock(&amp;cfs_constraints_mutex);</span><br><span class="line">	ret = __cfs_schedulable(tg, period, quota);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	runtime_enabled = quota != RUNTIME_INF;</span><br><span class="line">	runtime_was_enabled = cfs_b-&gt;quota != RUNTIME_INF;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we need to toggle cfs_bandwidth_used, off-&gt;on must occur</span></span><br><span class="line"><span class="comment">	 * before making related changes, and on-&gt;off must occur afterwards</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (runtime_enabled &amp;&amp; !runtime_was_enabled)</span><br><span class="line">		cfs_bandwidth_usage_inc();</span><br><span class="line">	raw_spin_lock_irq(&amp;cfs_b-&gt;lock);</span><br><span class="line">	cfs_b-&gt;period = ns_to_ktime(period);</span><br><span class="line">	cfs_b-&gt;quota = quota;</span><br><span class="line"></span><br><span class="line">	__refill_cfs_bandwidth_runtime(cfs_b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restart the period timer (if active) to handle new period expiry: */</span></span><br><span class="line">	<span class="keyword">if</span> (runtime_enabled)</span><br><span class="line">		start_cfs_bandwidth(cfs_b);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irq(&amp;cfs_b-&gt;lock);</span><br><span class="line"></span><br><span class="line">	for_each_online_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> = <span class="title">tg</span>-&gt;<span class="title">cfs_rq</span>[<span class="title">i</span>];</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">rq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">		rq_lock_irq(rq, &amp;rf);</span><br><span class="line">		cfs_rq-&gt;runtime_enabled = runtime_enabled;</span><br><span class="line">		cfs_rq-&gt;runtime_remaining = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cfs_rq-&gt;throttled)</span><br><span class="line">			unthrottle_cfs_rq(cfs_rq);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (runtime_was_enabled &amp;&amp; !runtime_enabled)</span><br><span class="line">		cfs_bandwidth_usage_dec();</span><br><span class="line">out_unlock:</span><br><span class="line">	mutex_unlock(&amp;cfs_constraints_mutex);</span><br><span class="line">	put_online_cpus();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_quota</span><span class="params">(struct task_group *tg, <span class="keyword">long</span> cfs_quota_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	period = ktime_to_ns(tg-&gt;cfs_bandwidth.period);</span><br><span class="line">	<span class="keyword">if</span> (cfs_quota_us &lt; <span class="number">0</span>)</span><br><span class="line">		quota = RUNTIME_INF;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((u64)cfs_quota_us &lt;= U64_MAX / NSEC_PER_USEC)</span><br><span class="line">		quota = (u64)cfs_quota_us * NSEC_PER_USEC;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">tg_get_cfs_quota</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota_us;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg-&gt;cfs_bandwidth.quota == RUNTIME_INF)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	quota_us = tg-&gt;cfs_bandwidth.quota;</span><br><span class="line">	do_div(quota_us, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> quota_us;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_period</span><span class="params">(struct task_group *tg, <span class="keyword">long</span> cfs_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((u64)cfs_period_us &gt; U64_MAX / NSEC_PER_USEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	period = (u64)cfs_period_us * NSEC_PER_USEC;</span><br><span class="line">	quota = tg-&gt;cfs_bandwidth.quota;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">tg_get_cfs_period</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 cfs_period_us;</span><br><span class="line"></span><br><span class="line">	cfs_period_us = ktime_to_ns(tg-&gt;cfs_bandwidth.period);</span><br><span class="line">	do_div(cfs_period_us, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cfs_period_us;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_cfs_quota_read_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_get_cfs_quota(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_quota_write_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cftype, s64 cfs_quota_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_quota(css_tg(css), cfs_quota_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_cfs_period_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_get_cfs_period(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_period_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cftype, u64 cfs_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_period(css_tg(css), cfs_period_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line">	u64 period, quota;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * normalize group quota/period to be quota/max_period</span></span><br><span class="line"><span class="comment"> * note: units are usecs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">normalize_cfs_quota</span><span class="params">(struct task_group *tg,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cfs_schedulable_data *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg == d-&gt;tg) &#123;</span><br><span class="line">		period = d-&gt;period;</span><br><span class="line">		quota = d-&gt;quota;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		period = tg_get_cfs_period(tg);</span><br><span class="line">		quota = tg_get_cfs_quota(tg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* note: these should typically be equivalent */</span></span><br><span class="line">	<span class="keyword">if</span> (quota == RUNTIME_INF || quota == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> RUNTIME_INF;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> to_ratio(period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_cfs_schedulable_down</span><span class="params">(struct task_group *tg, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> *<span class="title">d</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line">	s64 quota = <span class="number">0</span>, parent_quota = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tg-&gt;parent) &#123;</span><br><span class="line">		quota = RUNTIME_INF;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct cfs_bandwidth *parent_b = &amp;tg-&gt;parent-&gt;cfs_bandwidth;</span><br><span class="line"></span><br><span class="line">		quota = normalize_cfs_quota(tg, d);</span><br><span class="line">		parent_quota = parent_b-&gt;hierarchical_quota;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ensure max(child_quota) &lt;= parent_quota.  On cgroup2,</span></span><br><span class="line"><span class="comment">		 * always take the min.  On cgroup1, only inherit when no</span></span><br><span class="line"><span class="comment">		 * limit is set:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (cgroup_subsys_on_dfl(cpu_cgrp_subsys)) &#123;</span><br><span class="line">			quota = min(quota, parent_quota);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (quota == RUNTIME_INF)</span><br><span class="line">				quota = parent_quota;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (parent_quota != RUNTIME_INF &amp;&amp; quota &gt; parent_quota)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cfs_b-&gt;hierarchical_quota = quota;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> <span class="title">data</span> = &#123;</span></span><br><span class="line">		.tg = tg,</span><br><span class="line">		.period = period,</span><br><span class="line">		.quota = quota,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (quota != RUNTIME_INF) &#123;</span><br><span class="line">		do_div(data.period, NSEC_PER_USEC);</span><br><span class="line">		do_div(data.quota, NSEC_PER_USEC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &amp;data);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_stat_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">seq_css</span>(<span class="title">sf</span>));</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	seq_printf(sf, <span class="string">"nr_periods %d\n"</span>, cfs_b-&gt;nr_periods);</span><br><span class="line">	seq_printf(sf, <span class="string">"nr_throttled %d\n"</span>, cfs_b-&gt;nr_throttled);</span><br><span class="line">	seq_printf(sf, <span class="string">"throttled_time %llu\n"</span>, cfs_b-&gt;throttled_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (schedstat_enabled() &amp;&amp; tg != &amp;root_task_group) &#123;</span><br><span class="line">		u64 ws = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(i)</span><br><span class="line">			ws += schedstat_val(tg-&gt;se[i]-&gt;statistics.wait_sum);</span><br><span class="line"></span><br><span class="line">		seq_printf(sf, <span class="string">"wait_sum %llu\n"</span>, ws);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CFS_BANDWIDTH */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_rt_runtime_write</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cft, s64 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_rt_runtime(css_tg(css), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_rt_runtime_read</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_rt_runtime(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_rt_period_write_uint</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cftype, u64 rt_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_rt_period(css_tg(css), rt_period_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_rt_period_read_uint</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_rt_period(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">cpu_legacy_files</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"shares"</span>,</span><br><span class="line">		.read_u64 = cpu_shares_read_u64,</span><br><span class="line">		.write_u64 = cpu_shares_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"cfs_quota_us"</span>,</span><br><span class="line">		.read_s64 = cpu_cfs_quota_read_s64,</span><br><span class="line">		.write_s64 = cpu_cfs_quota_write_s64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"cfs_period_us"</span>,</span><br><span class="line">		.read_u64 = cpu_cfs_period_read_u64,</span><br><span class="line">		.write_u64 = cpu_cfs_period_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"stat"</span>,</span><br><span class="line">		.seq_show = cpu_cfs_stat_show,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"rt_runtime_us"</span>,</span><br><span class="line">		.read_s64 = cpu_rt_runtime_read,</span><br><span class="line">		.write_s64 = cpu_rt_runtime_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"rt_period_us"</span>,</span><br><span class="line">		.read_u64 = cpu_rt_period_read_uint,</span><br><span class="line">		.write_u64 = cpu_rt_period_write_uint,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.min"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_min_show,</span><br><span class="line">		.write = cpu_uclamp_min_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_max_show,</span><br><span class="line">		.write = cpu_uclamp_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; &#125;	<span class="comment">/* Terminate */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_extra_stat_show</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line">		u64 throttled_usec;</span><br><span class="line"></span><br><span class="line">		throttled_usec = cfs_b-&gt;throttled_time;</span><br><span class="line">		do_div(throttled_usec, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">		seq_printf(sf, <span class="string">"nr_periods %d\n"</span></span><br><span class="line">			   <span class="string">"nr_throttled %d\n"</span></span><br><span class="line">			   <span class="string">"throttled_usec %llu\n"</span>,</span><br><span class="line">			   cfs_b-&gt;nr_periods, cfs_b-&gt;nr_throttled,</span><br><span class="line">			   throttled_usec);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_weight_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">	u64 weight = scale_load_down(tg-&gt;shares);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_weight_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cft, u64 weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cgroup weight knobs should use the common MIN, DFL and MAX</span></span><br><span class="line"><span class="comment">	 * values which are 1, 100 and 10000 respectively.  While it loses</span></span><br><span class="line"><span class="comment">	 * a bit of range on both ends, it maps pretty well onto the shares</span></span><br><span class="line"><span class="comment">	 * value used by scheduler and the round-trip conversions preserve</span></span><br><span class="line"><span class="comment">	 * the original value over the entire range.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (weight &lt; CGROUP_WEIGHT_MIN || weight &gt; CGROUP_WEIGHT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">	weight = DIV_ROUND_CLOSEST_ULL(weight * <span class="number">1024</span>, CGROUP_WEIGHT_DFL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(weight));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_weight_nice_read_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> weight = scale_load_down(css_tg(css)-&gt;shares);</span><br><span class="line">	<span class="keyword">int</span> last_delta = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> prio, delta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find the closest nice value to the current weight */</span></span><br><span class="line">	<span class="keyword">for</span> (prio = <span class="number">0</span>; prio &lt; ARRAY_SIZE(sched_prio_to_weight); prio++) &#123;</span><br><span class="line">		delta = <span class="built_in">abs</span>(sched_prio_to_weight[prio] - weight);</span><br><span class="line">		<span class="keyword">if</span> (delta &gt;= last_delta)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		last_delta = delta;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PRIO_TO_NICE(prio - <span class="number">1</span> + MAX_RT_PRIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_weight_nice_write_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				     struct cftype *cft, s64 nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> weight;</span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nice &lt; MIN_NICE || nice &gt; MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">	idx = NICE_TO_PRIO(nice) - MAX_RT_PRIO;</span><br><span class="line">	idx = array_index_nospec(idx, <span class="number">40</span>);</span><br><span class="line">	weight = sched_prio_to_weight[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(weight));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __maybe_unused <span class="title">cpu_period_quota_print</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">						  <span class="keyword">long</span> period, <span class="keyword">long</span> quota)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (quota &lt; <span class="number">0</span>)</span><br><span class="line">		seq_puts(sf, <span class="string">"max"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		seq_printf(sf, <span class="string">"%ld"</span>, quota);</span><br><span class="line"></span><br><span class="line">	seq_printf(sf, <span class="string">" %ld\n"</span>, period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* caller should put the current value in *@periodp before calling */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __maybe_unused <span class="title">cpu_period_quota_parse</span><span class="params">(<span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">						 u64 *periodp, u64 *quotap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tok[<span class="number">21</span>];	<span class="comment">/* U64_MAX */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sscanf</span>(buf, <span class="string">"%20s %llu"</span>, tok, periodp) &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	*periodp *= NSEC_PER_USEC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sscanf</span>(tok, <span class="string">"%llu"</span>, quotap))</span><br><span class="line">		*quotap *= NSEC_PER_USEC;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tok, <span class="string">"max"</span>))</span><br><span class="line">		*quotap = RUNTIME_INF;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_max_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">seq_css</span>(<span class="title">sf</span>));</span></span><br><span class="line"></span><br><span class="line">	cpu_period_quota_print(sf, tg_get_cfs_period(tg), tg_get_cfs_quota(tg));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_max_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">			     <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">of_css</span>(<span class="title">of</span>));</span></span><br><span class="line">	u64 period = tg_get_cfs_period(tg);</span><br><span class="line">	u64 quota;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = cpu_period_quota_parse(buf, &amp;period, &amp;quota);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		ret = tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">	<span class="keyword">return</span> ret ?: nbytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">cpu_files</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"weight"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.read_u64 = cpu_weight_read_u64,</span><br><span class="line">		.write_u64 = cpu_weight_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"weight.nice"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.read_s64 = cpu_weight_nice_read_s64,</span><br><span class="line">		.write_s64 = cpu_weight_nice_write_s64,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_max_show,</span><br><span class="line">		.write = cpu_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.min"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_min_show,</span><br><span class="line">		.write = cpu_uclamp_min_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_max_show,</span><br><span class="line">		.write = cpu_uclamp_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; &#125;	<span class="comment">/* terminate */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> <span class="title">cpu_cgrp_subsys</span> = &#123;</span></span><br><span class="line">	.css_alloc	= cpu_cgroup_css_alloc,</span><br><span class="line">	.css_online	= cpu_cgroup_css_online,</span><br><span class="line">	.css_released	= cpu_cgroup_css_released,</span><br><span class="line">	.css_free	= cpu_cgroup_css_free,</span><br><span class="line">	.css_extra_stat_show = cpu_extra_stat_show,</span><br><span class="line">	.fork		= cpu_cgroup_fork,</span><br><span class="line">	.can_attach	= cpu_cgroup_can_attach,</span><br><span class="line">	.attach		= cpu_cgroup_attach,</span><br><span class="line">	.legacy_cftypes	= cpu_legacy_files,</span><br><span class="line">	.dfl_cftypes	= cpu_files,</span><br><span class="line">	.early_init	= <span class="literal">true</span>,</span><br><span class="line">	.threaded	= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_CGROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_cpu_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">"Task dump for CPU %d:\n"</span>, cpu);</span><br><span class="line">	sched_show_task(cpu_curr(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class="line"><span class="comment"> * nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class="line"><span class="comment"> * nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class="line"><span class="comment"> * that remained on nice 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The "10% effect" is relative and cumulative: from _any_ nice level,</span></span><br><span class="line"><span class="comment"> * if you go up 1 level, it's -10% CPU usage, if you go down 1 level</span></span><br><span class="line"><span class="comment"> * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class="line"><span class="comment"> * If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class="line"><span class="comment"> * the relative distance between them is ~25%.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sched_prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inverse (2^32/x) values of the sched_prio_to_weight[] array, precalculated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In cases where the weight does not change often, we can use the</span></span><br><span class="line"><span class="comment"> * precalculated inverse to speed up arithmetics by turning divisions</span></span><br><span class="line"><span class="comment"> * into multiplications:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> u32 sched_prio_to_wmult[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">48388</span>,     <span class="number">59856</span>,     <span class="number">76040</span>,     <span class="number">92818</span>,    <span class="number">118348</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>    <span class="number">147320</span>,    <span class="number">184698</span>,    <span class="number">229616</span>,    <span class="number">287308</span>,    <span class="number">360437</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>    <span class="number">449829</span>,    <span class="number">563644</span>,    <span class="number">704093</span>,    <span class="number">875809</span>,   <span class="number">1099582</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>   <span class="number">1376151</span>,   <span class="number">1717300</span>,   <span class="number">2157191</span>,   <span class="number">2708050</span>,   <span class="number">3363326</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>   <span class="number">4194304</span>,   <span class="number">5237765</span>,   <span class="number">6557202</span>,   <span class="number">8165337</span>,  <span class="number">10153587</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>  <span class="number">12820798</span>,  <span class="number">15790321</span>,  <span class="number">19976592</span>,  <span class="number">24970740</span>,  <span class="number">31350126</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>  <span class="number">39045157</span>,  <span class="number">49367440</span>,  <span class="number">61356676</span>,  <span class="number">76695844</span>,  <span class="number">95443717</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span> <span class="number">119304647</span>, <span class="number">148102320</span>, <span class="number">186737708</span>, <span class="number">238609294</span>, <span class="number">286331153</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CREATE_TRACE_POINTS</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="https://ae01.alicdn.com/kf/HTB1AlvVXk9E3KVjSZFr7610UVXaw.png" alt="iBoy wechat" style="width: 150px; max-width: 100%;">
  <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://ae01.alicdn.com/kf/HTB1eKnGXkWE3KVjSZSy760ocXXah.png" alt="iBoy 支持作者">
        <p>支持作者</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>iBoy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.iboy.tech/post/2783.html" title="Linux调度算法">https://blog.iboy.tech/post/2783.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/post/43648.html" rel="next" title="IDEA快捷键">
                  <i class="fa fa-chevron-left"></i> IDEA快捷键
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/post/1507.html" rel="prev" title="PlantUML使用笔记">
                  PlantUML使用笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NDI4OS8yMDgyMQ=="></div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="iBoy"
    src="https://ae01.alicdn.com/kf/HTB1pZi7XlCw3KVjSZFu763AOpXa0.png">
  <p class="site-author-name" itemprop="name">iBoy</p>
  <div class="site-description" itemprop="description">知道的越多，不知道的越多...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
      
<!--音乐播放器-->

           <div >
              <iframe frameborder="no" style="margin-top:25px;" border="0" marginwidth="0" marginheight="0" width="210" height="110" src="//music.163.com/outchain/player?type=2&id=479850552&auto=0&height=66"></iframe>
           </div>



<!--标签云-->

<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Celery/" rel="tag">Celery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coding/" rel="tag">Coding</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask/" rel="tag">Flask</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask-Redis/" rel="tag">Flask-Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask-SQLAlchemy/" rel="tag">Flask-SQLAlchemy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Frp/" rel="tag">Frp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kali/" rel="tag">Kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Miniconda/" rel="tag">Miniconda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Web/" rel="tag">Python Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Supervisor/" rel="tag">Supervisor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trojan/" rel="tag">Trojan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VsCode/" rel="tag">VsCode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frp/" rel="tag">frp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pipenv/" rel="tag">pipenv</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E5%B0%9A/" rel="tag">云尚</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/" rel="tag">公众号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" rel="tag">在线工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/" rel="tag">微信公众号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E7%A0%81%E5%B9%B3%E5%8F%B0/" rel="tag">接码平台</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%94%B6%E8%97%8F/" rel="tag">收藏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9A%91%E6%9C%9F%E7%AD%94%E8%BE%A9/" rel="tag">暑期答辩</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" rel="tag">科学上网</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
    </div>
</div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iBoy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">386k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:51</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js?v=7.4.1.js"></script>

<script src="/js/motion.js?v=7.4.1.js"></script>


<script src="/js/schemes/pisces.js?v=7.4.1.js"></script>


<script src="/js/next-boot.js?v=7.4.1.js"></script>

<script src="/js/bookmark.js?v=7.4.1.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>






  
<script src="/js/local-search.js?v=7.4.1.js"></script>














  

  

  

<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

</body>
</html>
