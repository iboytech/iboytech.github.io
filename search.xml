<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019暑期答辩</title>
    <url>//post/48363.html</url>
    <content><![CDATA[<h1 id="签到回帖情况统计"><a href="#签到回帖情况统计" class="headerlink" title="签到回帖情况统计"></a>签到回帖情况统计</h1><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>杨豪、李靖旖-2019启明星工作室暑期答辩</p><h4 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h4><ol>
<li>IDEA</li>
<li>PyCharm</li>
<li>MySQL8.0</li>
</ol><a id="more"></a>

<h4 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h4><ol>
<li>SpringBoot、MyBatis</li>
<li>JavaScript、jQuery，html，css</li>
<li>Python3</li>
</ol>
<h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><h5 id="设计目的："><a href="#设计目的：" class="headerlink" title="设计目的："></a>设计目的：</h5><pre><code>&lt;u&gt;方便例会总结 ，更加清楚的了解成员的状态目录结构&lt;/u&gt;</code></pre><h4 id="JavaWeb部分"><a href="#JavaWeb部分" class="headerlink" title="JavaWeb部分"></a>JavaWeb部分</h4><h5 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h5><p><img src="https://ae01.alicdn.com/kf/Hdcc1d653c52c4ec1b02f34250c19a079Z.png" alt></p>
<ul>
<li><u>JAVA文件目录说明（java目录）</u>                </li>
</ul>
<table>
<thead>
<tr>
<th>目录命名</th>
<th>文件说明</th>
</tr>
</thead>
<tbody><tr>
<td>config</td>
<td>有各个页面的接口，以及登录的拦截器</td>
</tr>
<tr>
<td>controller</td>
<td>存放controller层的java文件</td>
</tr>
<tr>
<td>dao</td>
<td>MyBatis生成的Mapper文件</td>
</tr>
<tr>
<td>dto</td>
<td>此目录下的实体类没有对应的表，主要是为了作为前端数据展示的媒介</td>
</tr>
<tr>
<td>pojo</td>
<td>MyBatis逆向生成的实体类，在数据库中有相应的表与之对应</td>
</tr>
<tr>
<td>service</td>
<td>service层的相应文件</td>
</tr>
</tbody></table>
<p><img src="https://ae01.alicdn.com/kf/H6d882001c8834cddbd75e8803515625bP.png" alt></p>
<ul>
<li><u>静态资源目录说明（resourcs目录）</u></li>
</ul>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>文件说明</th>
</tr>
</thead>
<tbody><tr>
<td>mapper</td>
<td>存放MyBatis所生成的mapper映射文件</td>
</tr>
<tr>
<td>static&gt;ajax</td>
<td>里面的主要用于前后端数据交互，包含整个项目的ajax实现的js文件</td>
</tr>
<tr>
<td>static&gt;templates</td>
<td>页面HTML文件，只用到了部分，若改变文件名称，需要改变java&gt;config&gt;Page.java中接口对应的名称</td>
</tr>
</tbody></table>
<p><strong>主要功能</strong>：</p>
<ol>
<li>用户的增删改查（分类展示）</li>
<li>回帖以及签到情况的统计（分类展示）</li>
<li>各组周平均签到次数的可视化展示</li>
<li>管理员登录日志的记录功能</li>
</ol>
<h4 id="Pyhon部分："><a href="#Pyhon部分：" class="headerlink" title="Pyhon部分："></a>Pyhon部分：</h4><p><strong>一、所用的库主要有：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fake_useragent&#x3D;&#x3D;0.1.11</span><br><span class="line">PyMySQL&#x3D;&#x3D;0.9.3</span><br><span class="line">requests&#x3D;&#x3D;2.22.0</span><br><span class="line">beautifulsoup4&#x3D;&#x3D;4.8.0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用依赖文件</span><br><span class="line">运行项目之前进入工程目录，在其中执行</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p><strong>二、主要的功能：</strong></p>
<ol>
<li><p>post表和userpost表的增删改查 </p>
</li>
<li><p>sign表的日期获取以及周数的计算 </p>
</li>
</ol>
<p>   ​                </p>
<p>   <strong>三、可能出现的问题：</strong></p>
<pre><code>目前为止脚本已经在服务器上运行了十多天了，基本没出什么错误，但是开学的时候出现了一些报错，以为是特殊情况抛出的异常，没太在意，但是每次执行都会出现这个异常，问题在与回复帖子之后的一段时间之内，并不会显示具体的时间范围，而是显示的是时间范围</code></pre><p>   <img src="https://ae01.alicdn.com/kf/H8e25118f3a264c148f67087769a02c5cj.png" alt></p>
<pre><code>如果想采集精确到分钟的回帖时间这个问题暂时无法解决，但是并不影响数据库中的数据，一段时间之            后报错就会消失</code></pre><h4 id="使用说明与注意事项："><a href="#使用说明与注意事项：" class="headerlink" title="使用说明与注意事项："></a>使用说明与注意事项：</h4><ol>
<li><p>每学期使用之前需要先设置开学的时间才能够使用，回帖情况统计以及签到次数的统计都依赖于开学设置的时间</p>
<p><img src="https://ae01.alicdn.com/kf/H6b898ab682354e0e89858cbb51909d3f5.png" alt></p>
</li>
</ol>
<p>2.特殊情况下，如例会时间改变、签到或论坛服务器故障、或者采集的脚本出现故障都有可能导致统计的结果出现问题</p>
<h4 id="项目不足："><a href="#项目不足：" class="headerlink" title="项目不足："></a>项目不足：</h4><ol>
<li>对于签到详情，在个人上体现的只有每周的签到总数，没有一个星期的每一天的具体签到的时间范围</li>
<li>结果展示大多是以周为单位的，没有实现时间段的选择功能</li>
<li>没做管理员的权限控制</li>
<li>在前后端的有些代码耦合度比较高，没有在最开始就抽象一些方法</li>
</ol>
]]></content>
      <tags>
        <tag>暑期答辩</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpine下使用Docker构建LNMP多站点环境</title>
    <url>//post/44464.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySql的部署</span><br><span class="line">docker pull mysql:5.6</span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -v &#x2F;www&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql --name mysql mysql:5.6</span><br><span class="line">docker exec -it mysql bash</span><br><span class="line">mysql -u root -p</span><br><span class="line">use mysql;</span><br><span class="line">update user set host &#x3D; &quot;%&quot; where user &#x3D; &quot;root&quot;;</span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP的部署</span><br><span class="line">docker run -d -p 9000:9000 -v &#x2F;www&#x2F;php:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php  -v &#x2F;www&#x2F;nginx&#x2F;html:&#x2F;var&#x2F;www --name php --link mysql:mysql  --volumes-from mysql --privileged&#x3D;true cs2ag&#x2F;php5.6-devtest;</span><br><span class="line">docker exec -it php bash;</span><br><span class="line"></span><br><span class="line">docker stop php;</span><br><span class="line">docker rm php;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nginx的部署</span><br><span class="line">docker run -p 80:80  -p 81:81 --name nginx -v &#x2F;www&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;www&#x2F;nginx&#x2F;conf.d&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf  --link php:php  --link mysql:mysql -d nginx:latest;</span><br><span class="line">docker stop nginx;</span><br><span class="line">docker rm nginx;</span><br><span class="line"></span><br><span class="line">docker run -p 80:80  -p 81:81 --name nginx -v &#x2F;www&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;www&#x2F;nginx&#x2F;conf.d&#x2F;default.conf:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf  --link php:php  --link mysql:mysql -d nginx:latest;</span><br><span class="line">docker stop nginx;</span><br><span class="line">docker rm nginx;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 参数解析</span><br><span class="line">-v 将本地磁盘上的php代码挂载到docker 环境中，对应docker的目录是 &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">--name 新建的容器名称 php-with-mysql</span><br><span class="line">--link 链接的容器，链接的容器名称：在该容器中的别名，运行这个容器是，docker中会自动添加一个host识别被链接的容器ip</span><br><span class="line">--privileged&#x3D;true 权限问题</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>64位系统运行32位可执行文件</title>
    <url>//post/undefined.html</url>
    <content><![CDATA[<p>当你执行一个32位程序的时候，你可能会发现提示No such file ordirectory，这就是说明你的64位系统没有安装32位的lib库，如何知道一个程序是32位还是64位呢，也很简单，可以通过readelf来看。呃，如果你确定你执行的是32位程序，而你是64位系统，则出现Nosuch file or directory错误就是因为你缺少了32位的库文件。解决方法也很简单：</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -a </span><br><span class="line">查看CPU架构</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/14/ad06d31bcadc885b4e9b9a172e7e168e.png" alt="image-20210114112003303"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file 文件名查看可执行文件的信息</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/14/2a33ae84d91cf89bbe07ff151d92a0cc.png" alt="image-20210114112124794"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装32位的库</span></span><br><span class="line">apt-get update</span><br><span class="line">apt install lib32z1</span><br><span class="line"><span class="meta">#</span><span class="bash">或者apt install lib32ncurses5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/14/dc0a0c7a729eadcc6583973c5afb8b25.png" alt="image-20210114112507406"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装共享库</span><br><span class="line">apt install g++-multilib</span><br></pre></td></tr></table></figure>

<p>查看CPU型号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br><span class="line">#查看自行位数（CPU字长）</span><br><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/14/9afe6dff116178fcd51ac84d6d9c81d4.png" alt="image-20210114113728795"></p>
]]></content>
  </entry>
  <entry>
    <title>Celery后台异步任务队列</title>
    <url>//post/905.html</url>
    <content><![CDATA[<p>官方中文文档</p><p><a href="https://dormousehole.readthedocs.io/en/latest/patterns/celery.html" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/patterns/celery.html</a></p><a id="more"></a>

<p>官方英文文档</p>
<p><a href="https://pypi.org/project/celery_once/#backends" target="_blank" rel="noopener">https://pypi.org/project/celery_once/#backends</a></p>
<p>李辉 Flask开发番外篇 <a href="https://www.zhihu.com/topic/20203769/hot" target="_blank" rel="noopener">https://www.zhihu.com/topic/20203769/hot</a></p>
<p><a href="https://www.tuicool.com/articles/UziEN3I" target="_blank" rel="noopener">https://www.tuicool.com/articles/UziEN3I</a></p>
<p>加分布式锁 <a href="http://einverne.github.io/post/2018/01/use-celery-once-to-prevent-multiple-execution.html" target="_blank" rel="noopener">http://einverne.github.io/post/2018/01/use-celery-once-to-prevent-multiple-execution.html</a></p>
<p><a href="https://pypi.org/project/celery_once/#backends" target="_blank" rel="noopener">https://pypi.org/project/celery_once/#backends</a></p>
<p><a href="https://www.jianshu.com/p/b1934ff22b06" target="_blank" rel="noopener">https://www.jianshu.com/p/b1934ff22b06</a></p>
<p>推荐（中文）</p>
<p><a href="https://www.celerycn.io/ru-men/celery-jin-jie-shi-yong" target="_blank" rel="noopener">https://www.celerycn.io/ru-men/celery-jin-jie-shi-yong</a></p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title>Android逆向基础</title>
    <url>//post/11667.html</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/micaaa/article/details/82426710" target="_blank" rel="noopener">https://blog.csdn.net/micaaa/article/details/82426710</a></p>]]></content>
      <categories>
        <category>Android</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>//post/15279.html</url>
    <content><![CDATA[<h1 id="C-基本数据类型占字节数"><a href="#C-基本数据类型占字节数" class="headerlink" title="C++基本数据类型占字节数"></a><a href="https://www.cnblogs.com/home123/p/7397267.html" target="_blank" rel="noopener">C++基本数据类型占字节数</a></h1><p><strong>32位编译器</strong></p><p>char ：1个字节<br>char<em>（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br>*</em>long:  4个字节**<br>long long: 8个字节<br>unsigned long: 4个字节</p><a id="more"></a>

<p><strong>64位编译器</strong></p>
<p>char ：1个字节<br>char<em>(即指针变量): 8个字节<br>short int : 2个字节<br>int： 4个字节<br>unsigned int : 4个字节<br>float: 4个字节<br>double:  8个字节<br>*</em>long:  8个字节**<br>long long: 8个字节<br>unsigned long: 8个字节</p>
<h1 id="greater-和less"><a href="#greater-和less" class="headerlink" title="greater() 和less ()"></a>greater<t>() 和less<t> ()</t></t></h1><blockquote>
<p><a href="https://blog.csdn.net/Ginsn/article/details/81590473?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/Ginsn/article/details/81590473?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Docker搭建 SoftEther VPN</title>
    <url>//post/43889.html</url>
    <content><![CDATA[<p>1、运行Docker镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">	--name=softethervpn \</span><br><span class="line">       	--restart=always --cap-add NET_ADMIN \</span><br><span class="line">	-p 500:500/udp \</span><br><span class="line">       	-p 4500:4500/udp \</span><br><span class="line">	-p 1701:1701/tcp \</span><br><span class="line">	-p 1194:1194/udp \</span><br><span class="line">	-p 5555:5555/tcp \</span><br><span class="line">       	-e SPW=超级管理员密码 \</span><br><span class="line">	-e HPW=普通管理员密码 \</span><br><span class="line">       	-e PSK=vpn \</span><br><span class="line">	-e USERNAME=用户名 \</span><br><span class="line">	-v /dev/null:/usr/vpnserver/server_log \</span><br><span class="line">	-v /dev/null:/usr/vpnserver/packet_log \</span><br><span class="line">        -v /dev/null:/usr/vpnserver/security_log\</span><br><span class="line">        -e PASSWORD=密码 \</span><br><span class="line">	siomiz/softethervpn:alpine</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker利用Tomcat部署war包</title>
    <url>//post/31230.html</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- <span class="doctag">Note:</span>  A "Server" is not itself a "Container", so you may not</span></span><br><span class="line"><span class="comment">     define subcomponents such as "Valves" at this level.</span></span><br><span class="line"><span class="comment">     Documentation at /docs/config/server.html</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Security listener. Documentation at /docs/config/listeners.html</span></span><br><span class="line"><span class="comment">  &lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Global JNDI resources</span></span><br><span class="line"><span class="comment">       Documentation at /docs/jndi-resources-howto.html</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Editable user database that can also be used by</span></span><br><span class="line"><span class="comment">         UserDatabaseRealm to authenticate users</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- A "Service" is a collection of one or more "Connectors" that share</span></span><br><span class="line"><span class="comment">       a single "Container" <span class="doctag">Note:</span>  A "Service" is not itself a "Container",</span></span><br><span class="line"><span class="comment">       so you may not define subcomponents such as "Valves" at this level.</span></span><br><span class="line"><span class="comment">       Documentation at /docs/config/service.html</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-"</span></span><br><span class="line"><span class="comment">        maxThreads="150" minSpareThreads="4"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- A "Connector" represents an endpoint by which requests are received</span></span><br><span class="line"><span class="comment">         and responses are returned. Documentation at :</span></span><br><span class="line"><span class="comment">         Java HTTP Connector: /docs/config/http.html</span></span><br><span class="line"><span class="comment">         Java AJP  Connector: /docs/config/ajp.html</span></span><br><span class="line"><span class="comment">         APR (HTTP/AJP) Connector: /docs/apr.html</span></span><br><span class="line"><span class="comment">         Define a non-SSL/TLS HTTP/1.1 Connector on port 8080</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- A "Connector" using the shared thread pool--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;Connector executor="tomcatThreadPool"</span></span><br><span class="line"><span class="comment">               port="8080" protocol="HTTP/1.1"</span></span><br><span class="line"><span class="comment">               connectionTimeout="20000"</span></span><br><span class="line"><span class="comment">               redirectPort="8443" /&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443</span></span><br><span class="line"><span class="comment">         This connector uses the NIO implementation. The default</span></span><br><span class="line"><span class="comment">         SSLImplementation will depend on the presence of the APR/native</span></span><br><span class="line"><span class="comment">         library and the useOpenSSL attribute of the</span></span><br><span class="line"><span class="comment">         AprLifecycleListener.</span></span><br><span class="line"><span class="comment">         Either JSSE or OpenSSL style configuration may be used regardless of</span></span><br><span class="line"><span class="comment">         the SSLImplementation selected. JSSE style configuration is used below.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"</span></span><br><span class="line"><span class="comment">               maxThreads="150" SSLEnabled="true"&gt;</span></span><br><span class="line"><span class="comment">        &lt;SSLHostConfig&gt;</span></span><br><span class="line"><span class="comment">            &lt;Certificate certificateKeystoreFile="conf/localhost-rsa.jks"</span></span><br><span class="line"><span class="comment">                         type="RSA" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;/SSLHostConfig&gt;</span></span><br><span class="line"><span class="comment">    &lt;/Connector&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443 with HTTP/2</span></span><br><span class="line"><span class="comment">         This connector uses the APR/native implementation which always uses</span></span><br><span class="line"><span class="comment">         OpenSSL for TLS.</span></span><br><span class="line"><span class="comment">         Either JSSE or OpenSSL style configuration may be used. OpenSSL style</span></span><br><span class="line"><span class="comment">         configuration is used below.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11AprProtocol"</span></span><br><span class="line"><span class="comment">               maxThreads="150" SSLEnabled="true" &gt;</span></span><br><span class="line"><span class="comment">        &lt;UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;SSLHostConfig&gt;</span></span><br><span class="line"><span class="comment">            &lt;Certificate certificateKeyFile="conf/localhost-rsa-key.pem"</span></span><br><span class="line"><span class="comment">                         certificateFile="conf/localhost-rsa-cert.pem"</span></span><br><span class="line"><span class="comment">                         certificateChainFile="conf/localhost-rsa-chain.pem"</span></span><br><span class="line"><span class="comment">                         type="RSA" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;/SSLHostConfig&gt;</span></span><br><span class="line"><span class="comment">    &lt;/Connector&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;Connector protocol="AJP/1.3"</span></span><br><span class="line"><span class="comment">               address="::1"</span></span><br><span class="line"><span class="comment">               port="8009"</span></span><br><span class="line"><span class="comment">               redirectPort="8443" /&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- An Engine represents the entry point (within Catalina) that processes</span></span><br><span class="line"><span class="comment">         every request.  The Engine implementation for Tomcat stand alone</span></span><br><span class="line"><span class="comment">         analyzes the HTTP headers included with the request, and passes them</span></span><br><span class="line"><span class="comment">         on to the appropriate Host (virtual host).</span></span><br><span class="line"><span class="comment">         Documentation at /docs/config/engine.html --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- You should set jvmRoute to support load-balancing via AJP ie :</span></span><br><span class="line"><span class="comment">    &lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1"&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--For clustering, please take a look at documentation at:</span></span><br><span class="line"><span class="comment">          /docs/cluster-howto.html  (simple how to)</span></span><br><span class="line"><span class="comment">          /docs/config/cluster.html (reference documentation) --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords</span></span><br><span class="line"><span class="comment">           via a brute-force attack --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- This Realm uses the UserDatabase configured in the global JNDI</span></span><br><span class="line"><span class="comment">             resources under the key "UserDatabase".  Any edits</span></span><br><span class="line"><span class="comment">             that are performed against this UserDatabase are immediately</span></span><br><span class="line"><span class="comment">             available for use by the Realm.  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"../webapps/app"</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SingleSignOn valve, share authentication between web applications</span></span><br><span class="line"><span class="comment">             Documentation at: /docs/config/valve.html --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Access log processes all example.</span></span><br><span class="line"><span class="comment">             Documentation at: /docs/config/valve.html</span></span><br><span class="line"><span class="comment">             <span class="doctag">Note:</span> The pattern used is equivalent to using pattern="common" --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">"%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">springboot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">80</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 容器数据卷挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./java/app.war:/usr/local/tomcat/webapps/app.war</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./java/server.xml:/usr/local/tomcat/conf/server.xml</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./java/logs:/usr/local/tomcat/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Docker搭建Hadoop集群</title>
    <url>//post/61036.html</url>
    <content><![CDATA[<p>Docker安装</p><p>hadoop 2.7.2的Docker镜像  twinsen/hadoop:2.7.2</p><a id="more"></a>

<h5 id="3-创建hadoop容器"><a href="#3-创建hadoop容器" class="headerlink" title="3)创建hadoop容器"></a>3)创建hadoop容器</h5><p>（1）创建master节点<br><code>docker run --name master -d -h master twinsen/hadoop:2.7.2</code><br><strong>参数说明:</strong><br>-h 为容器设置主机名<br>–name 设置容器的名称<br>-d 在后台运行</p>
<p>（2）以此方法创建slave1和slave2节点<br><code>docker run --name slave1 -d -h slave1 twinsen/hadoop:2.7.2</code><br><code>docker run --name slave2 -d -h slave2 twinsen/hadoop:2.7.2</code><br>（3）查看容器<br><code>docker ps -s</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/root/hadoop/sbin</span><br><span class="line"></span><br><span class="line">docker run --name master  --rm  twinsen/hadoop:<span class="number">2.7</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">docker run --name  hadoop-slave1 -itd   -P --network hadoop twinsen/hadoop:<span class="number">2.7</span><span class="number">.2</span> </span><br><span class="line"></span><br><span class="line">docker run --name  hadoop-slave2 -itd   -P --network hadoop twinsen/hadoop:<span class="number">2.7</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">docker run --name  hadoop-slave3 -itd -P  --network hadoop twinsen/hadoop:<span class="number">2.7</span><span class="number">.2</span></span><br><span class="line">    </span><br><span class="line">docker run --name  hadoop-master -it  -d  -P  --network hadoop  twinsen/hadoop:<span class="number">2.7</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<p>cd /</p>
]]></content>
  </entry>
  <entry>
    <title>Docker下使用Nginx配置多站点</title>
    <url>//post/24743.html</url>
    <content><![CDATA[<p><code>docker run -p 80:80 -p 81:81 --name nginx -v /root/nginx/www/dvwa/:/usr/share/nginx/html/dvwa -v /root/nginx/conf.d:/etc/nginx/conf.d  -v /root/nginx/www/xss:/usr/share/nginx/html/xss   --link php:php --link mysql:mysql -d nginx:latest</code></p><a id="more"></a>
<p><code>方式一：修改配置文件（需停止docker服务）</code><br><code>1、停止docker服务</code><br><code>systemctl stop docker.service（关键，修改之前必须停止docker服务）</code><br><code>2、vim /var/lib/docker/containers/container-ID/config.v2.json</code><br><code>修改配置文件中的目录位置，然后保存退出</code></p>
<p> <code>&quot;MountPoints&quot;:{&quot;/home&quot;:{&quot;Source&quot;:&quot;/docker&quot;,&quot;Destination&quot;:&quot;/home&quot;,&quot;RW&quot;:true,&quot;Name&quot;:&quot;&quot;,&quot;Driver&quot;:&quot;&quot;,&quot;Type&quot;:&quot;bind&quot;,&quot;Propagation&quot;:&quot;rprivate&quot;,&quot;Spec&quot;:{&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;//docker/&quot;,&quot;Target&quot;:&quot;/home&quot;}}}</code><br><code>1</code><br><code>3、启动docker服务</code><br><code>systemctl start docker.service</code><br><code>4、启动docker容器</code><br><code>docker start &lt;container-name/ID&gt;</code></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建Nginx+Mysql+PHP环境</title>
    <url>//post/21932.html</url>
    <content><![CDATA[<p>mysql -u root -p<br>use mysql;<br>update user set host = “%” where user = “root”;<br>docker run -d -p 9000:9000 -v /home/sail/codelife/code/be/php/:/var/www/html/ –name php-with-mysql –link test_mysql:mysql  –volumes-php-from test_mysql –privileged=true php-fpm5.6/v2</p><a id="more"></a>
<p>docker run -p 9000:9000 –name php -v /root/php:/var/www/html  –link mysql:mysql  –privileged=true -d php:5.6-fpm</p>
<p>root           /var/www/html; # 代码目录</p>
<p>docker run -p 80:80  –name nginx -v /root/nginx/www:/usr/share/nginx/html -v /root/nginx/conf.d:/etc/nginx/conf.d  –link php:php  –link mysql:mysql -d nginx:latest</p>
<p>docker run -p 81:80  –name nginx -v /root/nginx/www:/usr/share/nginx/html -v /root/nginx/conf.d:/etc/nginx/conf.d  –link php:phpfpm -d nginx:latest<br>docker run -p 80:80 –name nginx-test -d nginx:latest</p>
<p>docker run -d nginx:latest –link php:php   –volumes-from php -p 80:80 -v /root/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf –name nginx-php –privileged=true</p>
<p>docker build -t=”php” .</p>
<p>docker run -d -p 9000:9000 -v /root/php/:/var/www/html/ –name php –link mysql:mysql  –volumes-from mysql –privileged=true php</p>
<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>－v 将本地磁盘上的php代码挂载到docker 环境中，对应docker的目录是 /var/www/html/<br>–name 新建的容器名称 php-with-mysql<br>–link 链接的容器，链接的容器名称：在该容器中的别名，运行这个容器是，docker中会自动添加一个host识别被链接的容器ip<br>–privileged=true 权限问题</p>
<p>docker run -d -p 9000:9000 -v /root/php/:/var/www/html/ –name php –link mysql:mysql  –volumes-from mysql –privileged=true -d php:5.6-fpm<br>docker exec -it php bash<br>cd /var/www/html &amp;&amp; ls</p>
<p>docker run -d -p 9000:9000 -v /www/php/:/var/www/html/ –name php –link mysql:mysql  –volumes-from mysql –privileged=true php:5.6-fpm</p>
<h3 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h3><p>－v 将本地磁盘上的php代码挂载到docker 环境中，对应docker的目录是 /var/www/html/<br>–name 新建的容器名称 php-with-mysql<br>–link 链接的容器，链接的容器名称：在该容器中的别名，运行这个容器是，docker中会自动添加一个host识别被链接的容器ip<br>–privileged=true 权限问题</p>
<p>mod_php</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署Flask</title>
    <url>//post/49387.html</url>
    <content><![CDATA[<p>Dokcer的安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用脚本自动安装</span><br><span class="line">在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装：</span><br><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span><br><span class="line">执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ubuntu 16.04+、Debian 8+、CentOS 7</span><br><span class="line">在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中写入如下内容（如果文件不存在请新建该文件）</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [</span><br><span class="line">&quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,</span><br><span class="line">&quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h1><p>镜像加速</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br></pre></td></tr></table></figure>

<h1 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h1><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<p>退出当前终端并重新登录，进行如下测试。</p>
<h1 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure>

<p>1、Docker可视化面板安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5471:10086 -v /var/run/docker.sock:/var/run/docker.sock tobegit3hub/seagull</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 8888:8888 --name swzl cb1642485ca7  -v &#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn:&#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn flask:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it  --rm&#x3D;true -p 8888:8888  -v &#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn:&#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn flask:latest	 &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">docker run -it  -p 8888:8888  -v &#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn:&#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn flask:latest	 &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">docker run -it  -p 8888:8888 --name flask -v &#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn:&#x2F;www&#x2F;wwwroot&#x2F;ctguswzl.cn registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;ctguswzl:1.0	 &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>mkdir -p /www/wwwroot/ctguswzl.cn<br>mkdir -p /www/server</p>
<p>迁移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf server.tar.gz  *</span><br></pre></td></tr></table></figure>

<p>cerboot实现泛域名证书自动续期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir -p &#x2F;www&#x2F;server&#x2F;certbot</span><br><span class="line"></span><br><span class="line"># 进入目录</span><br><span class="line">cd &#x2F;www&#x2F;server&#x2F;certbot</span><br><span class="line"></span><br><span class="line"># 下载</span><br><span class="line">wget https:&#x2F;&#x2F;dl.eff.org&#x2F;certbot-auto</span><br><span class="line"></span><br><span class="line"># 设为可执行权限</span><br><span class="line">chmod +x certbot-auto</span><br><span class="line"></span><br><span class="line"># 加入到系统可执行目录</span><br><span class="line">ln -s &#x2F;www&#x2F;server&#x2F;certbot&#x2F;certbot-auto &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line"># 申请证书，替换成你自己的域名</span><br><span class="line">ln -s &#x2F;www&#x2F;server&#x2F;certbot&#x2F;certbot-auto &#x2F;usr&#x2F;bin&#x2F; </span><br><span class="line">ln -s &#x2F;www&#x2F;server&#x2F;certbot&#x2F;certbot-auto &#x2F;usr&#x2F;bin&#x2F; \</span><br><span class="line">&amp;&amp; certbot-auto -d &quot;*.ctguswzl.cn&quot;  -d  &quot;ctguswzl.cn&quot; --manual --preferred-challenges dns-01 certonly --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 *&#x2F;1 * * root certbot-auto renew --manual --preferred-challenges dns --deploy-hook  &quot;docker start nginx&quot; --manual-auth-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python aly add&quot; --manual-cleanup-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python aly clean&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certbot-auto renew --cert-name ctguswzl.cn --manual-auth-hook &#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh --dry-run</span><br><span class="line"></span><br><span class="line">0 3 1 * * certbot-auto renew --renew-hook &quot;sudo nginx -s reload&quot;</span><br><span class="line">0 3 1 * * certbot-auto renew --renew-hook &quot;sudo nginx -s reload&quot;</span><br><span class="line"></span><br><span class="line">0 1 *&#x2F;1 * * certbot renew  --force-renewal --cert-name ctguswzl.cn --preferred-challenges dns --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory --manual --manual-auth-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy add&quot; --manual-cleanup-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy clean&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;sh -c cd &#x2F;www&#x2F;server&#x2F;certbot &amp;&amp; certbot-auto renew  --force-renewal --cert-name ctguswzl.cn --preferred-challenges dns --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory --manual --manual-auth-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy add&quot; --manual-cleanup-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy clean&quot; --renew-hook &quot;docker restart nginx&quot;  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">每天凌晨1点执行定时任务续签证书</span><br><span class="line">0 1 * * * &#x2F;bin&#x2F;sh -c  &#x2F;www&#x2F;server&#x2F;certbot&#x2F;certbot-auto renew  --force-renewal --cert-name ctguswzl.cn --preferred-challenges dns --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory --manual --manual-auth-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy add&quot; --manual-cleanup-hook &quot;&#x2F;www&#x2F;server&#x2F;certbot&#x2F;tool&#x2F;au.sh python txy clean&quot; --renew-hook &quot;docker restart nginx&quot;  &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">sudo apt-get install python3.6-venv</span><br></pre></td></tr></table></figure>

<p>正解</p>
<p>apt-get purge python-virtualenv python3-virtualenv virtualenv<br>pip install virtualenv</p>
<p> pip install virtualenv==16.1</p>
<h2 id="Docker可视化面板"><a href="#Docker可视化面板" class="headerlink" title="Docker可视化面板"></a>Docker可视化面板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \</span><br><span class="line">-v portainer_data:&#x2F;data \</span><br><span class="line">portainer&#x2F;portainer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d -p 9000:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data -v &#x2F;public:&#x2F;public portainer&#x2F;portainer:1.20.2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> docker commit -a &quot;iBoy&quot; -m &quot;Portainer中文汉化&quot; 398562fad864  registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;portainer:1.0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">docker run -d \</span><br><span class="line">-p 9001:9000 \</span><br><span class="line">-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \</span><br><span class="line">-v portainer_data:&#x2F;data \</span><br><span class="line"> registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;portainer:1.0	</span><br><span class="line"> </span><br><span class="line"> https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42851117&#x2F;article&#x2F;details&#x2F;106645555</span><br><span class="line"> </span><br><span class="line"> docker run -d -p 9000:9000 --restart&#x3D;always  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock --name prtainer  registry.cn-zhangjiakou.aliyuncs.com&#x2F;ctgu&#x2F;portainer</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  docker run -d -p 9000:9000 --restart&#x3D;always  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v pcn_data:&#x2F;data  --name prtainer5  registry.cn-zhangjiakou.aliyuncs.com&#x2F;ctgu&#x2F;portainer</span><br><span class="line">  </span><br><span class="line">  docker cp &#x2F;root&#x2F;public&#x2F;. 2a8:&#x2F;public&#x2F; </span><br><span class="line"></span><br><span class="line">registry.cn-zhangjiakou.aliyuncs.com&#x2F;ctgu&#x2F;portainer</span><br></pre></td></tr></table></figure>

<h4 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -L https://github.wuyanzheshui.workers.dev/docker/compose/releases/download/1.26.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>秘钥登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp id_rsa.pub root@192.168.19.7:~&#x2F;.ssh</span><br><span class="line">我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</span><br><span class="line"></span><br><span class="line">密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</span><br><span class="line"></span><br><span class="line">下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</span><br><span class="line"></span><br><span class="line">1. 制作密钥对</span><br><span class="line"></span><br><span class="line">首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ ssh-keygen  &lt;&#x3D;&#x3D; 建立密钥对</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa): &lt;&#x3D;&#x3D; 按 Enter</span><br><span class="line">Created directory &#39;&#x2F;root&#x2F;.ssh&#39;.</span><br><span class="line">Enter passphrase (empty for no passphrase): &lt;&#x3D;&#x3D; 输入密钥锁码，或直接按 Enter 留空</span><br><span class="line">Enter same passphrase again: &lt;&#x3D;&#x3D; 再输入一遍密钥锁码</span><br><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa. &lt;&#x3D;&#x3D; 私钥</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub. &lt;&#x3D;&#x3D; 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</span><br><span class="line">密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</span><br><span class="line"></span><br><span class="line">现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</span><br><span class="line"></span><br><span class="line">2. 在服务器上安装公钥</span><br><span class="line"></span><br><span class="line">键入以下命令，在服务器上安装公钥：</span><br><span class="line"></span><br><span class="line">[root@host ~]$ cd .ssh</span><br><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ chmod 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ chmod 700 ~&#x2F;.ssh</span><br><span class="line">3. 设置 SSH，打开密钥登录功能</span><br><span class="line"></span><br><span class="line">编辑 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件，进行如下设置：</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">另外，请留意 root 用户能否通过 SSH 登录：</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line">当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line">最后，重启 SSH 服务：</span><br><span class="line"></span><br><span class="line">[root@host .ssh]$ service sshd restart</span><br><span class="line">4. 将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</span><br><span class="line"></span><br><span class="line">使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</span><br><span class="line"></span><br><span class="line">载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</span><br><span class="line"></span><br><span class="line">今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Docker部署Frp实现内网穿透</title>
    <url>//post/17273.html</url>
    <content><![CDATA[<p>1、运行Frp服务端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always --network host -d -v /root/frp/frps.ini:/etc/frp/frps.ini --name frps snowdreamtech/frps</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>2、frp服务端配置文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="attr">kcp_bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">81</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">444</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = 用户名</span><br><span class="line"><span class="attr">dashboard_pwd</span> = 密码</span><br><span class="line"><span class="attr">subdomain_host</span> = 子域名</span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">7</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">token</span> = token值</span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">1</span>-<span class="number">65535</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log</span><br><span class="line"><span class="attr">log_level</span> = info</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Frp</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker概述(2)</title>
    <url>//post/59367.html</url>
    <content><![CDATA[<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p><strong>docker的理念回顾</strong></p><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><a id="more"></a>


<p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p>
<p><img src="../static/img/docker2/image-20200611220811766.png" alt="image-20200611220811766"></p>
<p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote>
<p>方式一：直接使用命令来挂载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost home]# docker run -it -v /home/ceshi:/home  centos  /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动起来的时候，我们可以通过docker inspect 容器id 来查看挂载情况：（见下图）</span></span><br></pre></td></tr></table></figure>

<p><img src="../static/img/docker2/image-20200611224010091.png" alt="image-20200611224010091"></p>
<p>测试文件的同步.</p>
<p><img src="/static/img/docker2/image-20200611224046109.png" alt="image-20200611224046109"></p>
<p>在容器内指定目录下添加或修改一个文件，会同步到主机指定目录下！反之，在主机目录下做相关操作，也会同步到容器对应的目录下！</p>
<p>再来测试！</p>
<p>1、停止容器</p>
<p>2、宿主机修改文件</p>
<p>3、启动容器</p>
<p>4、容器内的数据依旧是同步的！</p>
<p><img src="/static/img/docker2/image-20200611224137284.png" alt="image-20200611224137284"></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><p>思考：MySQL的数据持久化的问题！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取镜像</span></span><br><span class="line">[root@localhost home]# docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行容器，需要做数据挂载！ <span class="comment"># 安装mysql,需要配置密码，这是要注意的点！</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动我们的MySQL容器</span></span><br><span class="line">-d	后台运行</span><br><span class="line">-p	端口映射</span><br><span class="line">-v	卷挂载</span><br><span class="line">-e  环境配置</span><br><span class="line">--name  容器名字</span><br><span class="line">[root@localhost home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog 连接测试一下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sqlyog —— 连接到服务器的3310 —— 3310和容器内的3306映射，这个时候我们就可以连接上了！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地测试创建一个数据库，查看一下我们的映射的路径是否ok!</span></span><br></pre></td></tr></table></figure>

<p>假设我们将容器删除</p>
<p><img src="/static/img/docker2/image-20200611230752177.png" alt="image-20200611230752177"></p>
<p>发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！</p>
<h2 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有卷的情况</span></span><br><span class="line">[root@localhost data]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               2dd0379216c9ee4441ed56f8ce53461c19abe78b8cfd024ac5fbe07c3b8f09ba</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v 后只写了容器内的路径，没有写容器外的路径！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">[root@localhost home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">5ba5708389bf71b2156fdbcedc50a62b16ac27adb2a3dfac42c52e9da5ace79f</span><br><span class="line">[root@localhost home]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               juming-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 卷名：容器内路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下这个卷  <span class="comment"># 先找到卷所在路径 docker volume inspect 卷名，如下图：</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200611235522418.png" alt="image-20200611235522418"></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/xxxx/_data</strong>下！<br>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况使用 <strong>具名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span></span><br><span class="line">-v	容器内路径		       # 匿名挂载</span><br><span class="line">-v	卷名:容器内路径	 	 # 具名挂载</span><br><span class="line">-v	/宿主机路径:容器内路径   # 指定路径挂载！</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径：ro 或 rw   改变读写权限</span></span><br><span class="line">ro	 #readonly 只读</span><br><span class="line">rw	 #readwrite 可读可写</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一旦创建容器时设置了容器权限，容器对我们挂载出来的内容就有限定了！</span></span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认是 rw</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></span><br></pre></td></tr></table></figure>

<h2 id="初始Dockerfile"><a href="#初始Dockerfile" class="headerlink" title="初始Dockerfile"></a>初始Dockerfile</h2><p>Dockerfile 就是用来构建 docker镜像的构建文件！命令脚本！ 先体验一下！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是最终镜像的一层！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随机，建议 dockerfile</span></span><br><span class="line"></span><br><span class="line">[root@localhost docker-test-volume]# vim dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件中的内容：指令(大写) 参数</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME ["volume01","volume02"]</span><br><span class="line"></span><br><span class="line">CMD echo"----end----"</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层！</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200612003052844.png" alt="image-20200612003052844"></p>
<p>注意：我们这里的 dockerfile  是我们编写的文件名哦！</p>
<p><img src="/static/img/docker2/image-20200612003717223.png" alt="image-20200612003717223"></p>
<p>这两个卷和外部一定有两个同步的目录！</p>
<p><img src="/static/img/docker2/image-20200612003946028.png" alt="image-20200612003946028"></p>
<p>查看一下卷挂载在主机上的路径</p>
<p><strong>docker inspect 容器id</strong></p>
<p><img src="/static/img/docker2/image-20200612004608027.png" alt="image-20200612004608027"></p>
<p>测试一下刚才的文件是否同步出去了！</p>
<p>这种方式我们未来使用十分的多，因为我们通常会构建自己的镜像！</p>
<p>假设构建镜像的时候没有挂在卷，要手动镜像挂载即可： (参考上文<strong>具名和匿名挂载</strong>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-v 卷名:容器内路径</span><br></pre></td></tr></table></figure>

<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p><strong>多个mysql同步数据！</strong></p>
<p><img src="/static/img/docker2/image-20200612223759573.png" alt="image-20200612223759573"></p>
<p><img src="/static/img/docker2/image-20200612224621379.png" alt="image-20200612224621379"></p>
<p><img src="/static/img/docker2/image-20200612225358172.png" alt="image-20200612225358172"></p>
<p>在docker03下创建docker03文件后，进入docker01发现也依旧会同步过来：</p>
<p><img src="/static/img/docker2/image-20200612225641266.png" alt="image-20200612225641266"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试1：删除docker01后，docker02和docker03是否还可以访问原来docker01下创建的的文件？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试1的结果为：依旧可以访问！！！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试2：删除docker01后，docker02和docker03之间是否可以相互同步文件？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试2的结果为：docket02和docker03之间一九可以完成同步！！！ 见下图：</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200612231431551.png" alt="image-20200612231431551"></p>
<p><img src="/static/img/docker2/image-20200612231603498.png" alt="image-20200612231603498"></p>
<p><strong>多个mysql实现数据共享</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line">➜  ~ docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p>
<hr>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p><code>dockerfile</code>是用来构建docker镜像的文件！命令参数脚本！</p>
<p><strong>构建步骤：</strong></p>
<p>1、 编写一个dockerfile文件</p>
<p>2、 docker build 构建称为一个镜像</p>
<p>3、 docker run运行镜像</p>
<p>4、 docker push发布镜像（DockerHub 、阿里云仓库)</p>
<p>查看官方是怎么做的！</p>
<p><img src="/static/img/docker2/image-20200612233951676.png" alt="image-20200612233951676"></p>
<p><img src="/static/img/docker2/image-20200612234022746.png" alt="image-20200612234022746"></p>
<p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p>
<p>官方既然可以制作镜像，那我们也可以！</p>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><p><strong>基础知识：</strong></p>
<p>1、每个保留关键字(指令）都是必须是大写字母</p>
<p>2、执行从上到下顺序</p>
<p>3、# 表示注释</p>
<p>4、每一个指令都会创建提交一个新的镜像曾，并提交！</p>
<p><img src="/static/img/docker2/image-20200612234419262.png" alt="image-20200612234419262"></p>
<p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p>
<p>Docker镜像逐渐成企业交付的标准，必须要掌握！</p>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p>
<p>Docker容器：容器就是镜像运行起来提供服务。</p>
<h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM			# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER		# 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN				# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD				# 步骤：tomcat镜像，这个tomcat压缩包！ 添加内容</span><br><span class="line">WORKDIR			# 镜像的工作目录</span><br><span class="line">VOLUME			# 挂载的目录</span><br><span class="line">EXPOSE          # 暴露端口配置，跟 -p 是一个道理</span><br><span class="line">CMD				# 指定这个容器启动时要执行的命令,只有最后一个命令会生效，可悲替代</span><br><span class="line">ENTRYPOINT		# 指定这个容器启动的时候要执行的命令，可以追加命令</span><br><span class="line">ONBUILD			# 当构建一个被继承DockerFile 这个时候就会运行ONBUILD的指令。触发指令</span><br><span class="line">COPY			# 类似ADD,将我们文件拷贝到镜像中</span><br><span class="line">ENV				# 构建的时候设置环境变量，跟 -e 是一个意思</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD 和 ENTRYPOINT 的区别说明：（后面也会介绍）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若CMD 和 ENTRYPOINT 后跟的都是 ls -a 这个命令，当docker run 一个容器时，添加了 -l 选项，则CMD里的ls -a 命令就会被替换成-l;而ENTRYPOINT中的 ls -a会追加-l变成 ls -a -l</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200613000838850.png" alt="image-20200613000838850"></p>
<h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>Docker Hub中99%镜像都是从这个基础镜像过来的( <strong>FROM scratch</strong> )，然后配置需要的软件和配置来构建。</p>
<p><img src="/static/img/docker2/image-20200613001130237.png" alt="image-20200613001130237"></p>
<blockquote>
<p>创建一个自己的 centos</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编写DockerFile文件，内容如下：</span></span><br><span class="line">[root@localhost dockerfile]# cat mydockerfile-centos</span><br><span class="line">FROM centos						</span><br><span class="line">MAINTAINER ztx&lt;123456@qq.com&gt; </span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、通过这个文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令docker build -f dockerfile文件路径 -t 镜像名:[tag] .</span></span><br><span class="line">[root@localhost dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .</span><br><span class="line">....</span><br><span class="line">Successfully built c987078b06cb</span><br><span class="line">Successfully tagged mycentos:0.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、测试运行</span></span><br></pre></td></tr></table></figure>

<p><strong>对比：</strong></p>
<p><strong>之前的原生的centos</strong></p>
<p><img src="/static/img/docker2/image-20200613004551789.png" alt="image-20200613004551789"></p>
<p><strong>我们增加之后的镜像</strong></p>
<p><img src="/static/img/docker2/image-20200613005056516.png" alt="image-20200613005056516"></p>
<p>注：net-tools 包含一系列程序，构成了 Linux 网络的基础。</p>
<p>我们可以列出本地镜像的变更历史：</p>
<p><img src="/static/img/docker2/image-20200613005625844.png" alt="image-20200613005625844"></p>
<p>我们平时拿到一个镜像，可以研究一下它是怎么做的！</p>
<blockquote>
<p>CMD 和 ENTRYPOINT 的区别</p>
</blockquote>
<p><strong>测试CMD</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfile文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim dockerfile-test-cmd</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD ["ls","-a"]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run cmd-test:0.1</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想追加一个命令  -l 成为ls -al</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run cmd-test:0.1 -l</span></span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"-l\":</span><br><span class="line"> executable file not found in $PATH": unknown.</span><br><span class="line">ERRO[0000] error waiting for container: context canceled </span><br><span class="line"><span class="meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="string">"ls"</span>,<span class="string">"-l"</span>]。 -l  不是命令,所以报错</span></span><br></pre></td></tr></table></figure>

<p><strong>测试ENTRYPOINT</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfile文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim dockerfile-test-entrypoint</span></span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT ["ls","-a"]</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run entrypoint-test:0.1</span></span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">lost+found ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们的命令，是直接拼接在我们的ENTRYPOINT命令后面的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run entrypoint-test:0.1 -l</span></span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 May 16 06:32 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 May 16 06:32 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64 ....</span><br></pre></td></tr></table></figure>

<p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p>
<h2 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h2><p>1、准备镜像文件tomcat压缩包，jdk压缩包！</p>
<p><img src="/static/img/docker2/image-20200613151500712.png" alt="image-20200613151500712"></p>
<p>2、编写Dockerfile文件，官方命名: <strong>Dockerfile</strong> ，build会自动寻找这个文件，就不要 -f 指定了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER kuangshen&lt;123456@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u161-linux-x64.tar.gz    /usr/local/</span><br><span class="line">ADD apache-tomcat-8.0.53.tar.gz   /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_161</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-8.0.53</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-8.0.53</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-8.0.53/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-8.0.53/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p>3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker build -t diytomcat .     diytomcat是定义的镜像名</span></span><br></pre></td></tr></table></figure>

<p>4、启动镜像，创建容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -d -p 9090:8080 --name kuangshentomcat02 -v /home/kuangshen/build/tomcat/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/apache-tomcat-8.0.53/webapps/<span class="built_in">test</span> -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/<span class="built_in">local</span>/apache-tomcat-8.0.53/logs diytomcat</span></span><br></pre></td></tr></table></figure>

<p>5、访问测试</p>
<p><img src="/static/img/docker2/image-20200613175551231.png" alt="image-20200613175551231"></p>
<p>6、发布项目（由于做了卷挂载，我们就可以直接在本地发布项目了）</p>
<p>在/home/kuangshen/build/tomcat/test目录下创建WEB-INF目录，在里面创建web.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                               http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在回到test目录，添加一个index.jsp页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>hello kuangshen<span class="tag">&lt;/<span class="name">title</span>&gt;</span>vim</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello World!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag"><span class="attr">System.out.println</span>("<span class="attr">---my</span> <span class="attr">test</span> <span class="attr">web</span> <span class="attr">logs---</span>");</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现：test项目部署成功，可以直接访问！</p>
<p><img src="/static/img/docker2/image-20200613180033633.png" alt="image-20200613180033633"></p>
<p>注意：这时进入/home/kuangshen/build/tomcat/tomcatlogs/目录下就可以看到日志信息了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcatlogs]# cat catalina.out</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200613180355186.png" alt="image-20200613180355186"></p>
<p>之前一直访问失败是web.xml配置有问题，最后也是查看该日志提示，才得以解决！！！</p>
<p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p>
<h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><blockquote>
<p>Docker Hub</p>
</blockquote>
<p>1、地址 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<p>2、确定这个账号可以登录</p>
<p>3、在我们服务器上提交自己的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:	docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录dockerhub</span></span><br><span class="line">[root@localhost tomcat]# docker login -u ztx115</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<p>4、登录完毕后就可以提交镜像了，就是一步 docker push</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> push自己的镜像到服务器上！</span></span><br><span class="line">[root@localhost tomcat]# docker push diytomcat</span><br><span class="line">The push refers to repository [docker.io/library/diytomcat]</span><br><span class="line">c5593011cd68: Preparing </span><br><span class="line">d3ce40b8178e: Preparing </span><br><span class="line">02084c67dcc9: Preparing </span><br><span class="line">2b7c1c6c89c5: Preparing </span><br><span class="line">0683de282177: Preparing </span><br><span class="line">denied: requested access to the resource is denied  # 拒绝</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> push镜像的问题？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决：增加一个tag         docker tag  指定镜像的id   dockerhub的用户名/镜像重命名:[tag]</span></span><br><span class="line">[root@localhost tomcat]# docker tag bb64ab96b432 ztx115/tomcat:1.0</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200613211709842.png" alt="image-20200613211709842"></p>
<p><strong>注意：镜像的重命名前一定要加当前的dockerhub的用户名，否则将会push失败！！！！</strong>（如：把ztx115改成ztx,  push一定失败！）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docekr push上去即可！  自己平时发布的镜像尽量带上版本号</span></span><br><span class="line">[root@localhost tomcat]# docker push ztx115/tomcat:1.0</span><br><span class="line">The push refers to repository [docker.io/ztx115/tomcat]</span><br><span class="line">c5593011cd68: Pushed </span><br><span class="line">d3ce40b8178e: Pushed </span><br><span class="line">02084c67dcc9: Pushed </span><br><span class="line">2b7c1c6c89c5: Pushed </span><br><span class="line">0683de282177: Pushed </span><br><span class="line">1.0: digest: sha256:b6733deccf85ad66c6f4302215dd9ea63e1579817f15a099b5858785708ed408 size: 1372</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200613210147709.png" alt="image-20200613210147709"></p>
<p>发现，提交时也是按照镜像的层级来进行提交的！</p>
<blockquote>
<p>发布到阿里云镜像服务上（狂神视频截图）</p>
</blockquote>
<p>1、登录阿里云</p>
<p>2、找到容器镜像服务</p>
<p>3、创建命名空间</p>
<p><img src="/static/img/docker2/image-20200613212823736.png" alt="image-20200613212823736"></p>
<p>4、创建容器镜像仓库</p>
<p><img src="/static/img/docker2/image-20200613213014849.png" alt="image-20200613213014849"></p>
<p><img src="/static/img/docker2/image-20200613213135466.png" alt="image-20200613213135466"></p>
<p><img src="/static/img/docker2/image-20200613213222587.png" alt="image-20200613213222587"></p>
<p>5、浏览阿里云</p>
<p><img src="/static/img/docker2/image-20200613214159792.png" alt="image-20200613214159792"></p>
<p>使用阿里云容器镜像的参考官方指南即可！！！（即上图）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/static/img/docker2/image-20200613214846464.png" alt="image-20200613214846464"></p>
<hr>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><p>清空所有环境</p>
<blockquote>
<p>测试</p>
</blockquote>
<p><img src="/static/img/docker2/image-20200613224119526.png" alt="image-20200613224119526"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 问题： docker是如何处理容器网络访问的？</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200613220806390.png" alt="image-20200613220806390"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [root@localhost /]<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的内部网络地址   ip addr,  发现容器启动的时候会得到一个 eth0@if43 ip地址，docker分配的！</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">42: eth0@if43: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 思考：linux能不能ping通docker容器内部！</span></span><br><span class="line">[root@localhost /]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.476 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.099 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.105 ms</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> linux 可以ping通docker容器内部</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理</p>
</blockquote>
<p>1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要装了docker，就会有一个docker01网卡。</p>
<p>桥接模式，使用的技术是veth-pair技术！</p>
<p>再次测试 ip addr，发现多了一对网卡 : </p>
<p><img src="/static/img/docker2/image-20200613224311838.png" alt="image-20200613224311838"></p>
<p>2、再启动一个容器测试，发现又多了一对网卡！！！</p>
<p><img src="/static/img/docker2/image-20200613224610781.png" alt="image-20200613224610781"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们发现这个容器带来网卡，都是一对对的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正因为有这个特性，veth-pair 充当一个桥梁，连接各种虚拟网络设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OpenStack，Docker容器之间的连接，OVS的连接都是使用veth-pair技术</span></span><br></pre></td></tr></table></figure>

<p>3、我们来测试下tomcat01和tomcat02是否可以ping通！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker exec -it tomcat02 ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.556 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.096 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.111 ms</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结论：容器与容器之间是可以相互ping通的！！！</span></span><br></pre></td></tr></table></figure>

<p><strong>绘制一个网络模型图：</strong></p>
<p><img src="/static/img/docker2/image-20200613231046553.png" alt="image-20200613231046553"></p>
<p><strong>结论：tomcat01 和 tomcat02 是公用一个路由器，即 docker0 !</strong> </p>
<p>所有的容器不指定网络的情况下，都是经 docker0 路由的，docker 会给我们的容器分配一个默认的可用ip</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>Docker使用的是Linux的桥接技术，宿主机是一个Docker容器的网桥 docker0</p>
<p><img src="/static/img/docker2/image-20200613232031835.png" alt="image-20200613232031835"></p>
<p><strong>注意：</strong>Docker中所有网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件）</p>
<p>只要容器一删除，对应的一对网桥就没有！</p>
<h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><blockquote>
<p>思考一个场景：我们编写了一个微服务，database url = ip ，项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来访问容器？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tomcat02 想通过直接ping 容器名（即<span class="string">"tomcat01"</span>）来ping通，而不是ip，发现失败了！</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat02 ping tomcat01</span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如何解决这个问题呢？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过--link 就可以解决这个网络联通问题了！！！      发现新建的tomcat03可以ping通tomcat02</span></span><br><span class="line">[root@localhost /]# docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line">87a0e5f5e6da34a7f043ff6210b57f92f40b24d0d4558462e7746b2e19902721</span><br><span class="line">[root@localhost /]# docker exec -it tomcat03 ping tomcat02</span><br><span class="line">PING tomcat02 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.132 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.116 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反向能ping通吗？       发现tomcat02不能oing通tomcat03</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat02 ping tomcat03</span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure>

<p>探究：inspect  ！！！</p>
<p><img src="/static/img/docker2/image-20200614002609300.png" alt="image-20200614002609300"></p>
<p><img src="/static/img/docker2/image-20200614002832045.png" alt="image-20200614002832045"></p>
<p>其实这个tomcat03就是在本地配置了到tomcat02的映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看hosts 配置，在这里发现原理！  </span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat03 cat /etc/hosts</span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.3	tomcat02 95303c12f6d9    # 就像windows中的 host 文件一样，做了地址绑定</span><br><span class="line">172.17.0.4	87a0e5f5e6da</span><br></pre></td></tr></table></figure>

<p>本质探究：–link  就是我们在hosts 配置中增加了一个 172.17.0.3    tomcat02   95303c12f6d9 （三条信息都是tomcat02 的）</p>
<p>我们现在玩Docker已经不建议使用 –link 了！！！</p>
<p><strong>自定义网络，不使用docker0！</strong></p>
<p>docker0问题：不支持容器名连接访问！</p>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><blockquote>
<p>查看所有的docker网络</p>
</blockquote>
<p>‘<img src="/static/img/docker2/image-20200614004445923.png" alt="image-20200614004445923"></p>
<p><strong>网络模式</strong></p>
<p>bridge  ：桥接 （docker默认，自己创建也使用bridge模式！）</p>
<p>none ：不配置网络</p>
<p>host  ：和宿主机共享网络</p>
<p>container  ：容器网络连通，容器直接互联！（用的少！局限很大！）</p>
<p><strong>测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们之前直接启动的命令 (默认是使用--net bridge，可省)，这个bridge就是我们的docker0 </span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat   </span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面两句等价</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker0（即bridge）默认不支持域名访问 ！ --link可以打通连接，即支持域名访问！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以自定义一个网络！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --driver bridge    		网络模式定义为 ：桥接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --subnet 192.168.0.0/16	定义子网 ，范围为：192.168.0.2 ~ 192.168.255.255</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --gateway 192.168.0.1		子网网关设为： 192.168.0.1 </span></span><br><span class="line">[root@localhost /]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">7ee3adf259c8c3d86fce6fd2c2c9f85df94e6e57c2dce5449e69a5b024efc28c</span><br><span class="line">[root@localhost /]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">461bf576946c        bridge              bridge              local</span><br><span class="line">c501704cf28e        host                host                local</span><br><span class="line">7ee3adf259c8        mynet               bridge              local  	#自定义的网络</span><br><span class="line">9354fbcc160f        none                null                local</span><br></pre></td></tr></table></figure>

<p><strong>自己的网络就创建好了：</strong></p>
<p><img src="/static/img/docker2/image-20200614011229854.png" alt="image-20200614011229854"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">b168a37d31fcdc2ff172fd969e4de6de731adf53a2960eeae3dd9c24e14fac67</span><br><span class="line">[root@localhost /]# docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line">c07d634e17152ca27e318c6fcf6c02e937e6d5e7a1631676a39166049a44c03c</span><br><span class="line">[root@localhost /]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Name": "mynet",</span><br><span class="line">        "Id": "7ee3adf259c8c3d86fce6fd2c2c9f85df94e6e57c2dce5449e69a5b024efc28c",</span><br><span class="line">        "Created": "2020-06-14T01:03:53.767960765+08:00",</span><br><span class="line">        "Scope": "local",</span><br><span class="line">        "Driver": "bridge",</span><br><span class="line">        "EnableIPv6": false,</span><br><span class="line">        "IPAM": &#123;</span><br><span class="line">            "Driver": "default",</span><br><span class="line">            "Options": &#123;&#125;,</span><br><span class="line">            "Config": [</span><br><span class="line">                &#123;</span><br><span class="line">                    "Subnet": "192.168.0.0/16",</span><br><span class="line">                    "Gateway": "192.168.0.1"</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "Internal": false,</span><br><span class="line">        "Attachable": false,</span><br><span class="line">        "Ingress": false,</span><br><span class="line">        "ConfigFrom": &#123;</span><br><span class="line">            "Network": ""</span><br><span class="line">        &#125;,</span><br><span class="line">        "ConfigOnly": false,</span><br><span class="line">        "Containers": &#123;</span><br><span class="line">            "b168a37d31fcdc2ff172fd969e4de6de731adf53a2960eeae3dd9c24e14fac67": &#123;</span><br><span class="line">                "Name": "tomcat-net-01",</span><br><span class="line">                "EndpointID": "f0af1c33fc5d47031650d07d5bc769e0333da0989f73f4503140151d0e13f789",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:02",</span><br><span class="line">                "IPv4Address": "192.168.0.2/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;,</span><br><span class="line">            "c07d634e17152ca27e318c6fcf6c02e937e6d5e7a1631676a39166049a44c03c": &#123;</span><br><span class="line">                "Name": "tomcat-net-02",</span><br><span class="line">                "EndpointID": "ba114b9bd5f3b75983097aa82f71678653619733efc1835db857b3862e744fbc",</span><br><span class="line">                "MacAddress": "02:42:c0:a8:00:03",</span><br><span class="line">                "IPv4Address": "192.168.0.3/16",</span><br><span class="line">                "IPv6Address": ""</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "Options": &#123;&#125;,</span><br><span class="line">        "Labels": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次测试 ping 连接</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.199 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.121 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.0.3 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 2ms</span><br><span class="line">rtt min/avg/max/mdev = 0.121/0.160/0.199/0.039 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在不使用 --link,也可以ping 名字了！！！！！！</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.145 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.117 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-02 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 3ms</span><br><span class="line">rtt min/avg/max/mdev = 0.117/0.131/0.145/0.014 ms</span><br></pre></td></tr></table></figure>

<p>我们在使用自定义的网络时，docker都已经帮我们维护好了对应关系，推荐我们平时这样使用网络！！！</p>
<p>好处：</p>
<p>redis——不同的集群使用不同的网络，保证了集群的安全和健康</p>
<p>mysql——不同的集群使用不同的网络，保证了集群的安全和健康</p>
<p><img src="/static/img/docker2/image-20200614015209053.png" alt="image-20200614015209053"></p>
<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img src="/static/img/docker2/image-20200614013625192.png" alt="image-20200614013625192"></p>
<p><img src="/static/img/docker2/image-20200614013801842.png" alt="image-20200614013801842"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试打通 tomcat01 — mynet</span></span><br><span class="line">[root@localhost /]# docker network connect mynet tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连通之后就是将 tomcat01 放到了 mynet 网络下！ （见下图）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这就产生了 一个容器有两个ip地址 ! 参考阿里云的公有ip和私有ip</span></span><br><span class="line">[root@localhost /]# docker network inspect mynet</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200614014544797.png" alt="image-20200614014544797"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tomcat01 连通ok</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.124 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.162 ms</span><br><span class="line">64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.107 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-01 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 3ms</span><br><span class="line">rtt min/avg/max/mdev = 0.107/0.131/0.162/0.023 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat02 是依旧打不通的</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat02 ping tomcat-net-01</span><br><span class="line">ping: tomcat-net-01: Name or service not known</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong>假设要跨网络操作别人，就需要使用docker network connect  连通。。。</p>
<h2 id="实战：部署Redis集群"><a href="#实战：部署Redis集群" class="headerlink" title="实战：部署Redis集群"></a>实战：部署Redis集群</h2><p><img src="/static/img/docker2/image-20200614124559172.png" alt="image-20200614124559172"></p>
<p>启动6个redis容器，上面三个是主，下面三个是备！</p>
<p>使用shell脚本启动！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建redis集群网络</span></span><br><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span></span><br><span class="line">[root@localhost /]# for port in $(seq 1 6);\</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">do</span> \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir -p /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> touch /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cat &lt;&lt;EOF&gt;&gt;/mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> port 6379</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">bind</span> 0.0.0.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-enabled yes</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-config-file nodes.conf</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-node-timeout 5000</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-announce-ip 172.38.0.1<span class="variable">$&#123;port&#125;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-announce-port 6379</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cluster-announce-bus-port 16379</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> appendonly yes</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EOF</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">done</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的六个redis</span></span><br><span class="line">[root@localhost /]# cd /mydata/</span><br><span class="line">[root@localhost mydata]# \ls</span><br><span class="line">redis</span><br><span class="line">[root@localhost mydata]# cd redis/</span><br><span class="line">[root@localhost redis]# ls</span><br><span class="line">node-1  node-2  node-3  node-4  node-5  node-6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看redis-1的配置信息</span></span><br><span class="line">[root@localhost redis]# cd node-1</span><br><span class="line">[root@localhost node-1]# ls</span><br><span class="line">conf</span><br><span class="line">[root@localhost node-1]# cd conf/</span><br><span class="line">[root@localhost conf]# ls</span><br><span class="line">redis.conf</span><br><span class="line">[root@localhost conf]# cat redis.conf </span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.11</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">-v /mydata/redis/node-1/data:/data \</span><br><span class="line">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6372:6379 -p 16372:16379 --name redis-2 \</span><br><span class="line">-v /mydata/redis/node-2/data:/data \</span><br><span class="line">-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6373:6379 -p 16373:16379 --name redis-3 \</span><br><span class="line">-v /mydata/redis/node-3/data:/data \</span><br><span class="line">-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6374:6379 -p 16374:16379 --name redis-4 \</span><br><span class="line">-v /mydata/redis/node-4/data:/data \</span><br><span class="line">-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6375:6379 -p 16375:16379 --name redis-5 \</span><br><span class="line">-v /mydata/redis/node-5/data:/data \</span><br><span class="line">-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6376:6379 -p 16376:16379 --name redis-6 \</span><br><span class="line">-v /mydata/redis/node-6/data:/data \</span><br><span class="line">-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker2/image-20200614133829277.png" alt="image-20200614133829277"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# docker exec -it redis-1 /bin/sh</span><br><span class="line">/data # ls</span><br><span class="line">appendonly.aof  nodes.conf</span><br><span class="line">/data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 172.38.0.15:6379 to 172.38.0.11:6379</span><br><span class="line">Adding replica 172.38.0.16:6379 to 172.38.0.12:6379</span><br><span class="line">Adding replica 172.38.0.14:6379 to 172.38.0.13:6379</span><br><span class="line">M: c5551e2a30c220fc9de9df2e34692f20f3382b32 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 825146ce6ab80fbb46ec43fcfec1c6e2dac55157 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 9f810c0e15ac99af68e114a0ee4e32c4c7067e2b 172.38.0.14:6379</span><br><span class="line">   replicates 825146ce6ab80fbb46ec43fcfec1c6e2dac55157</span><br><span class="line">S: e370225bf57d6ef6d54ad8e3d5d745a52b382d1a 172.38.0.15:6379</span><br><span class="line">   replicates c5551e2a30c220fc9de9df2e34692f20f3382b32</span><br><span class="line">S: 79428c1d018dd29cf191678658008cbe5100b714 172.38.0.16:6379</span><br><span class="line">   replicates d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">....</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)</span></span><br><span class="line">M: c5551e2a30c220fc9de9df2e34692f20f3382b32 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 79428c1d018dd29cf191678658008cbe5100b714 172.38.0.16:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b</span><br><span class="line">M: d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e370225bf57d6ef6d54ad8e3d5d745a52b382d1a 172.38.0.15:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates c5551e2a30c220fc9de9df2e34692f20f3382b32</span><br><span class="line">S: 9f810c0e15ac99af68e114a0ee4e32c4c7067e2b 172.38.0.14:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 825146ce6ab80fbb46ec43fcfec1c6e2dac55157</span><br><span class="line">M: 825146ce6ab80fbb46ec43fcfec1c6e2dac55157 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>docker搭建redis集群完成！</p>
<p><img src="/static/img/docker2/image-20200614141549867.png" alt="image-20200614141549867"></p>
<p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p>
<hr>
<h1 id="Springboot微服务打包Docker镜像"><a href="#Springboot微服务打包Docker镜像" class="headerlink" title="Springboot微服务打包Docker镜像"></a>Springboot微服务打包Docker镜像</h1><p>1、构建springboot项目，打包应用</p>
<p><img src="/static/img/docker2/image-20200614155721369.png" alt="image-20200614155721369"></p>
<p>2、编写Dockerfile，连同项目的jar包一并上传指定目录下</p>
<p><img src="/static/img/docker2/image-20200614153734161.png" alt="image-20200614153734161"></p>
<p><img src="/static/img/docker2/image-20200614154114656.png" alt="image-20200614154114656"></p>
<p>3、构建镜像</p>
<p><img src="/static/img/docker2/image-20200614154355597.png" alt="image-20200614154355597"></p>
<p>4、创建项目容器，发布运行！！！</p>
<p><img src="/static/img/docker2/image-20200614155034087.png" alt="image-20200614155034087"></p>
<p><img src="/static/img/docker2/image-20200614155340519.png" alt="image-20200614155340519"></p>
<p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署ES+SpringBoot+Mysql+Reids+Node.js</title>
    <url>//post/30091.html</url>
    <content><![CDATA[<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:10.16-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'8081:8080'</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/www/wwwroot/admin</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 文件夹映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/admin:/www/wwwroot/admin</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"npm config set unsafe-perm true &amp;&amp; npm config set registry http://registry.npm.taobao.org &amp;&amp; npm install echarts -S &amp;&amp; npm install webpack-dev-server -g &amp;&amp; npm install webpack-dev-server -g &amp;&amp; npm i &amp;&amp; npm run dev"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:10.16-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">client</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'8080:8080'</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/www/wwwroot/client</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 文件夹映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/client:/www/wwwroot/client</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"npm config set unsafe-perm true &amp;&amp; npm config set registry http://registry.npm.taobao.org &amp;&amp;npm install webpack-dev-server -g &amp;&amp; npm install webpack-dev-server -g  &amp;&amp; npm i --unsafe-perm &amp;&amp; npm run dev"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">springboot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openjdk:8-jdk-alpine</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/www/wwwroot/java</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">springboot</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'8088:8088'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 容器数据卷挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/java/fmall-0.0.1-SNAPSHOT.jar:/www/wwwroot/java/app.jar</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"nohup java -jar app.jar"</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span> <span class="comment"># 挂载数据目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/conf:/etc/mysql/conf.d</span> <span class="comment"># 挂载配置文件目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/logs:/var/log/mysql</span> <span class="comment"># 挂载配置文件目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="string">'true'</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/mysql.env</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7000:7000'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 文件夹映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span> <span class="comment"># nginx站点配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot:/etc/nginx/sites-available</span> <span class="comment"># 宿主:docker:只读  ,www目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span> <span class="comment"># nginx配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/logs:/var/log/nginx</span> <span class="comment"># 网站日志文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时间</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot:/www/wwwroot</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springboot</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">client</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.6.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line"><span class="comment">#      - discovery.seed_hosts=192.168.0.1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=elasticsearch</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'ES_JAVA_OPTS=-Xms1g -Xmx1g'</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/data:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/logs:/usr/share/elasticsearch/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./elasticsearch/elastic-certificates.p12:/usr/share/elasticsearch/config/elastic-certificates.p12</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<blockquote>
<p>相关教程：<a href="https://www.cnblogs.com/woshimrf/p/docker-es7.html" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/p/docker-es7.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Docker部署acmh.sh实现证书签发</title>
    <url>//post/822.html</url>
    <content><![CDATA[<h1 id="1、启动容器"><a href="#1、启动容器" class="headerlink" title="1、启动容器"></a>1、启动容器</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">acme.sh:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">neilpang/acme.sh</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">acme.sh</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">daemon</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Ali_Key=xxxxxxxx</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Ali_Secret=xxxxxxxxxx</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/nginx/ssl:/acme.sh</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<h1 id="2、申请证书"><a href="#2、申请证书" class="headerlink" title="2、申请证书"></a>2、申请证书</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">docker</span> <span class="string">exec</span> <span class="string">acme.sh</span> <span class="string">--issue</span> <span class="string">--dns</span> <span class="string">dns_ali</span> <span class="string">-d</span> <span class="string">example.com</span> <span class="string">-d</span> <span class="string">'*.example.com'</span> <span class="string">--keylength</span> <span class="string">ec-384</span></span><br></pre></td></tr></table></figure>

<h1 id="3、定时任务自动续签"><a href="#3、定时任务自动续签" class="headerlink" title="3、定时任务自动续签"></a>3、定时任务自动续签</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3.4 设置 crontab 任务自动续签</span><br><span class="line">运行 crontab -e 来编辑 crontab 文件，添加如下内容，保存即可</span><br><span class="line">每隔30自动更新证书</span><br><span class="line">0 0 */30 * * docker exec acme.sh --cron	--force &gt; /dev/null &amp;&amp; docker restart nginx	# acme.sh为容器名</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask在Windows下面运行的注意事项</title>
    <url>//post/32613.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Flask对象配置</title>
    <url>//post/53944.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;DEBUG&#39;: False,  # 是否开启Debug模式</span><br><span class="line">　　&#39;TESTING&#39;: False,  # 是否开启测试模式</span><br><span class="line">　　&#39;SECRET_KEY&#39;: None # 在启用Flask内置Session的时候&#x2F;开启flash,一定要有它</span><br><span class="line">　　&#39;PERMANENT_SESSION_LIFETIME&#39;: 31,  # days , Session的生命周期(天)默认31天</span><br><span class="line">　　&#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;,  # 在cookies中存放session加密字符串的名字</span><br><span class="line"></span><br><span class="line">　　&#39;PROPAGATE_EXCEPTIONS&#39;: None,  # 异常传播(是否在控制台打印LOG) 当Debug或者testing开启后,自动为True</span><br><span class="line">　　&#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None,  # 一两句话说不清楚,一般不用它</span><br><span class="line">　　&#39;SECRET_KEY&#39;: None,  # 之前遇到过,在启用Session的时候,一定要有它</span><br><span class="line">　　&#39;PERMANENT_SESSION_LIFETIME&#39;: 31,  # days , Session的生命周期(天)默认31天</span><br><span class="line">　　&#39;USE_X_SENDFILE&#39;: False,  # 是否弃用 x_sendfile</span><br><span class="line">　　&#39;LOGGER_NAME&#39;: None,  # 日志记录器的名称</span><br><span class="line">　　&#39;LOGGER_HANDLER_POLICY&#39;: &#39;always&#39;,</span><br><span class="line">　　&#39;SERVER_NAME&#39;: None,  # 服务访问域名</span><br><span class="line">　　&#39;APPLICATION_ROOT&#39;: None,  # 项目的完整路径</span><br><span class="line">　　&#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;,  # 在cookies中存放session加密字符串的名字</span><br><span class="line">　　&#39;SESSION_COOKIE_DOMAIN&#39;: None,  # 在哪个域名下会产生session记录在cookies中</span><br><span class="line">　　&#39;SESSION_COOKIE_PATH&#39;: None,  # cookies的路径</span><br><span class="line">　　&#39;SESSION_COOKIE_HTTPONLY&#39;: True,  # 控制 cookie 是否应被设置 httponly 的标志，</span><br><span class="line">　　&#39;SESSION_COOKIE_SECURE&#39;: False,  # 控制 cookie 是否应被设置安全标志</span><br><span class="line">　　&#39;SESSION_REFRESH_EACH_REQUEST&#39;: True,  # 这个标志控制永久会话如何刷新</span><br><span class="line">　　&#39;MAX_CONTENT_LENGTH&#39;: None,  # 如果设置为字节数， Flask 会拒绝内容长度大于此值的请求进入，并返回一个 413 状态码</span><br><span class="line">　　&#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: 12,  # hours 默认缓存控制的最大期限</span><br><span class="line">　　&#39;TRAP_BAD_REQUEST_ERRORS&#39;: False,</span><br><span class="line">　　# 如果这个值被设置为 True ，Flask不会执行 HTTP 异常的错误处理，而是像对待其它异常一样，</span><br><span class="line">　　# 通过异常栈让它冒泡地抛出。这对于需要找出 HTTP 异常源头的可怕调试情形是有用的。</span><br><span class="line">　　&#39;TRAP_HTTP_EXCEPTIONS&#39;: False,</span><br><span class="line">　　# Werkzeug 处理请求中的特定数据的内部数据结构会抛出同样也是“错误的请求”异常的特殊的 key errors 。</span><br><span class="line">　　# 同样地，为了保持一致，许多操作可以显式地抛出 BadRequest 异常。</span><br><span class="line">　　# 因为在调试中，你希望准确地找出异常的原因，这个设置用于在这些情形下调试。</span><br><span class="line">　　&#39;EXPLAIN_TEMPLATE_LOADING&#39;: False,  # 如果这个值被设置为True，你只会得到常规的回溯。</span><br><span class="line">　　&#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;,  # 生成URL的时候如果没有可用的 URL 模式话将使用这个值</span><br><span class="line">　　&#39;JSON_AS_ASCII&#39;: True,</span><br><span class="line">　　# 默认情况下 Flask 使用 ascii 编码来序列化对象。如果这个值被设置为 False ，</span><br><span class="line">　　# Flask不会将其编码为 ASCII，并且按原样输出，返回它的 unicode 字符串。</span><br><span class="line">　　# 比如 jsonfiy 会自动地采用 utf-8 来编码它然后才进行传输。</span><br><span class="line">　　&#39;JSON_SORT_KEYS&#39;: True,</span><br><span class="line">　　# 默认情况下 Flask 按照 JSON 对象的键的顺序来序来序列化它。</span><br><span class="line">　　# 这样做是为了确保键的顺序不会受到字典的哈希种子的影响，从而返回的值每次都是一致的，不会造成无用的额外 HTTP 缓存。</span><br><span class="line">　　# 你可以通过修改这个配置的值来覆盖默认的操作。但这是不被推荐的做法因为这个默认的行为可能会给你在性能的代价上带来改善。</span><br><span class="line">　　&#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: True,</span><br><span class="line">　　&#39;JSONIFY_MIMETYPE&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">　　&#39;TEMPLATES_AUTO_RELOAD&#39;: None,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker概述(1)</title>
    <url>//post/49388.html</url>
    <content><![CDATA[<blockquote>
<p>Docker学习</p>
</blockquote><ul>
<li><p>Docker概述</p>
</li>
<li><p>Docker安装</p>
</li>
<li><p>Docker命令</p>
<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>……</li>
</ul>
</li>
<li><p>Docker镜像</p>
</li>
<li><p>容器数据卷</p>
</li>
<li><p>DockerFile</p>
</li>
<li><p>Docker网络原理</p>
</li>
<li><p>Idea整合Docker</p>
</li>
<li><p>Docker Compose</p>
</li>
<li><p>Docker Swarm</p>
</li>
<li><p>CI\CD Jenkins</p>
</li>
</ul><a id="more"></a>

<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么会出现？"><a href="#Docker为什么会出现？" class="headerlink" title="Docker为什么会出现？"></a>Docker为什么会出现？</h2><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p>
<p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p>
<p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p>
<p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p>
<p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p>
<p>开发环境Windows，最后发布到Linux！</p>
<p><strong>传统：</strong>开发jar，运维来做！</p>
<p><strong>现在：</strong>开发打包部署上线，一套流程做完！</p>
<p><strong>安卓流程：</strong>java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p>
<p><strong>docker流程：</strong> java-jar（环境）— 打包项目帯上环境（镜像）— ( Docker仓库：商店）—下载我们发布的镜像 —直接运行即可！</p>
<p>Docker给以上的问题，提出了解决方案！</p>
<p><img src="/static/img/docker1/image-20200610142308099.png" alt="image-20200610142308099"></p>
<p>Docker的思想来源于集装箱！</p>
<p>JRE —多个应用（端口冲突）—原来都是交叉的！</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子都是相互隔离的。</p>
<p>Docker通过隔离机制可以将服务器利用到极致！</p>
<p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p>
<h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010年，几个的年轻人，就在美国成立了一家公司 <strong>dotcloud</strong></p>
<p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p>
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p>
<p>他们将自己的技术（容器化技术）命名就是 Docker</p>
<p>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p>
<p><strong>开源</strong></p>
<p>2013年，Docker开源！</p>
<p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p>
<p>2014年4月9日，Docker1.0发布！</p>
<p>docker为什么这么火？十分的轻巧！</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术！</p>
<p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟</span><br><span class="line">docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聊聊Docker</p>
</blockquote>
<p>Docker基于Go语言开发的！开源项目！</p>
<p>docker官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p>
<p><img src="/static/img/docker1/image-20200610143923433.png" alt="image-20200610143923433"></p>
<p>文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a> Docker的文档是超级详细的！</p>
<p>仓库：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><blockquote>
<p>之前的虚拟机技术</p>
</blockquote>
<p><img src="/static/img/docker1/image-20200610144126122.png" alt="image-20200610144126122"></p>
<blockquote>
<p>虚拟机技术缺点</p>
</blockquote>
<p>1、 资源占用十分多</p>
<p>2、 冗余步骤多</p>
<p>3、 启动很慢！</p>
<blockquote>
<p>容器技术</p>
</blockquote>
<p>容器化技术不是模拟一个完整的操作系统</p>
<p><img src="/static/img/docker1/image-20200610144338073.png" alt="image-20200610144338073"></p>
<p>比较Docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一套容器内的应用直接运行在宿主机硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机内，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<blockquote>
<p>DevOps (开发、运维)</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装程序</p>
<p>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了Docker之后，我们部署应用就和搭积木一样！</p>
<p>项目打包为一个镜像，扩展服务器A! 服务器B</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，我们的开发，测试环境都是高度一致的。</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多个容器实例！服务器的性能可以被压榨到极致。</p>
<hr>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><img src="/static/img/docker1/image-20200610145818895.png" alt="image-20200610145818895"></p>
<p><strong>镜像（image）：</strong></p>
<p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==&gt;run==&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p>
<p><strong>容器（container）:</strong></p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.</p>
<p>启动，停止，删除，基本命令</p>
<p>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p>
<p><strong>仓库（repository）:</strong></p>
<p>仓库就是存放镜像的地方！</p>
<p>仓库分为公有仓库和私有仓库。(很类似git)</p>
<p>Docker Hub是国外的。</p>
<p>阿里云…都有容器服务器 (配置镜像加速!)</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote>
<p>环境准备</p>
</blockquote>
<p>1.Linux要求内核3.0以上</p>
<p>2.CentOS 7</p>
<blockquote>
<p>环境查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">系统内核要求3.0以上</span></span><br><span class="line">[root@localhost ~]# uname -r</span><br><span class="line">3.10.0-1062.el7.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">系统版本</span></span><br><span class="line">[root@localhost ~]# cat /etc/os-release </span><br><span class="line">NAME="CentOS Linux"</span><br><span class="line">VERSION="7 (Core)"</span><br><span class="line">ID="centos"</span><br><span class="line">ID_LIKE="rhel fedora"</span><br><span class="line">VERSION_ID="7"</span><br><span class="line">PRETTY_NAME="CentOS Linux 7 (Core)"</span><br><span class="line">ANSI_COLOR="0;31"</span><br><span class="line">CPE_NAME="cpe:/o:centos:centos:7"</span><br><span class="line">HOME_URL="https://www.centos.org/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.centos.org/"</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT="CentOS-7"</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION="7"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT="centos"</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION="7"</span><br></pre></td></tr></table></figure>



<blockquote>
<p>安装</p>
</blockquote>
<p>帮助文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.卸载旧版本</span></span><br><span class="line"> yum remove docker \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-client \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-client-latest \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-common \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-latest \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-latest-logrotate \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-logrotate \</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">                   docker-engine</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推荐使用国内的</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">更新软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.安装docker docker-ce 社区版 而ee是企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5.启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6.使用docker version 查看是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200610153718450.png" alt="image-20200610153718450"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">7.测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200610154108118.png" alt="image-20200610154108118"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">8.查看一下下载的hello-world镜像</span></span><br><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago        13.3kB</span><br></pre></td></tr></table></figure>

<p>了解：卸载docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 删除资源</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/docker 是docker的默认工作路径！</span></span><br></pre></td></tr></table></figure>

<p>阿里云镜像加速</p>
<p><strong>1、登录阿里云找到容器服务——&gt;镜像加速器</strong></p>
<p><img src="/static/img/docker1/image-20200610155156310.png" alt="image-20200610155156310"></p>
<p><strong>2、配置使用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://cdoid6va.mirror.aliyuncs.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="回顾hello-world流程"><a href="#回顾hello-world流程" class="headerlink" title="回顾hello-world流程"></a>回顾hello-world流程</h2><p><img src="/static/img/docker1/image-20200610160359287.png" alt="image-20200610160359287"></p>
<p><strong>docker run 流程图</strong></p>
<p><img src="/static/img/docker1/image-20200610160609037.png" alt="image-20200610160609037"></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker是怎么工作的？</strong></p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在宿主机上，通过Socket从客户端访问！</p>
<p>DockerServer接受到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="/static/img/docker1/image-20200610161147612.png" alt="image-20200610161147612"></p>
<p><strong>Docker为什么比VM快？</strong></p>
<p>1、Docker有着比虚拟机更少的抽象层</p>
<p>2、Docker利用的是宿主机的内核，vm需要Guest Os。</p>
<p><img src="/static/img/docker1/image-20200610161342662.png" alt="image-20200610161342662"></p>
<p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest Os，分钟级别的，而docker是利用当前宿主机的操作系统，省略了复杂的过程，秒级的！</p>
<p><img src="/static/img/docker1/image-20200610161845790.png" alt="image-20200610161845790"></p>
<hr>
<h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version     # 显示docker的版本信息</span><br><span class="line">docker info        # 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help  # 帮助命令</span><br></pre></td></tr></table></figure>

<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago        13.3kB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解释</span></span><br><span class="line">REPOSITORY  镜像的仓库源</span><br><span class="line">TAG         镜像标签</span><br><span class="line">IMAGE ID    镜像id</span><br><span class="line">CREATED     镜像的创建时间</span><br><span class="line">SIZE        镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             # 列出所有镜像</span><br><span class="line">  -q, --quiet           # 只显示镜像id</span><br></pre></td></tr></table></figure>

<p><strong>docker search 搜索镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   9604                [OK]                </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3490                [OK]                </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可选项，通过收藏来过滤</span></span><br><span class="line">--filter=STARS=3000  #搜索出来的镜像就是STARS大于3000的</span><br><span class="line">[root@localhost /]# docker search mysql --filter=STARS=3000</span><br><span class="line">NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql               MySQL is a widely used, open-source relation…   9604                [OK]                </span><br><span class="line">mariadb             MariaDB is a community-developed fork of MyS…   3490                [OK]</span><br></pre></td></tr></table></figure>

<p><strong>docker pull 下载镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">[root@localhost /]# docker pull mysql</span><br><span class="line">Using default tag: latest    # 如果不写 tag,默认就是latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">8559a31e96f4: Pull complete  # 分层下载，docker image的核心 联合文件系统</span><br><span class="line">d51ce1c2e575: Pull complete </span><br><span class="line">c2344adc4858: Pull complete </span><br><span class="line">fcf3ceff18fc: Pull complete </span><br><span class="line">16da0c38dc5b: Pull complete </span><br><span class="line">b905d1797e97: Pull complete </span><br><span class="line">4b50d1c6b05c: Pull complete </span><br><span class="line">c75914a65ca2: Pull complete </span><br><span class="line">1ae8042bdd09: Pull complete </span><br><span class="line">453ac13c00a3: Pull complete </span><br><span class="line">9e680cd72f08: Pull complete </span><br><span class="line">a6b5dc864b6c: Pull complete </span><br><span class="line">Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6 # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest  # 真实地址</span><br><span class="line"></span><br><span class="line">docker pull mysql 等价于: docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载</span></span><br><span class="line">[root@localhost /]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">8559a31e96f4: Already exists   # 联合文件系统的好处：上面下载过的MySQL与5.7版本的MySQL有相同的文件时不需要重复下载</span><br><span class="line">d51ce1c2e575: Already exists </span><br><span class="line">c2344adc4858: Already exists </span><br><span class="line">fcf3ceff18fc: Already exists </span><br><span class="line">16da0c38dc5b: Already exists </span><br><span class="line">b905d1797e97: Already exists </span><br><span class="line">4b50d1c6b05c: Already exists </span><br><span class="line">d85174a87144: Pull complete </span><br><span class="line">a4ad33703fa8: Pull complete </span><br><span class="line">f7a5433ce20d: Pull complete </span><br><span class="line">3dcd2a278b4a: Pull complete </span><br><span class="line">Digest: sha256:32f9d9a069f7a735e28fd44ea944d53c61f990ba71460c5c183e610854ca4854</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200610165130055.png" alt="image-20200610165130055"></p>
<p><strong>docker rmi 删除镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker rmi -f 镜像id  				 #删除指定镜像</span><br><span class="line">[root@localhost /]# docker rmi -f 镜像id 镜像id 镜像id  	   #删除多个镜像</span><br><span class="line">[root@localhost /]# docker rmi -f $(docker images -aq)     #删除全部镜像</span><br></pre></td></tr></table></figure>

<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：有了镜像才可以创建容器，linux,下载一个centos镜像来学习</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name="Name"	容器名字 tomcat01 tomcat02 ，用来区分容器</span><br><span class="line">-d              后台方式运行</span><br><span class="line">-it             使用交互方式运行，进入容器查看内容</span><br><span class="line">-p              指定容器的端口 -p 8080:80</span><br><span class="line">	-p  ip:主机(即宿主机)端口：容器端口</span><br><span class="line">	-p  主机端口：容器端口  #这种方式常用</span><br><span class="line">	-p  容器端口</span><br><span class="line">	容器端口P</span><br><span class="line">-P              随机指定端口(大写P)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试，启动并进入容器</span></span><br><span class="line">[root@localhost /]# docker run -it centos /bin/bash</span><br><span class="line">[root@8b4c74381205 /]# ls     #查看容器内的centos,基础版本，很多命令都是不完善的！</span><br><span class="line">bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器中退回主机</span></span><br><span class="line">[root@8b4c74381205 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost /]# ls</span><br><span class="line">123  bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">222  boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps 命令</span></span><br><span class="line">(不加） # 列出当前正在运行的容器</span><br><span class="line">-a     # 列出当前正在运行的容器 + 带出历史运行过的容器</span><br><span class="line">-n=?   # 显示最近创建的容器</span><br><span class="line">-q    # 只显示当前容器的编号</span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@localhost /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">8b4c74381205        centos              "/bin/bash"         4 minutes ago       Exited (0) About a minute ago                       epic_wilson</span><br><span class="line">fb87667bbc19        bf756fb1ae65        "/hello"            2 hours ago         Exited (0) 2 hours ago                              awesome_banach</span><br><span class="line">[root@localhost /]# docker ps -a -n=1</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">8b4c74381205        centos              "/bin/bash"         9 minutes ago       Exited (0) 6 minutes ago                       epic_wilson</span><br><span class="line">[root@localhost /]# docker ps -aq</span><br><span class="line">8b4c74381205</span><br><span class="line">fb87667bbc19</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit   # 直接退出容器</span><br><span class="line">Ctrl + p + q  # 容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id				   # 删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)    # 删除所有容器 </span><br><span class="line">docker ps -a -q|xargs docker rm  # 删除所有容器</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器的操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id     # 启动容器</span><br><span class="line">docker restart 容器id   # 重启容器</span><br><span class="line">docker stop 容器id      # 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id      # 强制停止当前正在运行的容器</span><br></pre></td></tr></table></figure>

<h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span></span><br><span class="line"></span><br><span class="line">[root@localhost /]# docker run -d centos</span><br><span class="line">e9d60f206fa19963203db6c42c2f83c5120eb90eeee2b7ba9fdc4589370fd6b6</span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题docker ps,发现 centos 停止了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx,容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 数字 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示日志</span></span><br><span class="line">-tf 	# 显示日志</span><br><span class="line">--tail  # 要显示的日志条数</span><br><span class="line">[root@localhost /]# docker logs -tf --tail 10 ce989f90023d</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker top 容器id</span></span><br><span class="line">[root@localhost /]# docker top ce989f90023d</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME     </span><br><span class="line">root                12249               12232               0                   22:44               pts/0               00:00:00</span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost /]# docker inspect ce989f90023d</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244",</span><br><span class="line">        "Created": "2020-06-10T14:44:45.025360147Z",</span><br><span class="line">        "Path": "/bin/bash",</span><br><span class="line">        "Args": [],</span><br><span class="line">        "State": &#123;</span><br><span class="line">            "Status": "running",</span><br><span class="line">            "Running": true,</span><br><span class="line">            "Paused": false,</span><br><span class="line">            "Restarting": false,</span><br><span class="line">            "OOMKilled": false,</span><br><span class="line">            "Dead": false,</span><br><span class="line">            "Pid": 12249,</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Error": "",</span><br><span class="line">            "StartedAt": "2020-06-10T14:44:45.770227584Z",</span><br><span class="line">            "FinishedAt": "0001-01-01T00:00:00Z"</span><br><span class="line">        &#125;,</span><br><span class="line">        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",</span><br><span class="line">        "ResolvConfPath": "/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/resolv.conf",</span><br><span class="line">        "HostnamePath": "/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/hostname",</span><br><span class="line">        "HostsPath": "/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/hosts",</span><br><span class="line">        "LogPath": "/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244-json.log",</span><br><span class="line">        "Name": "/nifty_johnson",</span><br><span class="line">        "RestartCount": 0,</span><br><span class="line">        "Driver": "overlay2",</span><br><span class="line">        "Platform": "linux",</span><br><span class="line">        "MountLabel": "",</span><br><span class="line">        "ProcessLabel": "",</span><br><span class="line">        "AppArmorProfile": "",</span><br><span class="line">        "ExecIDs": null,</span><br><span class="line">        "HostConfig": &#123;</span><br><span class="line">            "Binds": null,</span><br><span class="line">            "ContainerIDFile": "",</span><br><span class="line">            "LogConfig": &#123;</span><br><span class="line">                "Type": "json-file",</span><br><span class="line">                "Config": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "NetworkMode": "default",</span><br><span class="line">            "PortBindings": &#123;&#125;,</span><br><span class="line">            "RestartPolicy": &#123;</span><br><span class="line">                "Name": "no",</span><br><span class="line">                "MaximumRetryCount": 0</span><br><span class="line">            &#125;,</span><br><span class="line">            "AutoRemove": false,</span><br><span class="line">            "VolumeDriver": "",</span><br><span class="line">            "VolumesFrom": null,</span><br><span class="line">            "CapAdd": null,</span><br><span class="line">            "CapDrop": null,</span><br><span class="line">            "Capabilities": null,</span><br><span class="line">            "Dns": [],</span><br><span class="line">            "DnsOptions": [],</span><br><span class="line">            "DnsSearch": [],</span><br><span class="line">            "ExtraHosts": null,</span><br><span class="line">            "GroupAdd": null,</span><br><span class="line">            "IpcMode": "private",</span><br><span class="line">            "Cgroup": "",</span><br><span class="line">            "Links": null,</span><br><span class="line">            "OomScoreAdj": 0,</span><br><span class="line">            "PidMode": "",</span><br><span class="line">            "Privileged": false,</span><br><span class="line">            "PublishAllPorts": false,</span><br><span class="line">            "ReadonlyRootfs": false,</span><br><span class="line">            "SecurityOpt": null,</span><br><span class="line">            "UTSMode": "",</span><br><span class="line">            "UsernsMode": "",</span><br><span class="line">            "ShmSize": 67108864,</span><br><span class="line">            "Runtime": "runc",</span><br><span class="line">            "ConsoleSize": [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            "Isolation": "",</span><br><span class="line">            "CpuShares": 0,</span><br><span class="line">            "Memory": 0,</span><br><span class="line">            "NanoCpus": 0,</span><br><span class="line">            "CgroupParent": "",</span><br><span class="line">            "BlkioWeight": 0,</span><br><span class="line">            "BlkioWeightDevice": [],</span><br><span class="line">            "BlkioDeviceReadBps": null,</span><br><span class="line">            "BlkioDeviceWriteBps": null,</span><br><span class="line">            "BlkioDeviceReadIOps": null,</span><br><span class="line">            "BlkioDeviceWriteIOps": null,</span><br><span class="line">            "CpuPeriod": 0,</span><br><span class="line">            "CpuQuota": 0,</span><br><span class="line">            "CpuRealtimePeriod": 0,</span><br><span class="line">            "CpuRealtimeRuntime": 0,</span><br><span class="line">            "CpusetCpus": "",</span><br><span class="line">            "CpusetMems": "",</span><br><span class="line">            "Devices": [],</span><br><span class="line">            "DeviceCgroupRules": null,</span><br><span class="line">            "DeviceRequests": null,</span><br><span class="line">            "KernelMemory": 0,</span><br><span class="line">            "KernelMemoryTCP": 0,</span><br><span class="line">            "MemoryReservation": 0,</span><br><span class="line">            "MemorySwap": 0,</span><br><span class="line">            "MemorySwappiness": null,</span><br><span class="line">            "OomKillDisable": false,</span><br><span class="line">            "PidsLimit": null,</span><br><span class="line">            "Ulimits": null,</span><br><span class="line">            "CpuCount": 0,</span><br><span class="line">            "CpuPercent": 0,</span><br><span class="line">            "IOMaximumIOps": 0,</span><br><span class="line">            "IOMaximumBandwidth": 0,</span><br><span class="line">            "MaskedPaths": [</span><br><span class="line">                "/proc/asound",</span><br><span class="line">                "/proc/acpi",</span><br><span class="line">                "/proc/kcore",</span><br><span class="line">                "/proc/keys",</span><br><span class="line">                "/proc/latency_stats",</span><br><span class="line">                "/proc/timer_list",</span><br><span class="line">                "/proc/timer_stats",</span><br><span class="line">                "/proc/sched_debug",</span><br><span class="line">                "/proc/scsi",</span><br><span class="line">                "/sys/firmware"</span><br><span class="line">            ],</span><br><span class="line">            "ReadonlyPaths": [</span><br><span class="line">                "/proc/bus",</span><br><span class="line">                "/proc/fs",</span><br><span class="line">                "/proc/irq",</span><br><span class="line">                "/proc/sys",</span><br><span class="line">                "/proc/sysrq-trigger"</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "GraphDriver": &#123;</span><br><span class="line">            "Data": &#123;</span><br><span class="line">                "LowerDir": "/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641-init/diff:/var/lib/docker/overlay2/d4cd3bedb1e7340e62bb292c1e0d5ae37b1d1689ffc1640da67b2a8325facc21/diff",</span><br><span class="line">                "MergedDir": "/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/merged",</span><br><span class="line">                "UpperDir": "/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/diff",</span><br><span class="line">                "WorkDir": "/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/work"</span><br><span class="line">            &#125;,</span><br><span class="line">            "Name": "overlay2"</span><br><span class="line">        &#125;,</span><br><span class="line">        "Mounts": [],</span><br><span class="line">        "Config": &#123;</span><br><span class="line">            "Hostname": "ce989f90023d",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": true,</span><br><span class="line">            "AttachStdout": true,</span><br><span class="line">            "AttachStderr": true,</span><br><span class="line">            "Tty": true,</span><br><span class="line">            "OpenStdin": true,</span><br><span class="line">            "StdinOnce": true,</span><br><span class="line">            "Env": [</span><br><span class="line">                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><br><span class="line">            ],</span><br><span class="line">            "Cmd": [</span><br><span class="line">                "/bin/bash"</span><br><span class="line">            ],</span><br><span class="line">            "Image": "centos",</span><br><span class="line">            "Volumes": null,</span><br><span class="line">            "WorkingDir": "",</span><br><span class="line">            "Entrypoint": null,</span><br><span class="line">            "OnBuild": null,</span><br><span class="line">            "Labels": &#123;</span><br><span class="line">                "org.label-schema.build-date": "20200114",</span><br><span class="line">                "org.label-schema.license": "GPLv2",</span><br><span class="line">                "org.label-schema.name": "CentOS Base Image",</span><br><span class="line">                "org.label-schema.schema-version": "1.0",</span><br><span class="line">                "org.label-schema.vendor": "CentOS",</span><br><span class="line">                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",</span><br><span class="line">                "org.opencontainers.image.licenses": "GPL-2.0-only",</span><br><span class="line">                "org.opencontainers.image.title": "CentOS Base Image",</span><br><span class="line">                "org.opencontainers.image.vendor": "CentOS"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "NetworkSettings": &#123;</span><br><span class="line">            "Bridge": "",</span><br><span class="line">            "SandboxID": "74d140bbc60432c5fdce865fa48f78c1138923dd292e708a25c4de17de812d56",</span><br><span class="line">            "HairpinMode": false,</span><br><span class="line">            "LinkLocalIPv6Address": "",</span><br><span class="line">            "LinkLocalIPv6PrefixLen": 0,</span><br><span class="line">            "Ports": &#123;&#125;,</span><br><span class="line">            "SandboxKey": "/var/run/docker/netns/74d140bbc604",</span><br><span class="line">            "SecondaryIPAddresses": null,</span><br><span class="line">            "SecondaryIPv6Addresses": null,</span><br><span class="line">            "EndpointID": "3580dd1064b07f434c61e316f14cb7d7b53a3d6d7c9c0f77eb6570f1781623bc",</span><br><span class="line">            "Gateway": "172.17.0.1",</span><br><span class="line">            "GlobalIPv6Address": "",</span><br><span class="line">            "GlobalIPv6PrefixLen": 0,</span><br><span class="line">            "IPAddress": "172.17.0.3",</span><br><span class="line">            "IPPrefixLen": 16,</span><br><span class="line">            "IPv6Gateway": "",</span><br><span class="line">            "MacAddress": "02:42:ac:11:00:03",</span><br><span class="line">            "Networks": &#123;</span><br><span class="line">                "bridge": &#123;</span><br><span class="line">                    "IPAMConfig": null,</span><br><span class="line">                    "Links": null,</span><br><span class="line">                    "Aliases": null,</span><br><span class="line">                    "NetworkID": "58fd9703e96d12128c30f244be3205e3fe31fc7d1fb7fffdddba72d981e782f4",</span><br><span class="line">                    "EndpointID": "3580dd1064b07f434c61e316f14cb7d7b53a3d6d7c9c0f77eb6570f1781623bc",</span><br><span class="line">                    "Gateway": "172.17.0.1",</span><br><span class="line">                    "IPAddress": "172.17.0.3",</span><br><span class="line">                    "IPPrefixLen": 16,</span><br><span class="line">                    "IPv6Gateway": "",</span><br><span class="line">                    "GlobalIPv6Address": "",</span><br><span class="line">                    "GlobalIPv6PrefixLen": 0,</span><br><span class="line">                    "MacAddress": "02:42:ac:11:00:03",</span><br><span class="line">                    "DriverOpts": null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost /]# docker exec -it ce989f90023d /bin/bash</span><br><span class="line">[root@ce989f90023d /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@ce989f90023d /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 14:44 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         15      0  0 15:19 pts/1    00:00:00 /bin/bash</span><br><span class="line">root         29     15  0 15:20 pts/1    00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost /]# docker attach ce989f90023d</span><br><span class="line">正在执行当前的代码...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span>		<span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker attach 	<span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内目标文件路径  目的主机路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前主机目录</span></span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">ztx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入docker容器内部</span></span><br><span class="line">[root@localhost home]# docker attach ce989f90023d</span><br><span class="line">[root@ce989f90023d /]# cd /home/</span><br><span class="line">[root@ce989f90023d home]# ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器内新建一个文件</span></span><br><span class="line">[root@ce989f90023d home]# touch test.java</span><br><span class="line">[root@ce989f90023d home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost home]# docker ps -a</span><br><span class="line">CONTAINER ID     IMAGE      COMMAND       CREATED           STATUS                PORTS           NAMES</span><br><span class="line">ce989f90023d     centos  "/bin/bash"  44 minutes ago  Exited (0) 46 seconds ago               nifty_johnson</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将docker内文件拷贝到主机上</span></span><br><span class="line">[root@localhost home]# docker cp ce989f90023d:/home/test.java /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">test.java  ztx</span><br><span class="line">[root@localhost home]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="C:%5CUsers%5CZTX%5CDesktop%5Cmarkdownx%E5%AD%A6%E4%B9%A0%5CDocker%E6%A6%82%E8%BF%B0(1).assets%5Cimage-20200611085918923.png" alt="image-20200611085918923"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">attach      Attach to a running container 	      # 当前shell下attach连接指定运行的镜像</span><br><span class="line">build       Build an image from a Dockerfile        # 通过Dockerfile定制镜像</span><br><span class="line">commit      Create a new image from a container changes  #提交当前容器为新的镜像</span><br><span class="line">cp          Copy files/folders between a container and the local filesystem #从容器中拷贝指定文件或目录到宿主机中</span><br><span class="line">create      Create a new container 				  # 创建一个新的容器，同run,但不启动容器</span><br><span class="line">diff        Inspect changes to files or directories on a container's filesystem #查看docker容器的变化</span><br><span class="line">events      Get real time events from the server 	  # 从docker服务获取容器实时事件</span><br><span class="line">exec        Run a command in a running container    # 在已存在的容器上运行命令</span><br><span class="line">export      Export a container filesystem as a tar archive # 导出容器的内容流作为一个tar归档文件[对应import]</span><br><span class="line">history     Show the history of an image            # 展示一个镜像形成历史</span><br><span class="line">images      List images                             # 列出系统当前的镜像</span><br><span class="line">import      Import the contents from a tarball to create a filesystem image # 从tar包中的内容创建一个新的文件系统镜像[对应export]</span><br><span class="line">info        Display system-wide information         # 显示系统相关信息</span><br><span class="line">inspect     Return low-level information on Docker objects # 查看容器详细信息</span><br><span class="line">kill        Kill one or more running containers     # 杀死指定的docker容器</span><br><span class="line">load        Load an image from a tar archive or STDIN # 从一个tar包加载一个镜像[对应save]</span><br><span class="line">login       Log in to a Docker registry			  # 注册或者登录一个docker源服务器</span><br><span class="line">logout      Log out from a Docker registry		  # 从当前Docker registry退出</span><br><span class="line">logs        Fetch the logs of a container			  # 输出当前容器日志信息</span><br><span class="line">pause       Pause all processes within one or more containers 	     # 暂停容器</span><br><span class="line">port        List port mappings or a specific mapping for the container # 查看映射端口对应容器内部源端口</span><br><span class="line">ps          List containers						  # 列出容器列表</span><br><span class="line">pull        Pull an image or a repository from a registry # 从docker镜像源服务器拉取指定镜像或库镜像</span><br><span class="line">push        Push an image or a repository to a registry   # 推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">rename      Rename a container					  # 给docker容器重新命名</span><br><span class="line">restart     Restart one or more containers		  # 重启运行的容器</span><br><span class="line">rm          Remove one or more containers			  # 移除一个或者多个容器</span><br><span class="line">rmi         Remove one or more images				  # 移除一个或者多个镜像[无容器使用该镜像时才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line">run         Run a command in a new container		  # 创建一个新的容器并运行一个命令</span><br><span class="line">save        Save one or more images to a tar archive (streamed to STDOUT by default) # 保存一个镜像为一个tar包[对应load]</span><br><span class="line">search      Search the Docker Hub for images		  # 在docker hub中搜索镜像</span><br><span class="line">start       Start one or more stopped containers	  # 启动容器</span><br><span class="line">stats       Display a live stream of container(s) resource usage statistics # 实时显示容器资源使用统计</span><br><span class="line">stop        Stop one or more running containers	  # 停止容器</span><br><span class="line">tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE # 给源中镜像打标签</span><br><span class="line">top         Display the running processes of a container   	  # 查看容器中运行的进程信息</span><br><span class="line">unpause     Unpause all processes within one or more containers # 取消暂停容器</span><br><span class="line">update      Update configuration of one or more containers	  # 更新一个或多个容器配置</span><br><span class="line">version     Show the Docker version information	  # 查看docker版本号 </span><br><span class="line">wait        Block until one or more containers stop, then print their exit codes # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>

<h2 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h2><blockquote>
<p>作业1：Docker 安装Nginx</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.搜索镜像 search 建议去docker搜索，可以看到帮助文档</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.下载镜像 pull</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.运行测试</span></span><br><span class="line">[root@localhost /]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              2622e6cca7eb        23 hours ago        132MB</span><br><span class="line">centos              latest              470671670cac        4 months ago        237MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 给容器命名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口   【端口映射操作】</span></span><br><span class="line">[root@localhost /]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">d60570d1e45024e3687e3bf3105a6959af8ee68d34f0c62a7deee1c16ec6579f</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">d60570d1e450        nginx               "/docker-entrypoint.…"   2 minutes ago       Up 2 minutes        0.0.0.0:3344-&gt;80/tcp   nginx01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地测试访问nginx</span></span><br><span class="line">[root@localhost /]# curl localhost:3344</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">[root@localhost /]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@d60570d1e450:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@d60570d1e450:/# cd /etc/nginx/</span><br><span class="line">root@d60570d1e450:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf</span><br></pre></td></tr></table></figure>

<p><strong>端口暴露的概念</strong></p>
<p><img src="C:%5CUsers%5CZTX%5CDesktop%5Cmarkdownx%E5%AD%A6%E4%B9%A0%5CDocker%E6%A6%82%E8%BF%B0(1).assets%5Cimage-20200611085948617.png" alt="image-20200611085948617"></p>
<p><strong>思考问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p>
<blockquote>
<p>作业2：Docker来装一个tomcat</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方文档</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们之前的启动都是后台，停止了容器之后，容器还是可以查到 docker run -it --rm,一般用来测试，用完就删除</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动运行</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试访问没有问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">[root@localhost /]# docker exec -it tomcat01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现问题：1、linux命令少了 2、webapps内没有内容（这是阿里云镜像的原因：默认是最小镜像，所有不必要的都删除）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保证最小可运行环境</span></span><br><span class="line"><span class="meta">#</span><span class="bash">解决方法：将webapps.dist目录下内容拷至webapps下</span></span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat# cd webapps</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat/webapps# ls</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat/webapps# cd ..</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt  CONTRIBUTING.md  LICENSE	NOTICE	README.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat# cd webapps.dist/</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat/webapps.dist# ls</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat/webapps.dist# cd ..</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat# cp -r webapps.dist/* webapps </span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat# cd webapps</span><br><span class="line">root@c435d5b974a7:/usr/local/tomcat/webapps# ls</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br></pre></td></tr></table></figure>

<p>拷贝完成就可以访问了：</p>
<p><img src="C:%5CUsers%5CZTX%5CDesktop%5Cmarkdownx%E5%AD%A6%E4%B9%A0%5CDocker%E6%A6%82%E8%BF%B0(1).assets%5Cimage-20200611090019494.png" alt="image-20200611090019494"></p>
<p><strong>思考问题：</strong>我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供映射路径，webapps,我们在外部放置项目，就自动同步到内部就好了！</p>
<blockquote>
<p>作业3：部署es+kibana</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> es 暴露的端口很多！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> es 十分耗内存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --net somenetwork？网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 elasticsearch</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动了 Linux就可卡住了   docker stats 查看cpu的状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> es 是十分耗内存的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试一下es是否成功了</span></span><br><span class="line">[root@localhost /]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  "name" : "83b0d5dca26e",</span><br><span class="line">  "cluster_name" : "docker-cluster",</span><br><span class="line">  "cluster_uuid" : "MjhNfYTvRVui1UCrAwMdqw",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "7.6.2",</span><br><span class="line">    "build_flavor" : "default",</span><br><span class="line">    "build_type" : "docker",</span><br><span class="line">    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    "build_date" : "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "8.4.0",</span><br><span class="line">    "minimum_wire_compatibility_version" : "6.8.0",</span><br><span class="line">    "minimum_index_compatibility_version" : "6.0.0-beta1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker容器占用资源情况</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200611124706727.png" alt="image-20200611124706727"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 赶紧关闭容器，增加内存限制，修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2</span><br><span class="line"> </span><br><span class="line"><span class="meta"> #</span><span class="bash"> 查看docker容器占用资源情况</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200611124755826.png" alt="image-20200611124755826"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  "name" : "5a262b522bbf",</span><br><span class="line">  "cluster_name" : "docker-cluster",</span><br><span class="line">  "cluster_uuid" : "rGMaCpVXScGaZcv_UtK3gQ",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "7.6.2",</span><br><span class="line">    "build_flavor" : "default",</span><br><span class="line">    "build_type" : "docker",</span><br><span class="line">    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",</span><br><span class="line">    "build_date" : "2020-03-26T06:34:37.794943Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "8.4.0",</span><br><span class="line">    "minimum_wire_compatibility_version" : "6.8.0",</span><br><span class="line">    "minimum_index_compatibility_version" : "6.0.0-beta1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>作业4：使用 kibana 连接 es ? 思考网络如何才能连接过去！</p>
</blockquote>
<p><img src="/static/img/docker1/image-20200611125352717.png" alt="image-20200611125352717"></p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul>
<li>portainer（线用这个）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<ul>
<li>Rancher （CI/CD再用）</li>
</ul>
<h2 id="什么是portainer"><a href="#什么是portainer" class="headerlink" title="什么是portainer ?"></a>什么是portainer ?</h2><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>外部访问测试：<a href="http://ip:8088/" target="_blank" rel="noopener">http://ip:8088/</a></p>
<p>通过它来访问了;</p>
<p><img src="/static/img/docker1/image-20200611141621853.png" alt="image-20200611141621853"></p>
<p>选择本地的：</p>
<p><img src="/static/img/docker1/image-20200611142004773.png" alt="image-20200611142004773"></p>
<p>进入之后的面板：</p>
<p><img src="/static/img/docker1/image-20200611144838665.png" alt="image-20200611144838665"></p>
<p><img src="/static/img/docker1/image-20200611144900114.png" alt="image-20200611144900114"></p>
<p>可视化面板我们平时不会使用，大家自己测试玩玩即可！</p>
<h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p>
<p>所有应用，直接打包docker镜像，就可以直接跑起来！</p>
<p><strong>如何得到镜像</strong></p>
<ul>
<li>从远程仓库下载</li>
<li>别人拷贝给你</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote>
<p>UnionFs （联合文件系统）</p>
</blockquote>
<p>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加载 kernel, Linux刚启动时会加载bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包括bootloader和 Kernel。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。<br><img src="/static/img/docker1/image-20200611162007055.png" alt="image-20200611162007055"></p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p>
<p><img src="/static/img/docker1/image-20200611162057734.png" alt="image-20200611162057734"></p>
<p>对于个精简的OS, rootfs可以很小，只需要包合最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</p>
<p>虚拟机是分钟级别，容器是秒级！</p>
<h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote>
<p>分层的镜像</p>
</blockquote>
<p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载！<img src="/static/img/docker1/image-20200611163839741.png" alt="image-20200611163839741"></p>
<p><strong>思考：为什么Docker镜像要采用这种分层的结构呢？</strong></p>
<p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p>
<p>查看镜像分层的方式可以通过docker image inspect 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  / docker image inspect redis          </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c",</span><br><span class="line">        "RepoTags": [</span><br><span class="line">            "redis:latest"</span><br><span class="line">        ],</span><br><span class="line">        "RepoDigests": [</span><br><span class="line">            "redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32"</span><br><span class="line">        ],</span><br><span class="line">        "Parent": "",</span><br><span class="line">        "Comment": "",</span><br><span class="line">        "Created": "2020-05-02T01:40:19.112130797Z",</span><br><span class="line">        "Container": "d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc",</span><br><span class="line">        "ContainerConfig": &#123;</span><br><span class="line">            "Hostname": "d30c0bcea885",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "ExposedPorts": &#123;</span><br><span class="line">                "6379/tcp": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "Tty": false,</span><br><span class="line">            "OpenStdin": false,</span><br><span class="line">            "StdinOnce": false,</span><br><span class="line">            "Env": [</span><br><span class="line">                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",</span><br><span class="line">                "GOSU_VERSION=1.12",</span><br><span class="line">                "REDIS_VERSION=6.0.1",</span><br><span class="line">                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz",</span><br><span class="line">                "REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"</span><br><span class="line">            ],</span><br><span class="line">            "Cmd": [</span><br><span class="line">                "/bin/sh",</span><br><span class="line">                "-c",</span><br><span class="line">                "#(nop) ",</span><br><span class="line">                "CMD [\"redis-server\"]"</span><br><span class="line">            ],</span><br><span class="line">            "ArgsEscaped": true,</span><br><span class="line">            "Image": "sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0",</span><br><span class="line">            "Volumes": &#123;</span><br><span class="line">                "/data": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "WorkingDir": "/data",</span><br><span class="line">            "Entrypoint": [</span><br><span class="line">                "docker-entrypoint.sh"</span><br><span class="line">            ],</span><br><span class="line">            "OnBuild": null,</span><br><span class="line">            "Labels": &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "DockerVersion": "18.09.7",</span><br><span class="line">        "Author": "",</span><br><span class="line">        "Config": &#123;</span><br><span class="line">            "Hostname": "",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "ExposedPorts": &#123;</span><br><span class="line">                "6379/tcp": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "Tty": false,</span><br><span class="line">            "OpenStdin": false,</span><br><span class="line">            "StdinOnce": false,</span><br><span class="line">            "Env": [</span><br><span class="line">                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",</span><br><span class="line">                "GOSU_VERSION=1.12",</span><br><span class="line">                "REDIS_VERSION=6.0.1",</span><br><span class="line">                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz",</span><br><span class="line">                "REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"</span><br><span class="line">            ],</span><br><span class="line">            "Cmd": [</span><br><span class="line">                "redis-server"</span><br><span class="line">            ],</span><br><span class="line">            "ArgsEscaped": true,</span><br><span class="line">            "Image": "sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0",</span><br><span class="line">            "Volumes": &#123;</span><br><span class="line">                "/data": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "WorkingDir": "/data",</span><br><span class="line">            "Entrypoint": [</span><br><span class="line">                "docker-entrypoint.sh"</span><br><span class="line">            ],</span><br><span class="line">            "OnBuild": null,</span><br><span class="line">            "Labels": null</span><br><span class="line">        &#125;,</span><br><span class="line">        "Architecture": "amd64",</span><br><span class="line">        "Os": "linux",</span><br><span class="line">        "Size": 104101893,</span><br><span class="line">        "VirtualSize": 104101893,</span><br><span class="line">        "GraphDriver": &#123;</span><br><span class="line">            "Data": &#123;</span><br><span class="line">                "LowerDir": "/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff",</span><br><span class="line">                "MergedDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged",</span><br><span class="line">                "UpperDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff",</span><br><span class="line">                "WorkDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work"</span><br><span class="line">            &#125;,</span><br><span class="line">            "Name": "overlay2"</span><br><span class="line">        &#125;,</span><br><span class="line">        "RootFS": &#123;</span><br><span class="line">            "Type": "layers",</span><br><span class="line">            "Layers": [</span><br><span class="line">                "sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13",</span><br><span class="line">                "sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990",</span><br><span class="line">                "sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8",</span><br><span class="line">                "sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8",</span><br><span class="line">                "sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123",</span><br><span class="line">                "sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894"</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        "Metadata": &#123;</span><br><span class="line">            "LastTagTime": "0001-01-01T00:00:00Z"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>理解：</strong></p>
<p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="/static/img/docker1/image-20200611163818495.png" alt="image-20200611163818495"></p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而整体的大镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="/static/img/docker1/image-20200611164322267.png" alt="image-20200611164322267"></p>
<p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p>
<p><img src="/static/img/docker1/image-20200611164447964.png" alt="image-20200611164447964"></p>
<p>这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的文件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p>
<p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。</p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！<img src="/static/img/docker1/image-20200611165355825.png" alt="image-20200611165355825"></p>
<p>如何提交一个自己的镜像？</p>
<h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理类似</span></span><br><span class="line">docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[版本TAG]</span><br></pre></td></tr></table></figure>

<p>实战测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1、启动一个默认的tomcat</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2、发现这个默认的tomcat是没有webapps应用的，镜像的原因。官方的镜像默认webapps下面是没有文件的！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3、我自己将webapp.dist下文件拷贝至webapps下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4、将我们操作过的容器通过commit提交为一个镜像！我们以后就可以使用我们修改过的镜像了，这就是我们自己的一个修改的镜像</span></span><br></pre></td></tr></table></figure>

<p><img src="/static/img/docker1/image-20200611172701729.png" alt="image-20200611172701729"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。</span><br></pre></td></tr></table></figure>

<p>到了这里就算是入门Docker了！</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-SQLAlchemy基础操作</title>
    <url>//post/21407.html</url>
    <content><![CDATA[<h2 id="5-8-1-创建表"><a href="#5-8-1-创建表" class="headerlink" title="5.8.1　创建表"></a>5.8.1　创建表</h2><p>首先，我们要让 Flask-SQLAlchemy 根据模型类创建数据库。方法是使用 db.create_all()<br>函数：<br>(venv) $ python hello.py shell</p><a id="more"></a>
<blockquote>
<blockquote>
<blockquote>
<p>from hello import db<br>db.create_all()<br>如果你查看程序目录，会发现新建了一个名为 data.sqlite 的文件。这个 SQLite 数据库文件<br>的名字就是在配置中指定的。如果数据库表已经存在于数据库中，那么 db.create_all()<br>不会重新创建或者更新这个表。如果修改模型后要把改动应用到现有的数据库中，这一特<br>性会带来不便。更新现有数据库表的粗暴方式是先删除旧表再重新创建：<br>db.drop_all()<br>db.create_all()<br>（续）<br>数据库 ｜ 51<br>遗憾的是，这个方法有个我们不想看到的副作用，它把数据库中原有的数据都销毁了。本<br>章末尾将会介绍一种更好的方式用于更新数据库。</p>
</blockquote>
</blockquote>
</blockquote>
<p>下面这段代码创建了一些角色和用户：</p>
<blockquote>
<blockquote>
<blockquote>
<p>from hello import Role, User<br>admin_role = Role(name=’Admin’)<br>mod_role = Role(name=’Moderator’)<br>user_role = Role(name=’User’)<br>user_john = User(username=’john’, role=admin_role)<br>user_susan = User(username=’susan’, role=user_role)<br>user_david = User(username=’david’, role=user_role)<br>模型的构造函数接受的参数是使用关键字参数指定的模型属性初始值。注意， role 属性也<br>可使用，虽然它不是真正的数据库列，但却是一对多关系的高级表示。这些新建对象的 id<br>属性并没有明确设定，因为主键是由 Flask-SQLAlchemy 管理的。现在这些对象只存在于<br>Python 中，还未写入数据库。因此 id 尚未赋值：<br>print(admin_role.id)<br>None<br>print(mod_role.id)<br>None<br>print(user_role.id)<br>None<br>通过数据库会话管理对数据库所做的改动，在 Flask-SQLAlchemy 中，会话由 db.session<br>表示。准备把对象写入数据库之前，先要将其添加到会话中：<br>db.session.add(admin_role)<br>db.session.add(mod_role)<br>db.session.add(user_role)<br>db.session.add(user_john)<br>db.session.add(user_susan)<br>db.session.add(user_david)<br>或者简写成：<br>db.session.add_all([admin_role, mod_role, user_role,<br>… user_john, user_susan, user_david])<br>为了把对象写入数据库，我们要调用 commit() 方法提交会话：<br>db.session.commit()<br>再次查看 id 属性，现在它们已经赋值了：<br>52 ｜ 第 5 章<br>print(admin_role.id)<br>1<br>print(mod_role.id)<br>2<br>print(user_role.id)<br>3<br>数据库会话 db.session 和第 4 章介绍的 Flask session 对象没有关系。数据库<br>会话也称为事务。<br>数据库会话能保证数据库的一致性。提交操作使用原子方式把会话中的对象全部写入数据<br>库。如果在写入会话的过程中发生了错误，整个会话都会失效。如果你始终把相关改动放<br>在会话中提交，就能避免因部分更新导致的数据库不一致性。<br>数据库会话也可 回滚 。调用 db.session.rollback() 后，添加到数据库会话<br>中的所有对象都会还原到它们在数据库时的状态。</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.4.1　准备用于登录的用户模型</span><br><span class="line">要想使用 Flask-Login 扩展，程序的 User 模型必须实现几个方法。需要实现的方法如表 8-1</span><br><span class="line">所示。</span><br><span class="line">82 ｜ 第 8 章</span><br><span class="line">表8-1　Flask-Login要求实现的用户方法</span><br><span class="line">方　　法 说　　明</span><br><span class="line">is_authenticated() 如果用户已经登录，必须返回 True ，否则返回 False</span><br><span class="line">is_active() 如果允许用户登录，必须返回 True ，否则返回 False 。如果要禁用账户，可以返回 False</span><br><span class="line">is_anonymous() 对普通用户必须返回 False</span><br><span class="line">get_id() 必须返回用户的唯一标识符，使用 Unicode 编码字符串</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Flask-SQLAlchemy</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask常用扩展</title>
    <url>//post/26946.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask-SQLalchemy：操作数据库；</span><br><span class="line">Flask-script：插入脚本；</span><br><span class="line">Flask-migrate：管理迁移数据库；</span><br><span class="line">Flask-Session：Session存储方式指定；</span><br><span class="line">Flask-WTF：表单；</span><br><span class="line">Flask-Mail：邮件；</span><br><span class="line">Flask-Bable：提供国际化和本地化支持，翻译；</span><br><span class="line">Flask-Login：认证用户状态；</span><br><span class="line">Flask-OpenID：认证；</span><br><span class="line">Flask-RESTful：开发REST API的工具；</span><br><span class="line">Flask-Bootstrap：集成前端Twitter Bootstrap框架；</span><br><span class="line">Flask-Moment：本地化日期和时间；</span><br><span class="line">Flask-Admin：简单而可扩展的管理接口的框架</span><br><span class="line">扩展列表：http:&#x2F;&#x2F;flask.pocoo.org&#x2F;extensions&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask开发环境搭建</title>
    <url>//post/26850.html</url>
    <content><![CDATA[<blockquote>
<p>PyPI（<a href="https://pypi.org" target="_blank" rel="noopener">https://pypi.org</a> ）是一个Python包的在线仓库，截至2018年5月，<br>共有13万多个包存储在这里。后面我们会学习如何编写自己的Flask扩展，并把它<br>上传到PyPI上。到时你就可以使用上面这条命令安装自己编写的包。<br>现在使用pip安装Pipenv：<br>$ pip install pipenv<br>在Linux或macOS系统中使用sudo以全局安装：<br><code>$ sudo pip install pipenv</code><br>附注<br>如果你不想全局安装，可以添加–user选项执行用户安装（即pip install–<br>user pipenv），并手动将用户基础二进制目录添加到PATH环境变量中，具体可参<br>考<a href="https://docs.pipenv.org/install/#installing-pipenv" target="_blank" rel="noopener">https://docs.pipenv.org/install/#installing-pipenv</a> 。<br>提示<br>PyPI中的包名称不区分大小写。出于方便的考虑，后面的安装命令都将使用小<br>写名称。<br>可以使用下面的命令检查Pipenv是否已经安装：<br><code>$ pipenv --version</code><br><code>pipenv, version 11.10.4</code><br>2.创建虚拟环境<br>在Python中，虚拟环境（virtual enviroment）就是隔离的Python解释器环<br>境。通过创建虚拟环境，你可以拥有一个独立的Python解释器环境。这样做的好处<br>是可以为每一个项目创建独立的Python解释器环境，因为不同的项目常常会依赖不<br>同版本的库或Python版本。使用虚拟环境可以保持全局Python解释器环境的干净，<br>避免包和版本的混乱，并且可以方便地区分和记录每个项目的依赖，以便在新环境<br>下复现依赖环境。<br>虚拟环境通常使用Virtualenv来创建，但是为了更方便地管理虚拟环境和依赖<br>包，我们将会使用集成了Virtualenv的Pipenv。首先确保我们当前工作目录在示例<br>程序项目的根目录，即helloflask文件夹中，然后使用pipenv install命令为当<br>前的项目创建虚拟环境：<br><code>$ pipenv install</code><br><code>Creating a virtualenv for this project…</code><br><code>...</code><br><code>Virtualenv location: /path/to/virtualenv/helloflask-5Pa0ZfZw</code><br><code>...</code><br>这会为当前项目创建一个文件夹，其中包含隔离的Python解释器环境，并且安<br>装pip、wheel、setuptools等基本的包。因为示例程序仓库里包含Pipfile文件，<br>所以这个文件中列出的依赖包也会一并被安装，下面会具体介绍。<br>附注<br>默认情况下，Pipenv会统一管理所有虚拟环境。在Windows系统中，虚拟环境<br>文件夹会在C：\Users\Administrator.virtualenvs\目录下创建，而Linux或<br>macOS会在~/.local/share/virtualenvs/目录下创建。如果你想在项目目录内创<br>建虚拟环境文件夹，可以设置环境变量PIPENV_VENV_IN_PROJECT，这时名<br>为.venv的虚拟环境文件夹将在项目根目录被创建。<br>虚拟环境文件夹的目录名称的形式为“当前项目目录名+一串随机字符”，比如<br>helloflask-5Pa0ZfZw。<br>提示<br>你可以通过–three和–two选项来声明虚拟环境中使用的Python版本（分别<br>对应Python3和Python2），或是使用–python选项指定具体的版本号。同时要确<br>保对应版本的Python已经安装在电脑中。<br>在单独使用Virtualenv时，我们通常会显式地激活虚拟环境。在Pipenv中，可<br>以使用pipenv shell命令显式地激活虚拟环境：<br><code>$ pipenv shell</code><br><code>Loading .env environment variables…</code><br><code>Launching subshell in virtual environment. Type &#39;exit&#39; to return.</code></p>
</blockquote><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境变量加载</span><br><span class="line">pipenv install python-dotenv</span><br><span class="line">.flaskenv</span><br><span class="line">.evn</span><br><span class="line">SOME_VAR&#x3D;1</span><br><span class="line"># 这是注释</span><br><span class="line">FOO&#x3D;&quot;BAR&quot;</span><br><span class="line">FLASK_APP&#x3D;app.py</span><br><span class="line">FLASK_ENV&#x3D;development</span><br><span class="line">FLASK_RUN_PORT&#x3D;80</span><br><span class="line">FLASK_RUN_HOST&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自动重启服务器</span><br><span class="line">默认会使用Werkzeug内置的stat重载器，它的缺点是耗电较严重，而且准确性</span><br><span class="line">一般。为了获得更优秀的体验，我们可以安装另一个用于监测文件变动的Python库</span><br><span class="line">Watchdog，安装后Werkzeug会自动使用它来监测文件变动：</span><br><span class="line">$ pipenv install watchdog --dev</span><br><span class="line">因为这个包只在开发时才会用到，所以我们在安装命令后添加了一个--dev选</span><br><span class="line">项，这用来把这个包声明为开发依赖。在Pipfile文件中，这个包会被添加到dev-</span><br><span class="line">packages部分。</span><br><span class="line">不过，如果项目中使用了单独的CSS或JavaScript文件时，那么浏览器可能会</span><br><span class="line">缓存这些文件，从而导致对文件做出的修改不能立刻生效。在浏览器中，我们可以</span><br><span class="line">按下Crtl+F5或Shift+F5执行硬重载（hard reload），即忽略缓存并重载（刷</span><br><span class="line">新）页面。</span><br><span class="line">提示</span><br><span class="line">当在一个新电脑创建运行环境时，使用pipenv install命令时需要添加额外</span><br><span class="line">的--dev选项才会安装dev-packages部分定义的开发依赖包</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Flask</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask环境变量加载踩坑</title>
    <url>//post/52596.html</url>
    <content><![CDATA[<p><strong>其实本质都是python-dotenv加载环境变量出现的问题。</strong></p><h1 id="坑一：python-dotenv加载的Value都是字符串类型"><a href="#坑一：python-dotenv加载的Value都是字符串类型" class="headerlink" title="坑一：python-dotenv加载的Value都是字符串类型"></a>坑一：python-dotenv加载的Value都是字符串类型</h1><a id="more"></a>
<p>第一个坑是<strong>python-dotenv加载的Value都是字符串类型</strong>（<code>python-dotenv</code>版本0.10.1），因此导致整型、浮点型和布尔类型需要转换一下。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>目前解决办法只能是这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `.env`</span></span><br><span class="line">MAIL_PORT = 465</span><br><span class="line">MAIL_USE_SSL = <span class="literal">false</span></span><br><span class="line">MAIL_USE_TLS = <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseConfig</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    MAIL_PORT = int(os.getenv(<span class="string">'MAIL_PORT'</span>, default=<span class="number">587</span>))</span><br><span class="line">    MAIL_USE_SSL = <span class="literal">True</span> <span class="keyword">if</span> <span class="string">'true'</span> == os.getenv(<span class="string">'MAIL_USE_SSL'</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    MAIL_USE_TLS = <span class="literal">True</span> <span class="keyword">if</span> <span class="string">'true'</span> == os.getenv(<span class="string">'MAIL_USE_TLS'</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>相关帖子：<a href="https://discuss.helloflask.com/t/topic/127/3?u=angelliang" target="_blank" rel="noopener">https://discuss.helloflask.com/t/topic/127/3?u=angelliang</a></p>
<h1 id="坑二：pipenv影响了flask加载-env环境变量"><a href="#坑二：pipenv影响了flask加载-env环境变量" class="headerlink" title="坑二：pipenv影响了flask加载.env环境变量"></a>坑二：pipenv影响了flask加载<code>.env</code>环境变量</h1><p>第二个坑和<code>pipenv</code>有关，众所周知Flask项目可以通过<code>.env</code>加载环境变量，但是，<code>pipenv</code>也可以通过<code>.env</code>加载环境变量！问题就出现了，进入<code>pipenv shell</code>虚拟环境后，修改.env环境变量后再启动Flask app：<code>flask run</code>，Flask还是用了原来的环境变量！！！</p>
<p>究其原因，是<code>pipenv shell</code>加载了环境变量并进行了缓存，然后flask加载环境变量时没有进行覆盖</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&gt; pipenv shell</span><br><span class="line">Loading .env environment variables…</span><br><span class="line">Launching subshell <span class="keyword">in</span> <span class="keyword">virtual</span> environment…</span><br><span class="line">...</span><br><span class="line">&gt; flask run  <span class="meta"># 正常预期</span></span><br><span class="line"><span class="meta"># 停止flask，修改 .env 环境变量，保存</span></span><br><span class="line">&gt; flask run  <span class="meta"># 没达到修改变量后的预期效果</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>尤其是部署Flask到服务器后，以下步骤肯定有问题的！！！</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ pipenv shell</span><br><span class="line">$ vim .env</span><br><span class="line">...</span><br><span class="line">$ flask run</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：重进pipenv-shell"><a href="#方案一：重进pipenv-shell" class="headerlink" title="方案一：重进pipenv shell"></a>方案一：重进<code>pipenv shell</code></h3><p>一种解决方案就是退出<code>pipenv shell</code>环境再进入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; pipenv shell</span><br><span class="line">&gt; <span class="comment"># 编辑 .env</span></span><br><span class="line">...</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br><span class="line">&gt; pipenv shell</span><br></pre></td></tr></table></figure>

<h3 id="方案二：新建并使用app-py启动"><a href="#方案二：新建并使用app-py启动" class="headerlink" title="方案二：新建并使用app.py启动"></a>方案二：新建并使用<code>app.py</code>启动</h3><p>另一个解决方案是在主目录下新建一个<code>app.py</code>，拷贝下面代码，以后使用<code>python app.py</code>启动。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python app.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line">dotenv_path = os.path.join(os.path.abspath(os.path.dirname(__file__)), <span class="string">'.env'</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(dotenv_path):</span><br><span class="line">    load_dotenv(dotenv_path, override=<span class="literal">True</span>)  <span class="comment">#  override=True: 覆写已存在的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> apps.web <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app = create_app()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>这种代码有时也会给一些wsgi（比如gunicorn）提供。</p>
<h3 id="方案三：设置PIPENV-DONT-LOAD-ENV-1"><a href="#方案三：设置PIPENV-DONT-LOAD-ENV-1" class="headerlink" title="方案三：设置PIPENV_DONT_LOAD_ENV=1"></a>方案三：设置<code>PIPENV_DONT_LOAD_ENV=1</code></h3><p>还有一个方案是设置<code>PIPENV_DONT_LOAD_ENV=1</code>，不让pipenv加载<code>.env</code>。</p>
<p>PowerShell示例（注意没有了<code>Loading .env environment variables…</code>信息）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; <span class="variable">$env:PIPENV_DONT_LOAD_ENV</span>=<span class="number">1</span></span><br><span class="line">&gt; pipenv shell</span><br><span class="line">Launching subshell <span class="keyword">in</span> virtual environment…</span><br><span class="line">Windows PowerShell</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="方案四：使用-flaskenv"><a href="#方案四：使用-flaskenv" class="headerlink" title="方案四：使用.flaskenv"></a>方案四：使用<code>.flaskenv</code></h3><p><code>pipenv shell</code>不会从<code>.flaskenv</code>加载变量，所以如果有经常需要修改的环境变量也可以放在<code>.flaskenv</code>。但是我感觉一点也不优雅，因为我习惯把<code>.flaskenv</code>也提交到仓库，而留下<code>.env</code>在部署端客制化。</p>
<hr>
<p>相同帖子：<a href="https://discuss.helloflask.com/t/topic/128" target="_blank" rel="noopener">https://discuss.helloflask.com/t/topic/128</a></p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask微信公众号开发</title>
    <url>//post/29173.html</url>
    <content><![CDATA[<h3 id="微信服务器认证"><a href="#微信服务器认证" class="headerlink" title="微信服务器认证"></a>微信服务器认证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;wx_flask&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;])</span><br><span class="line">def wechat():</span><br><span class="line">    # 第一次接入服务器的验证</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;GET&#39;:</span><br><span class="line">        #这里改写你在微信公众平台里输入的token</span><br><span class="line">        token &#x3D; &#39;ctgu&#39;</span><br><span class="line">        #获取输入参数</span><br><span class="line">        data &#x3D; request.args</span><br><span class="line">        signature &#x3D; data.get(&#39;signature&#39;,&#39;&#39;)</span><br><span class="line">        timestamp &#x3D; data.get(&#39;timestamp&#39;,&#39;&#39;)</span><br><span class="line">        nonce &#x3D; data.get(&#39;nonce&#39;,&#39;&#39;)</span><br><span class="line">        echostr &#x3D; data.get(&#39;echostr&#39;,&#39;&#39;)</span><br><span class="line">        #字典排序</span><br><span class="line">        list &#x3D; [token, timestamp, nonce]</span><br><span class="line">        list.sort()</span><br><span class="line"></span><br><span class="line">        s &#x3D; list[0] + list[1] + list[2]</span><br><span class="line">        #sha1加密算法        </span><br><span class="line">        hascode &#x3D; hashlib.sha1(s.encode(&#39;utf-8&#39;)).hexdigest()</span><br><span class="line">        #如果是来自微信的请求，则回复echostr</span><br><span class="line">        if hascode &#x3D;&#x3D; signature:</span><br><span class="line">            return echostr</span><br><span class="line">        else:</span><br><span class="line">            return &quot;非微信官方请求&quot;</span><br><span class="line">    #回复用户消息</span><br><span class="line">    elif request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        # 表示微信服务器转发消息过来</span><br><span class="line">        xml_str &#x3D; request.data</span><br><span class="line">        if not xml_str:</span><br><span class="line">            return &quot;不支持此此类型消息处理！&quot;</span><br><span class="line">        # 对xml字符串进行解析</span><br><span class="line">        xml_dict &#x3D; xmltodict.parse(xml_str)</span><br><span class="line">        xml_dict &#x3D; xml_dict.get(&quot;xml&quot;)</span><br><span class="line">        return resp_by_msg_type(xml_dict)</span><br></pre></td></tr></table></figure><a id="more"></a>

<h3 id="自动回复用户消息"><a href="#自动回复用户消息" class="headerlink" title="自动回复用户消息"></a>自动回复用户消息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def resp_by_msg_type(xml_dict):</span><br><span class="line"></span><br><span class="line">    # 提取消息类型</span><br><span class="line"></span><br><span class="line">​    msg_type &#x3D; xml_dict.get(&quot;MsgType&quot;)</span><br><span class="line">​    if msg_type &#x3D;&#x3D; &quot;text&quot;:</span><br><span class="line"></span><br><span class="line">        # 表示发送的是文本消息</span><br><span class="line"></span><br><span class="line">        # 构造返回值，经由微信服务器回复给用户的消息内容</span><br><span class="line"></span><br><span class="line">​        resp_dict &#x3D; &#123;</span><br><span class="line">​            &quot;xml&quot;: &#123;</span><br><span class="line">​                &quot;ToUserName&quot;: xml_dict.get(&quot;FromUserName&quot;),</span><br><span class="line">​                &quot;FromUserName&quot;: xml_dict.get(&quot;ToUserName&quot;),</span><br><span class="line">​                &quot;CreateTime&quot;: int(time.time()),</span><br><span class="line">​                &quot;MsgType&quot;: &quot;text&quot;,</span><br><span class="line">​                &quot;Content&quot;: &quot;you say:&quot; + xml_dict.get(&quot;Content&quot;)</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">        # 将字典转换为xml字符串</span><br><span class="line"></span><br><span class="line">​        resp_xml_str &#x3D; xmltodict.unparse(resp_dict)</span><br><span class="line"></span><br><span class="line">        # 返回消息数据给微信服务器</span><br><span class="line"></span><br><span class="line">​        return resp_xml_str</span><br><span class="line"></span><br><span class="line">    # 收到图片消息</span><br><span class="line"></span><br><span class="line">​    if msg_type &#x3D;&#x3D; &quot;image&quot;:</span><br><span class="line"></span><br><span class="line">        # 表示发送的是文本消息</span><br><span class="line"></span><br><span class="line">        # 构造返回值，经由微信服务器回复给用户的消息内容</span><br><span class="line"></span><br><span class="line">​        resp_dict &#x3D; &#123;</span><br><span class="line">​            &quot;xml&quot;: &#123;</span><br><span class="line">​                &quot;ToUserName&quot;: xml_dict.get(&quot;FromUserName&quot;),</span><br><span class="line">​                &quot;FromUserName&quot;: xml_dict.get(&quot;ToUserName&quot;),</span><br><span class="line">​                &quot;CreateTime&quot;: int(time.time()),</span><br><span class="line">​                &quot;MsgType&quot;: &quot;text&quot;,</span><br><span class="line">​                &quot;PicUrl&quot;: xml_dict.get(&quot;PicUrl&quot;),</span><br><span class="line">​                &quot;MediaId&quot;: xml_dict.get(&quot;MediaId&quot;),</span><br><span class="line"></span><br><span class="line">                # &quot;MsgId&quot; : xml_dict.get(&quot;MsgId&quot;)</span><br><span class="line"></span><br><span class="line">​                &quot;MsgId&quot;: &quot;1234567890123456&quot;</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">        # 将字典转换为xml字符串</span><br><span class="line"></span><br><span class="line">​        resp_xml_str &#x3D; xmltodict.unparse(resp_dict)</span><br><span class="line"></span><br><span class="line">        # 返回消息数据给微信服务器</span><br><span class="line"></span><br><span class="line">​        return resp_xml_str</span><br><span class="line">​    else:</span><br><span class="line">​        resp_dict &#x3D; &#123;</span><br><span class="line">​            &quot;xml&quot;: &#123;</span><br><span class="line">​                &quot;ToUserName&quot;: xml_dict.get(&quot;FromUserName&quot;),</span><br><span class="line">​                &quot;FromUserName&quot;: xml_dict.get(&quot;ToUserName&quot;),</span><br><span class="line">​                &quot;CreateTime&quot;: int(time.time()),</span><br><span class="line">​                &quot;MsgType&quot;: &quot;text&quot;,</span><br><span class="line">​                &quot;Content&quot;: &quot;欢迎关注iBoy博客！&quot;</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​        resp_xml_str &#x3D; xmltodict.unparse(resp_dict)</span><br><span class="line"></span><br><span class="line">        # 返回消息数据给微信服务器</span><br><span class="line"></span><br><span class="line">​        return resp_xml_str</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Flask</category>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask开发笔记</title>
    <url>//post/575.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask-sqlacodegen</span><br><span class="line">ORM操作有两种方式。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1.模型迁移到数据库中生成表，codefirst：使用flask-migrate:</span><br><span class="line"></span><br><span class="line">需要flask-script：</span><br><span class="line"></span><br><span class="line">from flask_script import Manager</span><br><span class="line">from flask_migrate import Migrate ,MigrateCommand</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">manager &#x3D; Manager(app)  # 注册App到脚本</span><br><span class="line">Migrate(app,db)  # 注册App和ORM对象</span><br><span class="line">manager.add_command(&#39;db&#39;,MigrateCommand)  # db为命令 即执行python manager.py db 命令</span><br><span class="line"></span><br><span class="line">python setup.py db init:初始化</span><br><span class="line"></span><br><span class="line">python setup.py db migrate:生成迁移脚本</span><br><span class="line"></span><br><span class="line">python setup.py db upgrade:映射到数据库</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2.已经建好数据库&#x3D;&#x3D;&gt;模型:使用flask-sqlacodegen:</span><br><span class="line"></span><br><span class="line">安装：pip install flask-sqlacodegen</span><br><span class="line"></span><br><span class="line">使用window环境下：</span><br><span class="line"></span><br><span class="line"># 整体映射database数据库并写入model.py文件</span><br><span class="line">flask-sqlacodegen \</span><br><span class="line">mysql:&#x2F;&#x2F;username:password@127.0.0.1&#x2F;database \</span><br><span class="line">--outfile &#39;model.py&#39; \</span><br><span class="line">--flask</span><br><span class="line"></span><br><span class="line"># 映射table数据表并写入table.py文件</span><br><span class="line">flask-sqlacodegen \</span><br><span class="line">mysql:&#x2F;&#x2F;username:password@127.0.0.1&#x2F;database \</span><br><span class="line">--table table \</span><br><span class="line">--outfile &#39;model.py&#39; \</span><br><span class="line">--flask</span><br><span class="line">flask-sqlacodegen mysql:&#x2F;&#x2F;root:@127.0.0.1&#x2F;db_name --outfile &quot;models&#x2F;model.py&quot;  --flask</span><br><span class="line"></span><br><span class="line">flask-sqlacodegen &#39;mysql:&#x2F;&#x2F;root:root@127.0.0.1&#x2F;swzl&#39; --table table  --outfile &quot;app&#x2F;models&#x2F;user_model.py&quot;  --flask</span><br><span class="line"></span><br><span class="line">flask-sqlacodegen mysql:&#x2F;&#x2F;root:root@127.0.0.1&#x2F;swzl --outfile all.py</span><br><span class="line">flask-sqlacodegen mysql:&#x2F;&#x2F;root:root@127.0.0.1&#x2F;swzl --tables t_user --outfile User.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flask-sqlacodegen &#39;mysql:&#x2F;&#x2F;root:root@127.0.0.1&#x2F;swzl&#39; --tables t_user  --outfile &quot;app&#x2F;models&#x2F;user_model.py&quot;  --flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flask-sqlacodegen mysql:&#x2F;&#x2F;root:@127.0.0.1&#x2F;db_name --tables user --outfile &quot;models&#x2F;user.py&quot;  --flask</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask部署</title>
    <url>//post/63618.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 supervisor 管理进程</span><br><span class="line">http:&#x2F;&#x2F;liyangliang.me&#x2F;posts&#x2F;2015&#x2F;06&#x2F;using-supervisor&#x2F;</span><br><span class="line">sudo pip3 install supervisor</span><br><span class="line"></span><br><span class="line">首先来看 supervisord 的配置文件。安装完 supervisor 之后，可以运行echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：</span><br><span class="line"></span><br><span class="line">echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=<span class="number">0700</span>                 ; socket 文件的 mode，默认是 <span class="number">0700</span></span><br><span class="line">;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class="line">;port=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ; 登录管理后台的用户名</span><br><span class="line">;password=<span class="number">123</span>               ; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=<span class="number">50</span>MB        ; 日志文件大小，超出会 rotate，默认 <span class="number">50</span>MB</span><br><span class="line">logfile_backups=<span class="number">10</span>           ; 日志文件保留备份数量默认 <span class="number">10</span></span><br><span class="line">loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; pid 文件</span><br><span class="line">nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class="line">minfds=<span class="number">1024</span>                  ; 可以打开的文件描述符的最小值，默认 <span class="number">1024</span></span><br><span class="line">minprocs=<span class="number">200</span>                 ; 可以打开的进程数的最小值，默认 <span class="number">200</span></span><br><span class="line"></span><br><span class="line">; the below section must remain <span class="keyword">in</span> the config file <span class="keyword">for</span> RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them <span class="keyword">in</span> separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class="line">;serverurl=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span> ; 通过 HTTP 的方式连接 supervisord</span><br><span class="line"></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们把上面这部分配置保存到 &#x2F;etc&#x2F;supervisord.conf（或其他任意有权限访问的文件），然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD&#x2F;supervisord.conf, $CWD&#x2F;etc&#x2F;supervisord.conf, &#x2F;etc&#x2F;supervisord.conf）：</span><br><span class="line"></span><br><span class="line">supervisord -c &#x2F;etc&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line">查看 supervisord 是否在运行：</span><br><span class="line">ps aux | grep supervisord</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WSGI服务器</span><br><span class="line">pip3 install gunicorn</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xmxj0707&#x2F;p&#x2F;8452881.html</span><br><span class="line">$ gunicorn -w 4 app:app --error-logfile - --worker-class eventlet</span><br><span class="line"></span><br><span class="line">配置文件编写</span><br><span class="line">gunicorn -c gunicorn.conf run:app   -k eventlet</span><br><span class="line">python3 run.py  --host&#x3D;0.0.0.0 --port&#x3D;8888 --no-reload</span><br><span class="line">sudo apt-get install gunicorn</span><br><span class="line">gunicorn -b 0.0.0.0:8889 run:app -k eventlet</span><br><span class="line"></span><br><span class="line">#配置文件内容</span><br><span class="line">import  os</span><br><span class="line">from  gevent import monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">import multiprocessing</span><br><span class="line">debug &#x3D; False</span><br><span class="line">bind &#x3D; &quot;0.0.0.0:5001&quot;</span><br><span class="line">pidfile &#x3D; &quot;gunicorn.pid&quot;</span><br><span class="line">logfile &#x3D; &quot;error.log&quot;</span><br><span class="line">workers &#x3D; multiprocessing.cpu_count()*2 + 1</span><br><span class="line">worker_class &#x3D; &quot;gevent&quot; # 异步非阻塞</span><br><span class="line">reload &#x3D; True # 自动重新加载</span><br><span class="line">#daemon &#x3D; True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主要问题：http的socket如何在https的网站使用？？</span><br><span class="line">https:&#x2F;&#x2F;segmentfault.com&#x2F;q&#x2F;1010000013762709</span><br><span class="line"># socket代理配置</span><br><span class="line">    location &#x2F;socket.io&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;192.54.2.1:3000;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    注意：</span><br><span class="line">配置前端socket连接时别带端口，但要配置到https:&#x2F;&#x2F;ineedtm.com&#x2F;而不是htt...:&#x2F;&#x2F;ineedtm.com&#x2F;socket.io&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;260f18aa5462</span><br><span class="line">配置证书</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;gunicorn  -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;config.py run:app</span><br><span class="line"></span><br><span class="line">gunicorn -c config.py run:app</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启异步队列</span><br><span class="line">celery worker -A run.celery --loglevel&#x3D;info --pool&#x3D;eventlet  -E</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery worker -A run.celery --loglevel&#x3D;info --pool&#x3D;eventlet  -E</span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;True&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动</span><br><span class="line">这两个命令是不一样的，supervisord 是启动 supervisor 守护进程（类似于 systemd 或 init.d 这种用于托管进程的服务），supervisorctl 是 supervisord 的命令行控制台。</span><br><span class="line">supervisorctl -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line">supervisord  -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line">重启服务 supervisord  -c  -n &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动supervisor</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">$ supervisor –c &#x2F;etc&#x2F;supervisor&#x2F;supervisor.conf</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">8、 启动服务并添加开机启动</span><br><span class="line">#启动服务</span><br><span class="line">$ &#x2F;usr&#x2F;local&#x2F;bin&#x2F;supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisor.conf</span><br><span class="line"> </span><br><span class="line">#添加开机启动</span><br><span class="line">$ sudo vim &#x2F;etc&#x2F;rc.local</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;supervisord  -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;supervisord.conf</span><br><span class="line"></span><br><span class="line">后台运行</span><br><span class="line">nohup &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gunicorn  -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;config.py run:app </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面这个命令会进入 supervisorctl 的 shell 界面，然后可以执行不同的命令了：</span><br><span class="line">&gt; status    # 查看程序状态</span><br><span class="line">&gt; stop swzl   # 关闭 swzl 程序</span><br><span class="line">&gt; start swzl  # 启动 swzl 程序</span><br><span class="line">&gt; restart swzl    # 重启 swzl 程序</span><br><span class="line">&gt; reread    ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序</span><br><span class="line">&gt; update    ＃ 重启配置文件修改过的程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面这些命令都有相应的输出，除了进入 supervisorctl 的 shell 界面，也可以直接在 bash 终端运行：</span><br><span class="line"></span><br><span class="line">$ supervisorctl status</span><br><span class="line">$ supervisorctl stop swzl</span><br><span class="line">$ supervisorctl start swzl</span><br><span class="line">$ supervisorctl restart swzl</span><br><span class="line">$ supervisorctl reread</span><br><span class="line">$ supervisorctl update</span><br><span class="line"></span><br><span class="line">查看进程 ps -ef | grep supervisord</span><br><span class="line">杀掉</span><br><span class="line">创建supervisor.sock</span><br><span class="line"></span><br><span class="line">sudo touch &#x2F;var&#x2F;run&#x2F;supervisor.sock</span><br><span class="line">sudo chmod 777 &#x2F;var&#x2F;run&#x2F;supervisor.sock</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nginx操作</span><br><span class="line">Centos nginx重启</span><br><span class="line"></span><br><span class="line">重启Nginx</span><br><span class="line"></span><br><span class="line">service nginx restart</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx stop</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line"></span><br><span class="line">Ubuntu Nginx</span><br><span class="line"></span><br><span class="line">$sudo service nginx start</span><br><span class="line">$sudo service nginx stop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;</span><br><span class="line">util-linux</span><br><span class="line"> python-gunicorn</span><br><span class="line"> gunicorn</span><br><span class="line"> supervisor</span><br><span class="line"> 这里只列出了部分错误信息，实际上输出的内容极多，多得让人眼都瞎。</span><br><span class="line">原因我不知道，但经过一番Google，我找到了一个解决办法：</span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;</span><br><span class="line">sudo mv python-gunicorn python-gunicorn.bak</span><br><span class="line">sudo mv gunicorn gunicorn.bak</span><br><span class="line">sudo mv util-linux util-linux.bak</span><br><span class="line">sudo mv supervisor supervisor.bak</span><br></pre></td></tr></table></figure>

<h4 id="Docker-Gunicorn部署Flask"><a href="#Docker-Gunicorn部署Flask" class="headerlink" title="Docker+Gunicorn部署Flask"></a>Docker+Gunicorn部署Flask</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;the-flask-mega-tutorial-2017-zh&#x2F;docs&#x2F;19.html</span><br><span class="line">用docker部署flask+gunicorn+nginx</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xuanmanstein&#x2F;p&#x2F;7692256.html</span><br><span class="line"></span><br><span class="line">知乎Flask部署 Flask + Docker 无脑部署新手教程 - 知乎</span><br><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;78432719</span><br><span class="line"></span><br><span class="line">docker教程</span><br><span class="line">https:&#x2F;&#x2F;yeasy.gitbooks.io&#x2F;docker_practice&#x2F;image&#x2F;dockerfile&#x2F;workdir.html</span><br><span class="line"></span><br><span class="line">删除镜像</span><br><span class="line">docker rmi imgid</span><br><span class="line">删除容器</span><br><span class="line">docker rm conid</span><br><span class="line">进入容器</span><br><span class="line">docker exec -it conid bash</span><br><span class="line"></span><br><span class="line">重启容器服务</span><br><span class="line">service docker restart</span><br><span class="line"></span><br><span class="line">构建容器镜像</span><br><span class="line">单步测试</span><br><span class="line">docker build -t flask-copy:latest  -f Dockerfile1 --no-cache . </span><br><span class="line"></span><br><span class="line">docker build -t flask   --no-cache . </span><br><span class="line"></span><br><span class="line">sudo docker build -t &#39;testflask&#39; .</span><br><span class="line"></span><br><span class="line">查看容器配置</span><br><span class="line">docker logs swzl</span><br><span class="line"></span><br><span class="line">查看进程</span><br><span class="line">docker ps |grep swzl</span><br><span class="line"></span><br><span class="line">后台守护进程</span><br><span class="line">Docker Dockerfile 定制镜像</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lienhua34&#x2F;p&#x2F;5170335.html</span><br><span class="line"></span><br><span class="line">sudo docker run -it  --rm&#x3D;true 698277f85e44 ls  </span><br><span class="line"></span><br><span class="line">进入终端</span><br><span class="line">docker run -it  --rm&#x3D;true 698277f85e44 &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">进入python</span><br><span class="line">docker run -it  --rm&#x3D;true 698277f85e44</span><br><span class="line"></span><br><span class="line">docker之Dockerfile实践</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lienhua34&#x2F;p&#x2F;5170335.html</span><br><span class="line"></span><br><span class="line">运行 生产环境运行(以daemon方式运行)</span><br><span class="line">sudo docker run -d -p 5000:5000 --name swzl swzl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">激活虚拟环境</span><br><span class="line">source venv&#x2F;bin&#x2F;activate</span><br><span class="line"></span><br><span class="line">从容器中构建新的镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker commit -m&#x3D;&quot;Created from img&quot; -a&#x3D;&quot;iBoy&quot; e537d42ba392 flask-v1:1.0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM python:3.6-alpine</span><br><span class="line">WORKDIR &#x2F;www&#x2F;wwwroot&#x2F;test</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN python -m venv venv</span><br><span class="line">RUN venv&#x2F;bin&#x2F;pip   install  -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple  --upgrade pip</span><br><span class="line">RUN venv&#x2F;bin&#x2F;pip install -r requirements.txt -i  https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">RUN mkdir -p &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech</span><br><span class="line">COPY app.py  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech</span><br><span class="line">COPY wsgi.conf  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech</span><br><span class="line">RUN pip --no-cache-dir install  -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple --upgrade pip</span><br><span class="line">#CMD gunicorn  -c gun.conf app:app</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;gunicorn  -c  &#x2F;www&#x2F;wwwroot&#x2F;swzl.iboy.tech&#x2F;config.py run:app </span><br><span class="line"></span><br><span class="line">docker run -p 8889:8889 --name swzl bc678a304 gunicorn config.py run:app</span><br><span class="line">  </span><br><span class="line">测试运行：docker run -p 8889:8889 --name swzl bc678a304 gunicorn config.py run:app</span><br><span class="line"></span><br><span class="line">docker run -p 5000:5000 --name swzl flask-v1:1.0</span><br><span class="line"></span><br><span class="line">docker run --rm -p 8889:8889 --name swzl</span><br><span class="line"></span><br><span class="line">docker run --name swzl -d -p 8889:8889 --rm swzl:latest</span><br><span class="line"></span><br><span class="line">docker history node-vanilla</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PWD使用</span><br><span class="line">base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.14.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo install &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure>



<h4 id="VsCode远程连接Docker"><a href="#VsCode远程连接Docker" class="headerlink" title="VsCode远程连接Docker"></a>VsCode远程连接Docker</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">原docker.service配置中的ExecStart配置项</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H unix:&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">修改为</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock -H tcp:&#x2F;&#x2F;0.0.0.0:2375</span><br><span class="line"></span><br><span class="line">重启Docker配置生效</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>



<h2 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username&#x3D;yang.hao@aliyun.com registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>您可以在访问凭证页面修改凭证密码。</p>
<h2 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;qmx:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h2 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username&#x3D;yang.hao@aliyun.com registry.cn-hangzhou.aliyuncs.com$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;qmx:[镜像版本号]$ sudo docker push registry.cn-hangzhou.aliyuncs.com&#x2F;iboy&#x2F;qmx:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>
<h2 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h2><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p>
<p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录，并作为镜像命名空间前缀。</p>
<h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h2><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com&#x2F;acs&#x2F;agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB$ sudo docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>

<p>使用”docker images”命令找到镜像，将该镜像名称中的域名部分变更为Registry专有网络地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker push registry-vpc.cn-hangzhou.aliyuncs.com&#x2F;acs&#x2F;agent:0.7-dfb6816</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop初体验</title>
    <url>//post/51380.html</url>
    <content><![CDATA[<h1 id="1、配置JDK的"><a href="#1、配置JDK的" class="headerlink" title="1、配置JDK的"></a>1、配置JDK的</h1><p>JAVA_HOME=/app/jdk1.8.0_171</p><p>CLASSPATH=./$JAVA_HOME/lib/tools.jar</p><a id="more"></a>

<p>PATH=$JAVA_HOME/bin:$PATH</p>
<p>export  JAVA_HOME  CLASSPATH  PATH</p>
<h1 id="2、搭建伪分布式集群"><a href="#2、搭建伪分布式集群" class="headerlink" title="2、搭建伪分布式集群"></a>2、搭建伪分布式集群</h1>]]></content>
  </entry>
  <entry>
    <title>Flask项目的基本结构</title>
    <url>//post/11382.html</url>
    <content><![CDATA[<h2 id="以下内容摘自"><a href="#以下内容摘自" class="headerlink" title="以下内容摘自"></a>以下内容摘自</h2><blockquote>
<p>Flask Web开发：<br>基于Python的Web应用开发实战</p>
</blockquote><h4 id="7-1-项目结构"><a href="#7-1-项目结构" class="headerlink" title="7.1　项目结构"></a>7.1　项目结构</h4><p>Flask 程序的基本结构如示例 7-1 所示。<br>示例 7-1　多文件 Flask 程序的基本结构<br>|-flasky<br>|-app/<br>|-templates/<br>|-static/<br>|-main/<br>|-<strong>init</strong>.py<br>|-errors.py<br>|-forms.py<br>|-views.py<br>|-<strong>init</strong>.py<br>|-email.py<br>|-models.py<br>|-migrations/<br>|-tests/<br>|-<strong>init</strong>.py<br>|-test*.py<br>|-venv/<br>|-requirements.txt<br>|-config.py<br>|-manage.py<br>这种结构有 4 个顶级文件夹：<br>Flask 程序一般都保存在名为 app 的包中； •<br>和之前一样，migrations 文件夹包含数据库迁移脚本； •<br>单元测试编写在 tests 包中； •<br>和之前一样，venv 文件夹包含 Python 虚拟环境。 •<br>同时还创建了一些新文件：<br>requirements.txt 列出了所有依赖包，便于在其他电脑中重新生成相同的虚拟环境； •<br>config.py 存储配置； •<br>manage.py 用于启动程序以及其他的程序任务。 •<br>为了帮助你完全理解这个结构，下面几节讲解把 hello.py 程序转换成这种结构的过程。</p><a id="more"></a>

<h4 id="7-2-配置选项"><a href="#7-2-配置选项" class="headerlink" title="7.2　配置选项"></a>7.2　配置选项</h4><p>程序经常需要设定多个配置。这方面最好的例子就是开发、测试和生产环境要使用不同的<br>数据库，这样才不会彼此影响。<br>我们不再使用 hello.py 中简单的字典状结构配置，而使用层次结构的配置类。config.py 文<br>件的内容如示例 7-2 所示。<br>示例 7-2　config.py：程序的配置<br>import os<br>basedir = os.path.abspath(os.path.dirname(<strong>file</strong>))<br>class Config:<br>SECRET_KEY = os.environ.get(‘SECRET_KEY’) or ‘hard to guess string’<br>SQLALCHEMY_COMMIT_ON_TEARDOWN = True<br>FLASKY_MAIL_SUBJECT_PREFIX = ‘[Flasky]’<br>FLASKY_MAIL_SENDER = ‘Flasky Admin <a href="mailto:&#x66;&#x6c;&#x61;&#115;&#107;&#x79;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;">&#x66;&#x6c;&#x61;&#115;&#107;&#x79;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#109;</a>‘<br>FLASKY_ADMIN = os.environ.get(‘FLASKY_ADMIN’)<br>@staticmethod<br>def init_app(app):<br>pass<br>class DevelopmentConfig(Config):<br>DEBUG = True<br>MAIL_SERVER = ‘smtp.googlemail.com’<br>大型程序的结构 ｜ 67<br>MAIL_PORT = 587<br>MAIL_USE_TLS = True<br>MAIL_USERNAME = os.environ.get(‘MAIL_USERNAME’)<br>MAIL_PASSWORD = os.environ.get(‘MAIL_PASSWORD’)<br>SQLALCHEMY_DATABASE_URI = os.environ.get(‘DEV_DATABASE_URL’) or <br>‘sqlite:///‘ + os.path.join(basedir, ‘data-dev.sqlite’)<br>class TestingConfig(Config):<br>TESTING = True<br>SQLALCHEMY_DATABASE_URI = os.environ.get(‘TEST_DATABASE_URL’) or <br>‘sqlite:///‘ + os.path.join(basedir, ‘data-test.sqlite’)<br>class ProductionConfig(Config):<br>SQLALCHEMY_DATABASE_URI = os.environ.get(‘DATABASE_URL’) or <br>‘sqlite:///‘ + os.path.join(basedir, ‘data.sqlite’)<br>config = {<br>‘development’: DevelopmentConfig,<br>‘testing’: TestingConfig,<br>‘production’: ProductionConfig,<br>‘default’: DevelopmentConfig<br>}<br>基类 Config 中包含通用配置，子类分别定义专用的配置。如果需要，你还可添加其他配<br>置类。<br>为了让配置方式更灵活且更安全，某些配置可以从环境变量中导入。例如， SECRET_KEY 的值，<br>这是个敏感信息，可以在环境中设定，但系统也提供了一个默认值，以防环境中没有定义。<br>在 3 个子类中， SQLALCHEMY_DATABASE_URI 变量都被指定了不同的值。这样程序就可在不同<br>的配置环境中运行，每个环境都使用不同的数据库。<br>配置类可以定义 init_app() 类方法，其参数是程序实例。在这个方法中，可以执行对当前<br>环境的配置初始化。现在，基类 Config 中的 init_app() 方法为空。<br>在这个配置脚本末尾， config 字典中注册了不同的配置环境，而且还注册了一个默认配置<br>（本例的开发环境）。</p>
<h4 id="7-3-程序包"><a href="#7-3-程序包" class="headerlink" title="7.3　程序包"></a>7.3　程序包</h4><p>程序包用来保存程序的所有代码、模板和静态文件。我们可以把这个包直接称为 app（应<br>用），如果有需求，也可使用一个程序专用名字。templates 和 static 文件夹是程序包的一部<br>分，因此这两个文件夹被移到了 app 中。数据库模型和电子邮件支持函数也被移到了这个<br>包中，分别保存为 app/models.py 和 app/email.py。</p>
<p>7.3.1　使用程序工厂函数<br>在单个文件中开发程序很方便，但却有个很大的缺点，因为程序在全局作用域中创建，所<br>以无法动态修改配置。运行脚本时，程序实例已经创建，再修改配置为时已晚。这一点对<br>单元测试尤其重要，因为有时为了提高测试覆盖度，必须在不同的配置环境中运行程序。<br>这个问题的解决方法是延迟创建程序实例，把创建过程移到可显式调用的工厂函数中。这<br>种方法不仅可以给脚本留出配置程序的时间，还能够创建多个程序实例，这些实例有时在<br>测试中非常有用。程序的工厂函数在 app 包的构造文件中定义，如示例 7-3 所示。<br>构造文件导入了大多数正在使用的 Flask 扩展。由于尚未初始化所需的程序实例，所以没<br>有初始化扩展，创建扩展类时没有向构造函数传入参数。 create_app() 函数就是程序的工<br>厂函数，接受一个参数，是程序使用的配置名。配置类在 config.py 文件中定义，其中保存<br>的配置可以使用 Flask app.config 配置对象提供的 from_object() 方法直接导入程序。至<br>于配置对象，则可以通过名字从 config 字典中选择。程序创建并配置好后，就能初始化<br>扩展了。在之前创建的扩展对象上调用 init_app() 可以完成初始化过程。<br>示例 7-3　app/<strong>init</strong>.py：程序包的构造文件<br>from flask import Flask, render_template<br>from flask.ext.bootstrap import Bootstrap<br>from flask.ext.mail import Mail<br>from flask.ext.moment import Moment<br>from flask.ext.sqlalchemy import SQLAlchemy<br>from config import config<br>bootstrap = Bootstrap()<br>mail = Mail()<br>moment = Moment()<br>db = SQLAlchemy()<br>def create_app(config_name):<br>app = Flask(<strong>name</strong>)<br>app.config.from_object(config[config_name])<br>config[config_name].init_app(app)<br>bootstrap.init_app(app)<br>mail.init_app(app)<br>moment.init_app(app)<br>db.init_app(app)</p>
<h1 id="附加路由和自定义的错误页面"><a href="#附加路由和自定义的错误页面" class="headerlink" title="附加路由和自定义的错误页面"></a>附加路由和自定义的错误页面</h1><p>return app<br>工厂函数返回创建的程序示例，不过要注意，现在工厂函数创建的程序还不完整，因为没<br>有路由和自定义的错误页面处理程序。这是下一节要讲的话题。<br>大型程序的结构 ｜ 69<br>7.3.2　在蓝本中实现程序功能<br>转换成程序工厂函数的操作让定义路由变复杂了。在单脚本程序中，程序实例存在于全<br>局作用域中，路由可以直接使用 app.route 修饰器定义。但现在程序在运行时创建，只<br>有调用 create_app() 之后才能使用 app.route 修饰器，这时定义路由就太晚了。和路由<br>一样，自定义的错误页面处理程序也面临相同的困难，因为错误页面处理程序使用 app.<br>errorhandler 修饰器定义。<br>幸好 Flask 使用蓝本提供了更好的解决方法。蓝本和程序类似，也可以定义路由。不同的<br>是，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序<br>的一部分。使用位于全局作用域中的蓝本时，定义路由的方法几乎和单脚本程序一样。<br>和程序一样，蓝本可以在单个文件中定义，也可使用更结构化的方式在包中的多个模块中<br>创建。为了获得最大的灵活性，程序包中创建了一个子包，用于保存蓝本。示例 7-4 是这<br>个子包的构造文件，蓝本就创建于此。<br>示例 7-4　app/main/<strong>init</strong>.py：创建蓝本<br>from flask import Blueprint<br>main = Blueprint(‘main’, <strong>name</strong>)<br>from . import views, errors<br>通过实例化一个 Blueprint 类对象可以创建蓝本。这个构造函数有两个必须指定的参数：<br>蓝本的名字和蓝本所在的包或模块。和程序一样，大多数情况下第二个参数使用 Python 的<br><strong>name</strong> 变量即可。<br>程序的路由保存在包里的 app/main/views.py 模块中，而错误处理程序保存在 app/main/<br>errors.py 模块中。导入这两个模块就能把路由和错误处理程序与蓝本关联起来。注意，这<br>些模块在 app/main/<strong>init</strong>.py 脚本的末尾导入，这是为了避免循环导入依赖，因为在<br>views.py 和 errors.py 中还要导入蓝本 main 。<br>蓝本在工厂函数 create_app() 中注册到程序上，如示例 7-5 所示。<br>示例 7-5　app/<em>init</em>.py：注册蓝本<br>def create_app(config_name):</p>
<h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1><p>from .main import main as main_blueprint<br>app.register_blueprint(main_blueprint)<br>return app<br>示例 7-6 显示了错误处理程序。<br>70 ｜ 第 7 章<br>示例 7-6　app/main/errors.py：蓝本中的错误处理程序<br>from flask import render_template<br>from . import main<br>@main.app_errorhandler(404)<br>def page_not_found(e):<br>return render_template(‘404.html’), 404<br>@main.app_errorhandler(500)<br>def internal_server_error(e):<br>return render_template(‘500.html’), 500<br>在蓝本中编写错误处理程序稍有不同，如果使用 errorhandler 修饰器，那么只有蓝本中的<br>错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用 app_errorhandler 。<br>在蓝本中定义的程序路由如示例 7-7 所示。<br>示例 7-7　app/main/views.py：蓝本中定义的程序路由<br>from datetime import datetime<br>from flask import render_template, session, redirect, url_for<br>from . import main<br>from .forms import NameForm<br>from .. import db<br>from ..models import User<br>@main.route(‘/‘, methods=[‘GET’, ‘POST’])<br>def index():<br>form = NameForm()<br>if form.validate_on_submit():</p>
<h1 id="…-1"><a href="#…-1" class="headerlink" title="…"></a>…</h1><p>return redirect(url_for(‘.index’))<br>return render_template(‘index.html’,<br>form=form, name=session.get(‘name’),<br>known=session.get(‘known’, False),<br>current_time=datetime.utcnow())<br>在蓝本中编写视图函数主要有两点不同：第一，和前面的错误处理程序一样，路由修饰器<br>由蓝本提供；第二， url_for() 函数的用法不同。你可能还记得， url_for() 函数的第一<br>个参数是路由的端点名，在程序的路由中，默认为视图函数的名字。例如，在单脚本程序<br>中， index() 视图函数的 URL 可使用 url_for(‘index’) 获取。<br>在蓝本中就不一样了，Flask 会为蓝本中的全部端点加上一个命名空间，这样就可以在不<br>同的蓝本中使用相同的端点名定义视图函数，而不会产生冲突。命名空间就是蓝本的名字<br>（ Blueprint 构造函数的第一个参数），所以视图函数 index() 注册的端点名是 main.index ，<br>其 URL 使用 url_for(‘main.index’) 获取。<br>大型程序的结构 ｜ 71<br>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如 url_for(‘.<br>index’) 。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向<br>可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。<br>为了完全修改程序的页面，表单对象也要移到蓝本中，保存于 app/main/forms.py 模块。</p>
<h4 id="7-4-启动脚本"><a href="#7-4-启动脚本" class="headerlink" title="7.4　启动脚本"></a>7.4　启动脚本</h4><p>顶级文件夹中的 manage.py 文件用于启动程序。脚本内容如示例 7-8 所示。<br>示例 7-8　manage.py：启动脚本<br>#!/usr/bin/env python<br>import os<br>from app import create_app, db<br>from app.models import User, Role<br>from flask.ext.script import Manager, Shell<br>from flask.ext.migrate import Migrate, MigrateCommand<br>app = create_app(os.getenv(‘FLASK_CONFIG’) or ‘default’)<br>manager = Manager(app)<br>migrate = Migrate(app, db)<br>def make_shell_context():<br>return dict(app=app, db=db, User=User, Role=Role)<br>manager.add_command(“shell”, Shell(make_context=make_shell_context))<br>manager.add_command(‘db’, MigrateCommand)<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>manager.run()<br>这个脚本先创建程序。如果已经定义了环境变量 FLASK_CONFIG ，则从中读取配置名；否则<br>使用默认配置。然后初始化 Flask-Script、Flask-Migrate 和为 Python shell 定义的上下文。<br>出于便利，脚本中加入了 shebang 声明，所以在基于 Unix 的操作系统中可以通过 ./manage.<br>py 执行脚本，而不用使用复杂的 python manage.py 。</p>
<h4 id="7-5-需求文件"><a href="#7-5-需求文件" class="headerlink" title="7.5　需求文件"></a>7.5　需求文件</h4><p>程序中必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号。如果<br>要在另一台电脑上重新生成虚拟环境，这个文件的重要性就体现出来了，例如部署程序时<br>使用的电脑。 pip 可以使用如下命令自动生成这个文件：<br>(venv) $ pip freeze &gt;requirements.txt<br>安装或升级包后，最好更新这个文件。需求文件的内容示例如下：<br>72 ｜ 第 7 章<br>Flask==0.10.1<br>Flask-Bootstrap==3.0.3.1<br>Flask-Mail==0.9.0<br>Flask-Migrate==1.1.0<br>Flask-Moment==0.2.0<br>Flask-SQLAlchemy==1.0<br>Flask-Script==0.6.6<br>Flask-WTF==0.9.4<br>Jinja2==2.7.1<br>Mako==0.9.1<br>MarkupSafe==0.18<br>SQLAlchemy==0.8.4<br>WTForms==1.0.5<br>Werkzeug==0.9.4<br>alembic==0.6.2<br>blinker==1.3<br>itsdangerous==0.23<br>如果你要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下<br>命令：<br>(venv) $ pip install -r requirements.txt<br>当你阅读本书时，该示例 requirements.txt 文件中的版本号可能已经过期了。如果愿意，你<br>可以试着使用这些包的最新版。如果遇到问题，你可以随时换回这个需求文件中的版本，<br>因为这些版本和程序兼容。</p>
<h4 id="7-6-单元测试"><a href="#7-6-单元测试" class="headerlink" title="7.6　单元测试"></a>7.6　单元测试</h4><p>这个程序很小，所以没什么可测试的。不过为了演示，我们可以编写两个简单的测试，如<br>示例 7-9 所示。<br>示例 7-9　tests/test_basics.py：单元测试<br>import unittest<br>from flask import current_app<br>from app import create_app, db<br>class BasicsTestCase(unittest.TestCase):<br>def setUp(self):<br>self.app = create_app(‘testing’)<br>self.app_context = self.app.app_context()<br>self.app_context.push()<br>db.create_all()<br>def tearDown(self):<br>db.session.remove()<br>db.drop_all()<br>self.app_context.pop()<br>def test_app_exists(self):<br>大型程序的结构 ｜ 73<br>self.assertFalse(current_app is None)<br>def test_app_is_testing(self):<br>self.assertTrue(current_app.config[‘TESTING’])<br>这个测试使用 Python 标准库中的 unittest 包编写。 setUp() 和 tearDown() 方法分别在各<br>测试前后运行，并且名字以 test_ 开头的函数都作为测试执行。<br>如果你想进一步了解如何使用 Python 的 unittest 包编写测试，请阅读官方文<br>档（<a href="https://docs.python.org/2/library/unittest.html）。" target="_blank" rel="noopener">https://docs.python.org/2/library/unittest.html）。</a><br>setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程<br>序，然后激活上下文。这一步的作用是确保能在测试中使用 current_app ，像普通请求一<br>样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在 tearDown() 方法<br>中删除。<br>第一个测试确保程序实例存在。第二个测试确保程序在测试配置中运行。若想把 tests 文<br>件夹作为包使用，需要添加 tests/<strong>init</strong>.py 文件，不过这个文件可以为空，因为 unittest<br>包会扫描所有模块并查找测试。<br>如果你从 GitHub 上克隆了这个程序的 Git 仓库，那么可以执行 git checkout<br>7a 签出程序的这个版本。为确保安装了所有依赖包，还需执行 pip install<br>-r requirements.txt 命令。<br>为了运行单元测试，你可以在 manage.py 脚本中添加一个自定义命令。示例 7-10 展示了如<br>何添加 test 命令。<br>示例 7-10　manage.py：启动单元测试的命令<br>@manager.command<br>def test():<br>“””Run the unit tests.”””<br>import unittest<br>tests = unittest.TestLoader().discover(‘tests’)<br>unittest.TextTestRunner(verbosity=2).run(tests)<br>manager.command 修饰器让自定义命令变得简单。修饰函数名就是命令名，函数的文档字符<br>串会显示在帮助消息中。 test() 函数的定义体中调用了 unittest 包提供的测试运行函数。<br>单元测试可使用下面的命令运行：<br>74 ｜ 第 7 章<br>(venv) $ python manage.py test<br>test_app_exists (test_basics.BasicsTestCase) … ok<br>test_app_is_testing (test_basics.BasicsTestCase) … ok<br>.———————————————————————-<br>Ran 2 tests in 0.001s<br>OK</p>
<h4 id="7-7-创建数据库"><a href="#7-7-创建数据库" class="headerlink" title="7.7　创建数据库"></a>7.7　创建数据库</h4><p>重组后的程序和单脚本版本使用不同的数据库。<br>首选从环境变量中读取数据库的 URL，同时还提供了一个默认的 SQLite 数据库做备用。3<br>种配置环境中的环境变量名和 SQLite 数据库文件名都不一样。例如，在开发环境中，数据<br>库 URL 从环境变量 DEV_DATABASE_URL 中读取，如果没有定义这个环境变量，则使用名为<br>data-dev.sqlite 的 SQLite 数据库。<br>不管从哪里获取数据库 URL，都要在新数据库中创建数据表。如果使用 Flask-Migrate 跟<br>踪迁移，可使用如下命令创建数据表或者升级到最新修订版本：<br>(venv) $ python manage.py db upgrade<br>不管你是否相信，第一部分到此就要结束了。现在你已经学到了使用 Flask 开发 Web 程序<br>的必备基础知识，不过可能还不确定如何把这些知识融贯起来开发一个真正的程序。本书<br>第二部分的目的就是解决这个问题，带着你一步一步地开发出一个完整的程序。</p>
]]></content>
      <categories>
        <category>Flask</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo如何备份</title>
    <url>//post/40451.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo backup --init #初始化备份</span><br><span class="line">hexo backup #备份操作</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客优化</title>
    <url>//post/42790.html</url>
    <content><![CDATA[<p>Hexo折腾-扩展篇</p><p>​    主题下载地址：<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a></p><a id="more"></a>

<p>​    1.给Hexo添加搜索功能</p>
<p>​            <a href="https://www.jianshu.com/p/d388119a90ec" target="_blank" rel="noopener">https://www.jianshu.com/p/d388119a90ec</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>​    2.Hexo生成唯一的文章链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>​            <a href="https://segmentfault.com/a/1190000005799711" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005799711</a></p>
<p>​    3.Hexo发布的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>​            <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>美化</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA快捷键</title>
    <url>//post/43648.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Shift+Alt+U</td>
<td>查看类图</td>
</tr>
<tr>
<td>Ctrl+Alt+B</td>
<td>查看接口的实现</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>]]></content>
  </entry>
  <entry>
    <title>Java项目部署</title>
    <url>//post/30839.html</url>
    <content><![CDATA[<h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><p>基于ubuntu 16.04系统，使用 Nginx 进行布署，云服务器为阿里云</p><h2 id="阿里云服务器"><a href="#阿里云服务器" class="headerlink" title="阿里云服务器"></a>阿里云服务器</h2><ul>
<li>选择云服务器:阿里云服务器 <a href="https://www.aliyun.com" target="_blank" rel="noopener">https://www.aliyun.com</a></li>
<li>个人免费获取 [<a href="https://free.aliyun.com/" target="_blank" rel="noopener">https://free.aliyun.com/</a>]</li>
<li>创建服务器选择ubuntu16.04 64位的操作系统</li>
<li>进入控制台,查看实例创建情况</li>
<li>给安全组配置规则，添加8080端口</li>
<li>利用命令行进行远程服务器登录</li>
</ul><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh 用户名@ip地址</span><br></pre></td></tr></table></figure>

<h2 id="相关环境安装"><a href="#相关环境安装" class="headerlink" title="相关环境安装"></a>相关环境安装</h2><p>以下操作都在远程服务器上进行操作 (ubuntu 16.04)</p>
<ul>
<li>先更新 apt 相关源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<ul>
<li>mysql安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install mysql-server</span><br><span class="line">apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>rz/sz命令安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install lrzsz</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx运行及停止</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx start #启动</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx stop  #停止</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件<ul>
<li>编辑文件:/etc/nginx/sites-available/default</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果是多台服务器的话，则在此配置，并修改 location 节点下面的 proxy_pass </span></span><br><span class="line"><span class="attribute">upstream</span> myserver &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听80端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="comment"># 转发请求到本地端口 </span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">                <span class="comment"># 请求转发到多台服务器</span></span><br><span class="line">                <span class="comment"># proxy_pass http://myserver;</span></span><br><span class="line">                <span class="comment"># 设置请求头，并将头信息传递给服务器端 </span></span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">                <span class="comment"># 设置请求头，传递原始请求ip </span></span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>执行nohup java -jar xxx.jar &amp; &gt; log.log</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级上课笔记</title>
    <url>//post/58020.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kali使用</title>
    <url>//post/47784.html</url>
    <content><![CDATA[<h2 id="1、虚拟机网络桥接"><a href="#1、虚拟机网络桥接" class="headerlink" title="1、虚拟机网络桥接"></a>1、虚拟机网络桥接</h2><p><a href="https://blog.csdn.net/Bluffing/article/details/114843586" target="_blank" rel="noopener">https://blog.csdn.net/Bluffing/article/details/114843586</a></p><a id="more"></a>
<h2 id="2、欺骗"><a href="#2、欺骗" class="headerlink" title="2、欺骗"></a>2、欺骗</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启IP转发，不然目标IP没网</span></span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/ip_forward    //这句意思是向这个文件写入1</span><br><span class="line"></span><br><span class="line">ettrcap中target 1是目标机器 target2是网关</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕获图片信息</span></span><br><span class="line"> driftnet -i eth0 </span><br><span class="line"><span class="meta">#</span><span class="bash">arpspoof -i eth0 -t 192.168.124.7 192.168.124.1   //-i后面是网卡，-t 后面填目标ip  最后的填网关</span></span><br><span class="line"></span><br><span class="line">apt-get install dsniff</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter使用</title>
    <url>//post/3217.html</url>
    <content><![CDATA[<h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br></pre></td></tr></table></figure><h1 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h1><p>生成自定义配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>生成的配置文件的路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C:\Users\Default Account\.jupyter\jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>

<p>1、取消启动的密码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># c.NotebookApp.token = '&lt;generated&gt;'</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.token = <span class="string">' '</span></span><br></pre></td></tr></table></figure>

<p>2、修改默认地址</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">#c.NotebookApp.notebook_dir = <span class="meta-string">''</span></span></span><br><span class="line">c.NotebookApp.notebook_dir = 'your path'</span><br><span class="line">c.NotebookApp.notebook_dir = 'O:\Jupyter'</span><br></pre></td></tr></table></figure>

<h1 id="3、设置代码补全"><a href="#3、设置代码补全" class="headerlink" title="3、设置代码补全"></a>3、设置代码补全</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions -i https:<span class="comment">//pypi.mirrors.ustc.edu.cn/simple！</span></span><br></pre></td></tr></table></figure>

<p>设置代码补全的教程：<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions/blob/master/README.md" target="_blank" rel="noopener">https://github.com/ipython-contrib/jupyter_contrib_nbextensions/blob/master/README.md</a></p>
<h1 id="4、Vscode中使用Jupyter"><a href="#4、Vscode中使用Jupyter" class="headerlink" title="4、Vscode中使用Jupyter"></a>4、Vscode中使用Jupyter</h1><p><a href="https://blog.csdn.net/u013709332/article/details/105029123" target="_blank" rel="noopener">https://blog.csdn.net/u013709332/article/details/105029123</a></p>
<blockquote>
<p>相关教程：<a href="https://blog.csdn.net/weixin_37595559/article/details/81540482" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37595559/article/details/81540482</a></p>
<p>numpy官网：<a href="https://www.numpy.org.cn/" target="_blank" rel="noopener">https://www.numpy.org.cn/</a></p>
<p>matplotlib官网：<a href="https://www.matplotlib.org.cn/" target="_blank" rel="noopener">https://www.matplotlib.org.cn/</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Jupyter的快捷键</title>
    <url>//post/50306.html</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/bky-zhwtt123/p/12655382.html" target="_blank" rel="noopener">https://www.cnblogs.com/bky-zhwtt123/p/12655382.html</a></p><a id="more"></a>
<p>知乎：推荐<a href="https://zhuanlan.zhihu.com/p/101646637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/101646637</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linx常用命令-Ubuntu</title>
    <url>//post/37333.html</url>
    <content><![CDATA[<p>1.不保存命令执行记录</p><p>vi /root/.bash_history</p><p>用 history -c 清空历史命令.<br>在.bashrc的最后行追加<br>unset HISTFILE</p><a id="more"></a>


<p>2.开机启动项设置</p>
<p>​    sudo vi /etc/rc.local</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2，	开启防火墙，</span><br><span class="line">启动firewall：</span><br><span class="line"></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line">1</span><br><span class="line">设置开机自启：</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line">1</span><br><span class="line">3，	重启防火墙：</span><br><span class="line"></span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line">1</span><br><span class="line">4，	检查防火墙状态是否打开：</span><br><span class="line"></span><br><span class="line">firewall-cmd --state</span><br><span class="line">1</span><br><span class="line">开端口命令：firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"> </span><br><span class="line">命令含义：</span><br><span class="line"> </span><br><span class="line">--zone #作用域</span><br><span class="line"> </span><br><span class="line">--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line"> </span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在CentOS 7系统中可以用systemd启动vpnserver，先新建启动脚本&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vpnserver.service：</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;SoftEther VPN Server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;share&#x2F;vpnserver&#x2F;vpnserver start</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;share&#x2F;vpnserver&#x2F;vpnserver stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line">然后就可以通过systemctl start vpnserver启动了，并通过systemctl enable vpnserver设置开机自启。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下Swap配置方法</title>
    <url>//post/4849.html</url>
    <content><![CDATA[<p>1.首先用命令free查看系统内Swap 分区大小<br> total used free shared buffers cache</p><a id="more"></a>
<p>​    Mem: 1002 964 38 0 21 410</p>
<p>​    -/+ buffers/cache: 532 470</p>
<p>​    Swap: 1024 24 1000</p>
<p>2.添加swap文件<br>mkdir swap<br>cd swap<br>sudo dd if=/dev/zero of=sfile bs=1024 count=1000000</p>
<p>count=1000000参数代表数量，这个正好是1g，直接增大1g</p>
<p>3.转化为swap文件<br>sudo mkswap sfile</p>
<p>4.激活swap文件<br>sudo swapon sfile</p>
<p>5.查看效果<br>再次输入：free -m</p>
<p>Linux删除文件出现rm: cannot remove `.user.ini’: Operation not permitted</p>
<p><a href="https://blog.csdn.net/sinat_35861727/article/details/79040755" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35861727/article/details/79040755</a></p>
<p>删除交换文件</p>
<p><a href="https://ldjhust.github.io/2018/04/18/rm-swapfile-not-permitted.html" target="_blank" rel="noopener">https://ldjhust.github.io/2018/04/18/rm-swapfile-not-permitted.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux下Python默认版本更改</title>
    <url>//post/30764.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更改Ubuntu18.04默认Python版</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;368b6b822cd8</span><br><span class="line"></span><br><span class="line">update-alternatives --list python</span><br><span class="line">update-alternatives: error: no alternatives forpython</span><br><span class="line"></span><br><span class="line">如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。</span><br><span class="line"></span><br><span class="line"># update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2.7 1</span><br><span class="line"></span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;bin&#x2F;python2.7 to provide &#x2F;usr&#x2F;bin&#x2F;python(python) inauto mode</span><br><span class="line"></span><br><span class="line"># update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3.5 3</span><br><span class="line"></span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;bin&#x2F;python3.4 to provide &#x2F;usr&#x2F;bin&#x2F;python(python) inauto mode</span><br><span class="line"></span><br><span class="line">--install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 &#x2F;usr&#x2F;bin&#x2F;python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">update-alternatives --list python</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python2.7  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python</span><br><span class="line">因此可以在 &#x2F;usr&#x2F;bin&#x2F;下 新建 pip的链接到 python3 安装目录下到 pip3，命令如下：</span><br><span class="line">先建立软件链接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.6&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3.6</span><br><span class="line"></span><br><span class="line">$ update-alternatives --list python</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3.5 6</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 4</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2.7 4</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2 6</span><br><span class="line"></span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3.6 4</span><br><span class="line">sudo update-alternatives --config python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数字越大优先级越高</span><br><span class="line">选择要执行的版本</span><br><span class="line">whereis pip</span><br><span class="line">sudo rm &#x2F;usr&#x2F;bin&#x2F;pip</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;pip2.7 &#x2F;usr&#x2F;bin&#x2F;pip</span><br><span class="line"></span><br><span class="line">首先列出所有可用的python替代版本信息：</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.6 &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">$ update-alternatives --list pip</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;pip pip &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip2.7 5</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;pip pip &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.5 2</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;pip pip &#x2F;usr&#x2F;bin&#x2F;pip3 4</span><br><span class="line">sudo update-alternatives --config pip</span><br><span class="line"></span><br><span class="line">移除替代版本</span><br><span class="line">update-alternatives --remove python &#x2F;usr&#x2F;bin&#x2F;python3.5</span><br><span class="line"></span><br><span class="line">update-alternatives --remove pip &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.5</span><br><span class="line">update-alternatives --remove pip &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip2.7</span><br><span class="line"></span><br><span class="line">只为当前用户更改</span><br><span class="line">alias pip&#x3D;pip3</span><br><span class="line">alias python&#x3D;python3.6</span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装Python3.5</span><br><span class="line">更改Linux下pip 安装包的默认位置</span><br><span class="line">http:&#x2F;&#x2F;www.qfrost.com&#x2F;ubuntu%E5%8D%87%E7%BA%A7Python%E5%8F%8Apip&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;C_chuxin&#x2F;article&#x2F;details&#x2F;82962797?utm_source&#x3D;distribute.pc_relevant.none-task</span><br><span class="line"></span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;python3.5&#x2F;lib&#x2F;python3.5&#x2F;site.py</span><br><span class="line"></span><br><span class="line">USER_SITE &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.5&#x2F;dist-packages&quot;     #用户自定义的依赖安装包的路径</span><br><span class="line"> </span><br><span class="line">USER_BASE &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.5&quot;    #用户自定义的启用Python脚本的路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install python3.5 直接安装可能会报错</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;python&#x2F;3.5.2&#x2F;Python-3.5.2.tgz</span><br><span class="line">cd Python-3.5.2</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3.5&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python3.5</span><br><span class="line"> make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS&#x3D;&quot;-g -O2 -DSQLITE_ENABLE_FTS3&#x3D;1 -DSQLITE_ENABLE_FTS4&#x3D;1 -DSQLITE_ENABLE_RTREE&#x3D;1&quot;</span><br></pre></td></tr></table></figure>



<h4 id="编译安装sqlite3的包"><a href="#编译安装sqlite3的包" class="headerlink" title="编译安装sqlite3的包"></a>编译安装sqlite3的包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> （1）针对这个问题，只能采取最原始的办法来进行安装，具体操作如下;</span><br><span class="line">$ wget https:&#x2F;&#x2F;www.sqlite.org&#x2F;2017&#x2F;sqlite-autoconf-3170000.tar.gz --no-check-certificate</span><br><span class="line">$ tar zxvf sqlite-autoconf-3170000.tar.gz</span><br><span class="line">$ cd sqlite-autoconf-3170000</span><br><span class="line">$ .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS&#x3D;&quot;-g -O2 -DSQLITE_ENABLE_FTS3&#x3D;1 -DSQLITE_ENABLE_FTS4&#x3D;1 -DSQLITE_ENABLE_RTREE&#x3D;1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）对python3进行重新编译</span><br><span class="line">$ cd Python-3.6.2</span><br><span class="line">$ LD_RUN_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sqlite3&#x2F;lib .&#x2F;configure LDFLAGS&#x3D;&quot;-L&#x2F;usr&#x2F;local&#x2F;sqlite3&#x2F;lib&quot; CPPFLAGS&#x3D;&quot;-I &#x2F;usr&#x2F;local&#x2F;sqlite3&#x2F;include&quot;</span><br><span class="line">$ LD_RUN_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sqlite3&#x2F;lib make</span><br><span class="line">$ LD_RUN_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sqlite3&#x2F;lib sudo make install</span><br><span class="line">通过上述安装过程，终于可以顺利实现python对sqlite3的支持了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：： </span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;dpkg </span><br><span class="line">sudo mv info info.bak </span><br><span class="line">sudo mkdir info </span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h4 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;wangweiwells&#x2F;article&#x2F;details&#x2F;88374070</span><br><span class="line">安装pip</span><br><span class="line">4，安装pip（对应Python版本）</span><br><span class="line"></span><br><span class="line">下载pip 包</span><br><span class="line">https:&#x2F;&#x2F;pypi.org&#x2F;project&#x2F;pip&#x2F;9.0.1&#x2F;#files</span><br><span class="line">解压，安装：</span><br><span class="line">tar -zxvf pip-9.0.1.tar.gz</span><br><span class="line">cd pip-9.0.1</span><br><span class="line">python2.7 setup.py install</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py  --no-check-certificate</span><br><span class="line">sudo python get-pip.py</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;jianghao_ava&#x2F;article&#x2F;details&#x2F;81097980</span><br></pre></td></tr></table></figure>

<h5 id="项目依赖导出"><a href="#项目依赖导出" class="headerlink" title="项目依赖导出"></a>项目依赖导出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pipreqs</span><br><span class="line">pipreqs .&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux路由配置</title>
    <url>//post/40399.html</url>
    <content><![CDATA[<p>1.临时路由（重启网卡或者服务器之后生效）</p><p>route add -net 172.25.1.0/24  gw 172.25.5.254</p><a id="more"></a>

<p>route del -net 172.25.1.0/24  gw 172.25.5.254</p>
<p>2.永久路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-eno4 </span><br><span class="line">   172.168.20.0&#x2F;24 via 172.168.10.254 dev eno4</span><br></pre></td></tr></table></figure>

<p>3.重启Nginx</p>
<p>/usr/local/nginx/sbin/nginx </p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>//post/22648.html</url>
    <content><![CDATA[<h1 id="Markdown语法笔记"><a href="#Markdown语法笔记" class="headerlink" title="Markdown语法笔记"></a>Markdown语法笔记</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>注:标题行上下需要留有空行，#号后面需要留有空格，最小为6级标题</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-TOC生成目录"><a href="#2-TOC生成目录" class="headerlink" title="2.TOC生成目录"></a>2.TOC生成目录</h2><p>注：根据标题生成目录</p>
<p>[TOC]</p>
<h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h2><p>单行式：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<p>多行式：</p>
<blockquote>
<p>hello world!<br>hello world!<br>hello world!</p>
</blockquote>
<p>多层嵌套:</p>
<blockquote>
<p>aaaaaaaaa</p>
<blockquote>
<p>bbbbbbbbb</p>
<blockquote>
<p>cccccccccc</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="4-行内标记"><a href="#4-行内标记" class="headerlink" title="4.行内标记"></a>4.行内标记</h2><p>注：用ESC键下面的撇号`做行内标记</p>
<p>eg: 标记外<code>标记内</code>标记外</p>
<p>eg: 标记外<code>hello world</code>标记外</p>
<p>eg: 标记外<code>&lt;div&gt;&lt;b&gt;hello world&lt;/b&gt;&lt;/div&gt;</code>标记外</p>
<p>行内标记之内的HTML标签不会被解析，行内标记之外的HTML标签会被解析</p>
<div><b>hello world</b></div>

<h2 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5.代码块"></a>5.代码块</h2><p>注：使用三个撇号在第一行和最后一行包围代码块,标注代码块使用的程序语言可以给代码显示语法高亮。单行代码用行内标记实现。</p>
<p><code>单行代码: cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>代码中使用Tab键进行缩进<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line"><span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">    num += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<h2 id="6-插入链接"><a href="#6-插入链接" class="headerlink" title="6.插入链接"></a>6.插入链接</h2><!-- [链接文字](链接地址 "链接标题") -->

<p>内链式：</p>
<p><a href="http://www.baidu.com/" target="_blank" rel="noopener">百度1</a></p>
<p>引用式：</p>
<!-- 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。
如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] 
[链接文字]：链接地址的形式 -->

<p><a href="http://www.baidu.com/" target="_blank" rel="noopener">百度2</a></p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="百度">baidu.com</a></p>
<p>自动链接：</p>
<!-- Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<>包起来， Markdown 就会自动把它转成链接 -->

<p><a href="mailto:&#x77;&#x77;&#119;&#46;&#119;&#106;&#120;&#46;&#103;&#103;&#46;&#x36;&#x36;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#x77;&#x77;&#119;&#46;&#119;&#106;&#120;&#46;&#103;&#103;&#46;&#x36;&#x36;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a></p>
<p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>
<h2 id="7-插入图片"><a href="#7-插入图片" class="headerlink" title="7.插入图片"></a>7.插入图片</h2><!-- 注：方括号中的文字是图片地址错误是的提示文字，也就是alt的属性值 -->

<p>内链式：</p>
<p><img src="/static/img/markdown/girl1.png" alt="漂亮女孩" title="描述"></p>
<p><img src="/static/img/markdown/main.png" alt="main"></p>
<p>引用式：</p>
<p><img src="/img/markdown/dog1.png" alt="dog" title="描述"></p>
<h2 id="8-插入图片带有链接"><a href="#8-插入图片带有链接" class="headerlink" title="8.插入图片带有链接"></a>8.插入图片带有链接</h2><p>内链式(参考式)：</p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener"><img src="https://blog.iboy.tech/img/markdown/dog1.png" alt="百度一下" title="百度"></a></p>
<p>引用式：</p>
<p><a href="http://www.baidu.com/" target="_blank" rel="noopener"><img src="/static/img/markdown/dog1.png" alt="百度一下" title="百度"></a></p>
<!-- [baidu] 在上面已经定义过 -->
<!-- [baidu]: https://iboy.tech -->

<h2 id="9-列表"><a href="#9-列表" class="headerlink" title="9.列表"></a>9.列表</h2><p>有序列表： 序号后要有空格</p>
<ol>
<li>one</li>
<li>two</li>
<li>three</li>
</ol>
<p>无序列表： 可使用 + - * 三种符号</p>
<ul>
<li>one</li>
<li>two</li>
<li>three</li>
</ul>
<p>列表嵌套使用：</p>
<ol>
<li>one<ul>
<li>one-one</li>
<li>one-two</li>
<li>one-three</li>
</ul>
</li>
<li>two<ol>
<li>two-one</li>
<li>two-two</li>
<li>two-three</li>
</ol>
</li>
<li>three<ul>
<li>three-one</li>
<li>three-two</li>
<li>three-three</li>
</ul>
</li>
</ol>
<p>列表嵌套代码块：</p>
<p>注： 换行 + 两个Tab</p>
<ul>
<li><p>one</p>
<pre><code>var a = 10;var a = 10;
var a = 10;var a = 10;
var a = 10;var a = 10;
var a = 10;</code></pre></li>
<li><p>two</p>
<pre><code>var b = 20;</code></pre></li>
</ul>
<p>定义型列表：</p>
<!-- 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab) -->

<dl><dt>Markdown</dt><dd>轻量级文本标记语言，可以转换成html, pdf等格式</dd></dl><dl><dt>代码块</dt><dd>以下是代码块(空一行 + 两个Tab)</dd></dl><pre><code>var a = 10;
var b = 10;</code></pre><p>列表缩进：</p>
<!-- 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符 -->

<ul>
<li>第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段第一段<br>第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段第二段</li>
</ul>
<p>第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段第三段</p>
<ul>
<li>paragraph1paragraph1paragraph1 paragraph1paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1 paragraph1paragraph1<br>paragraph2paragraph2paragraph2 paragraph2paragraph2paragraph2 paragraph2paragraph2paragraph2 paragraph2paragraph2paragraph2 paragraph2paragraph2paragraph2 paragraph2paragraph2paragraph2</li>
</ul>
<h2 id="10-任务列表"><a href="#10-任务列表" class="headerlink" title="10.任务列表"></a>10.任务列表</h2><p>请选择你喜欢的水果：</p>
<ul>
<li><input checked disabled type="checkbox"> 桃子</li>
<li><input checked disabled type="checkbox"> 葡萄</li>
<li><input disabled type="checkbox"> 香蕉</li>
</ul>
<h2 id="11-表情"><a href="#11-表情" class="headerlink" title="11.表情"></a>11.表情</h2><p>注：部分主流平台支持，兼容性一般 :smile:<br>:smirk:</p>
<!-- 该标题后面添加了锚点标记，花括号与标题之间要有空格 -->

<h2 id="12-使用内嵌CSS样式"><a href="#12-使用内嵌CSS样式" class="headerlink" title="12.使用内嵌CSS样式"></a>12.使用内嵌CSS样式</h2><p style="color:#ad5d0f;font-size:30px; font-family:'宋体'; ">内链样式</p>
## 13.语义标记(markdown语法)

<p>斜体: <em>斜体</em></p>
<p>斜体: <em>斜体</em></p>
<p>加粗: <strong>加粗</strong></p>
<p><strong><em>加粗+斜体</em></strong></p>
<p><strong><em>加粗+斜体</em></strong></p>
<p><del>删除线</del></p>
<h2 id="14语义标签-html语法"><a href="#14语义标签-html语法" class="headerlink" title="14语义标签(html语法)"></a>14语义标签(html语法)</h2><p><i>斜体</i></p>
<p><b>加粗</b></p>
<p><em>强调</em></p>
<p>上标 Z<sup>a</sup></p>
<p>下标 Z<sub>a</sub></p>
<p>键盘文本 <kbd>Ctrl</kbd></p>
<h2 id="15-分隔符"><a href="#15-分隔符" class="headerlink" title="15.分隔符"></a>15.分隔符</h2><p>注：至少三个 — 或 *** 或 * * *</p>
<hr>
<hr>
<hr>
<h2 id="16-脚注"><a href="#16-脚注" class="headerlink" title="16.脚注"></a>16.脚注</h2><p>注: 会自动将标记解析为1,2,3,…</p>
<p>Markdown<a href="markdwon是一种纯文本标记语言">^1</a></p>
<p>Markdown<a href="markdwon简单好用">^a</a></p>
<h2 id="17-表格"><a href="#17-表格" class="headerlink" title="17.表格"></a>17.表格</h2><p>注： :表示对其方式， ** : 与 | 之间不要有空格,否则有些会不兼容</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="left">b</th>
<th align="right">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">居中</td>
<td align="left">左对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="center">一</td>
<td align="left">二</td>
<td align="right">三</td>
</tr>
<tr>
<td align="center">一</td>
<td align="left">二</td>
<td align="right">三</td>
</tr>
<tr>
<td align="center">一</td>
<td align="left">二</td>
<td align="right">三</td>
</tr>
</tbody></table>
<p>简约写法：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="left">b</th>
<th align="right">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="left">居中</td>
<td align="right">左对齐</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">一</td>
<td align="right">二</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">一</td>
<td align="right">二</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装和破解激活Charles</title>
    <url>//post/49742.html</url>
    <content><![CDATA[<h2 id="charles的下载安装"><a href="#charles的下载安装" class="headerlink" title="charles的下载安装"></a>charles的下载安装</h2><ul>
<li>官网下载地址：<a href="https://www.charlesproxy.com/latest-release/download.do" target="_blank" rel="noopener">https://www.charlesproxy.com/latest-release/download.do</a></li>
<li>安装很简单，一直下一步即可</li>
</ul><a id="more"></a>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><ul>
<li><a href="http://www.charles.ren/" target="_blank" rel="noopener">http://www.charles.ren</a></li>
<li>进入上面的网站，随意输入一个Registered Name，点击「生成」</li>
<li>打开charles-help-register，输入刚刚生成的，然后就激活成功啦</li>
</ul>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Miniconda使用</title>
    <url>//post/14399.html</url>
    <content><![CDATA[<h1 id="1、Miniconda下载"><a href="#1、Miniconda下载" class="headerlink" title="1、Miniconda下载"></a>1、Miniconda下载</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D</a></p><a id="more"></a>
<h1 id="2、设置镜像加速"><a href="#2、设置镜像加速" class="headerlink" title="2、设置镜像加速"></a>2、设置镜像加速</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p>
<h1 id="3、Pycharm使用已有的Anaconda环境"><a href="#3、Pycharm使用已有的Anaconda环境" class="headerlink" title="3、Pycharm使用已有的Anaconda环境"></a>3、Pycharm使用已有的Anaconda环境</h1><p><a href="https://www.jianshu.com/p/be02b6181056" target="_blank" rel="noopener">https://www.jianshu.com/p/be02b6181056</a></p>
<h1 id="4、Miniconda创建虚拟环境"><a href="#4、Miniconda创建虚拟环境" class="headerlink" title="4、Miniconda创建虚拟环境"></a>4、Miniconda创建虚拟环境</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">显示可以安装的Python版本</span><br><span class="line">conda search -f python</span><br><span class="line"></span><br><span class="line">conda create -n py2.7 python=2.7</span><br><span class="line">conda activate py2.7</span><br><span class="line"><span class="meta">#</span><span class="bash">删除</span></span><br><span class="line">conda remove -n py2.7 --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">win激活</span></span><br><span class="line">activate py2.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">win退出</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h1 id="5、设置系统默认的python版本"><a href="#5、设置系统默认的python版本" class="headerlink" title="5、设置系统默认的python版本"></a>5、设置系统默认的python版本</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda install python=<span class="number">3.6</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据恢复</title>
    <url>//post/57165.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先确认你日志是否启用了</span><br><span class="line">show variables like &#39;log_bin&#39;;</span><br><span class="line">show master status</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>MongoDB使用记录</title>
    <url>//post/51005.html</url>
    <content><![CDATA[<h2 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h2><p><a href="http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/#installing-flask-mongoengine" target="_blank" rel="noopener">http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/#installing-flask-mongoengine</a></p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   db.help();查看帮助文档</span><br><span class="line">   show dbs 可以查看所有的数据库</span><br><span class="line"> </span><br><span class="line">   db 可以查看当前的数据库名称</span><br><span class="line"> </span><br><span class="line">   show collection 可以查看当前数据库下的集合</span><br><span class="line"> </span><br><span class="line">   use   test(数据库的名称) 切换到指定的数据库</span><br><span class="line"> </span><br><span class="line">   db.集合名.操作  对集合进行某种操作</span><br><span class="line"> </span><br><span class="line">   比如：</span><br><span class="line"> </span><br><span class="line">   db.集合名.find() 查找</span><br><span class="line"> </span><br><span class="line">   db.集合名.getIndexes() 查看索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给MongoDB设定密码</span><br><span class="line">1.命令行窗口输入mongo，进入mongo环境 </span><br><span class="line">2.切换到 &#39;admin&#39; 数据库 use admin</span><br><span class="line">3.给admin设置用户密码:</span><br><span class="line">4.user: 用户名, pwd: 用户密码,roles: 用来设置用户的权限，比如读，读写 等等</span><br><span class="line">db.createUser(&#123;user: &#39;root&#39;, pwd: &#39;123456&#39;, roles: [&#39;root&#39;]&#125;)</span><br><span class="line">5.验证是否添加成功，&#39;db.auth(用户名，用户密码)&#39; 这里用db.auth(&#39;root&#39;, &#39;123456&#39;) 如果返回 &#39;1&#39;表示验证成功， 如果是 &#39;0&#39; 表示验证失败...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Flask</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx静态文件缓存配置</title>
    <url>//post/64307.html</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/aed6b5204225" target="_blank" rel="noopener">https://www.jianshu.com/p/aed6b5204225</a></p><h1 id="Nginx学习之静态文件服务器配置"><a href="#Nginx学习之静态文件服务器配置" class="headerlink" title="Nginx学习之静态文件服务器配置"></a>Nginx学习之静态文件服务器配置</h1><a id="more"></a>
<p><a href="https://blog.52itstyle.vip/archives/2389/" target="_blank" rel="noopener">https://blog.52itstyle.vip/archives/2389/</a></p>
<p>nginx 缓存机制<br><a href="https://www.cnblogs.com/jun1019/p/6260662.html" target="_blank" rel="noopener">https://www.cnblogs.com/jun1019/p/6260662.html</a><br>Nginx之页面缓存<br><a href="http://blog.csdn.net/w1014074794/article/details/51893766" target="_blank" rel="noopener">http://blog.csdn.net/w1014074794/article/details/51893766</a><br>nginx静态资源缓存策略配置<br><a href="http://blog.csdn.net/yu12377/article/details/77875045" target="_blank" rel="noopener">http://blog.csdn.net/yu12377/article/details/77875045</a><br>nginx静态文件缓存的解决方案<br><a href="http://www.cnblogs.com/wangzhisdu/p/7771069.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangzhisdu/p/7771069.html</a><br>Nginx缓存原理及配置<br><a href="http://blog.csdn.net/wangjianno2/article/details/75201020" target="_blank" rel="noopener">http://blog.csdn.net/wangjianno2/article/details/75201020</a></p>
<p>————————————————<br>版权声明：本文为CSDN博主「北京Java青年」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Amen_Wu/article/details/79454455" target="_blank" rel="noopener">https://blog.csdn.net/Amen_Wu/article/details/79454455</a></p>
<p><a href="https://www.cnblogs.com/jun1019/p/6260662.html" target="_blank" rel="noopener">https://www.cnblogs.com/jun1019/p/6260662.html</a></p>
<p><a href="https://juejin.im/post/5af38e0c518825670c45ef6e" target="_blank" rel="noopener">https://juejin.im/post/5af38e0c518825670c45ef6e</a></p>
<p><strong>说下root 和 alias的区别：</strong> </p>
<p><a href="https://www.jianshu.com/p/aed6b5204225" target="_blank" rel="noopener">https://www.jianshu.com/p/aed6b5204225</a></p>
]]></content>
  </entry>
  <entry>
    <title>PlantUML使用笔记</title>
    <url>//post/1507.html</url>
    <content><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>快捷键 <code>ALT+D</code></p><blockquote>
<p><a href="https://blog.csdn.net/zhaoem82/article/details/104369539" target="_blank" rel="noopener">https://blog.csdn.net/zhaoem82/article/details/104369539</a></p>
</blockquote>]]></content>
  </entry>
  <entry>
    <title>Pyhton+MongoDB实现CRUD</title>
    <url>//post/50599.html</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-#!/usr/bin/python"""@File    : mongodb.py@Time    : 2019/10/20 15:16@Author  : iBoy@Email   : iboy@iboy.tech@Software: PyCharm"""import pymongo# MONGO_URL = 'localhost'# MONGO_DB = 'taobao'# MONGO_TABLE = 'product'## client = pymongo.MongoClient(MONGO_URL)   # 创建一个连接对象# db = client[MONGO_DB]# 第一步，连接MongoDBclient=pymongo.MongoClient('mongodb://127.0.0.1:27017/')# 　　第二步，选择数据库或集合# 第二步，选择数据库或集合# db = client['test']db = client.test# 第一步，连接MongoDB# 选择好数据库后我们需要指定要操作的集合，与数据库的选择类似。tb=db.persons# p = db.persons    # persons集合# p = db['persons']# 　　第三步，添加数据person0=&#123;    'name':'杨豪',    'sex':'男'&#125;person2 = &#123;    'id':'00001',    'name':'Abc',    'age':19&#125;person1 = &#123;    'id':'00002',    'name':'Dfg',    'age':20&#125;print(tb.insert_many([person0,person1,person2]))res = tb.find_one(&#123;'name':'Abc'&#125;)  # 查询 name 为 Abc 的人的信息，返回字典型的数据print(res)res = tb.find(&#123;'age':19&#125;)  # 查询集合中age是20的数据# res = p.find(&#123;'age':&#123;'$gt':20&#125;&#125;)  # 查询集合中age大于20的数据print(res)for r in res:    print(r)res = tb.find(&#123;'name':&#123;'$regex':'^A.*'&#125;&#125;)  # 查询集合中name以A开头的数据print(res)#where = &#123;'name':'Abc'&#125;res = tb.find_one(where)res['age'] = 25result = tb.update(where,res)  # 推荐使用 update_one() 或 update_many()print(result)# 　　我们通过PyMongo库里的MongoClient。其中第一个参数 host 是mongodb的地址，第二个参数是端口 port （不传参数的话默认是27017）　result = tb.delete_one(&#123;'name':'Abc'&#125;)   # 删除名称为Abc的数据，推荐使用 delete_one() 和 delete_many()，执行后调用 result.delete_count,获得删除的数据条数print(result)# client = pymongo.MongoClient(host='127.0.0.1',port=27017)# 　　另一种方法是直接传递MongoDB的连接字符串，以 mongodb 开头。## client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')# 　　第二步，选择数据库或集合## 　　在MongoDB中可以建立多个数据库，其中每个数据库又包含许多集合，类似于关系数据库中的表。选择数据库有两种方法，这两种方法作用相同。## db = client.test    # test数据库# db = client['test']# 　　选择好数据库后我们需要指定要操作的集合，与数据库的选择类似。## p = db.persons    # persons集合# p = db['persons']# 　　第三步，添加数据## 复制代码# person = &#123;#     'id':'00001',#     'name':'Abc',#     'age':19# &#125;# result = p.insert(person)# # 在PyMongo 3.x版本后，官方推荐使用insert_one(),该方法返回的不再是单纯的_id值，我们需要执行result.inserted_id查看 _id 值# print(result)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的时间处理</title>
    <url>//post/22974.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串转换成datetime对象</span><br><span class="line"></span><br><span class="line">from datetime import datetime # 导入datetime模块</span><br><span class="line">value &#x3D; &#39;2017&#x2F;10&#x2F;7&#39;</span><br><span class="line">datetime.strptime(value, &#39;%Y&#x2F;%m&#x2F;%d&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime对象转换成字符串</span><br><span class="line"></span><br><span class="line">from datetime import datetime # 导入datetime模块</span><br><span class="line">stamp &#x3D; datetime(2017, 10, 7) # 生成一个datetime对象</span><br><span class="line">str(stamp) # 转换  #结果显示：&#39;2017-10-07 00:00:00&#39;</span><br><span class="line"></span><br><span class="line">from datetime import datetime # 导入datetime</span><br><span class="line">datetime.datetime转化成字符串</span><br><span class="line">create_time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Poetry使用指南</title>
    <url>//post/38590.html</url>
    <content><![CDATA[<h1 id="Python包管理之poetry的使用"><a href="#Python包管理之poetry的使用" class="headerlink" title="Python包管理之poetry的使用"></a><a href="https://www.cnblogs.com/-wenli/p/13337188.html" target="_blank" rel="noopener">Python包管理之poetry的使用</a></h1><p>poetry是一个Python虚拟环境和依赖管理的工具，之前用pipenv，最近学习httprunner时，接触了poetry。poetry和pipenv类似，另外还提供了打包和发布的功能。<br>官方文档：<a href="https://www.cnblogs.com/-wenli/p/python-poetry.org/docs/" target="_blank" rel="noopener">python-poetry.org/docs/</a></p><a id="more"></a>
<p>python项目部署：<strong>poetry管理本地环境,上线用docker</strong></p>
<p><strong><em>\</em>poetry\</strong>安装**</p>
<p>poetry提供多种安装方式，个人推荐从以下2种方式中选择：</p>
<p>方式一：（推荐）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -sSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;python-poetry&#x2F;poetry&#x2F;master&#x2F;get-poetry.py | python</span><br></pre></td></tr></table></figure>

<p>方式二：（pip）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install --user poetry</span><br></pre></td></tr></table></figure>

<h3 id="工程初始化"><a href="#工程初始化" class="headerlink" title="工程初始化"></a>工程初始化</h3><p>如果当前还没有创建工程，可以使用poetry新建工程：</p>
<p>输入poetry new来创建一个项目脚手架，包括基本结构、pyproject.toml文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ poetry new poetry-demo</span><br></pre></td></tr></table></figure>

<p>这时候，会创建一个包含如下内容的工程，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">poetry-demo</span><br><span class="line">├── pyproject.toml</span><br><span class="line">├── README.rst</span><br><span class="line">├── poetry_demo</span><br><span class="line">│ └── __init__.py</span><br><span class="line">└── tests</span><br><span class="line">├── __init__.py</span><br><span class="line">└── test_poetry_demo.py</span><br></pre></td></tr></table></figure>



<p>除了新建工程，还可以在已有工程的基础上进行创建，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ poetry init</span><br></pre></td></tr></table></figure>

<p>这时候，它会让你输入包名称、版本号等信息，你可以选择输入，也可以选择按下ENTER键使用默认值，完成以后，pyproject.toml如以下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; &quot;poetry-demo&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">description &#x3D; &quot;&quot;</span><br><span class="line">authors &#x3D; [&quot;wenli&quot;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python &#x3D; &quot;*&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line">pytest &#x3D; &quot;^3.4&quot;</span><br></pre></td></tr></table></figure>



<h3 id="依赖包管理"><a href="#依赖包管理" class="headerlink" title="依赖包管理"></a>依赖包管理</h3><p><strong>安装依赖包</strong></p>
<p>可以使用install命令直接解析并安装pyproject.toml的依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ poetry install</span><br><span class="line">pyproject.toml文件的配置如下：</span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">pendulum &#x3D; &quot;^1.4&quot;</span><br></pre></td></tr></table></figure>

<p>也可以可以使用add命令来安装一款Python工具包，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ poetry add numpy</span><br></pre></td></tr></table></figure>

<p>还可以，通过添加配置参数–dev来区分不同环境下的依赖包。</p>
<p>详细：</p>
<p>poetry add flask ：安装最新稳定版本的flask<br>poetry add pytest –dev : 指定为开发依赖，会写到pyproject.toml中的[tool.poetry.dev-dependencies]区域<br>poetry add flask=2.22.0 : 指定具体的版本<br>poetry install : 安装pyproject.toml文件中的全部依赖<br>poetry install –no-dev ： 只安装非development环境的依赖，一般部署时使用<br></p>
<p><strong>更新所有锁定版本的依赖包</strong><br>$ poetry update</p>
<p><strong>更新指定依赖包</strong></p>
<p>$ poetry update numpy<br><strong>卸载依赖包</strong><br>$ poetry remove numpy</p>
<p><strong>查看可以更新的依赖</strong><br>$ poetry show –outdated</p>
<p><strong>查看项目安装的依赖</strong></p>
<p>$ poetry show</p>
<p><strong>树形结构查看项目安装的依赖</strong></p>
<p>$ poetry show -t</p>
<h3 id="虚拟环境管理"><a href="#虚拟环境管理" class="headerlink" title="虚拟环境管理"></a>虚拟环境管理</h3><p>创建虚拟环境<br>创建虚拟环境有2种方式：</p>
<p>方式1：</p>
<p>如果在配置文件中配置了virtualenvs.create=true，执行poetry install时会检查是否有虚拟环境，否则会自动创建。</p>
<p>方式2：</p>
<p><strong>指定创建虚拟环境时使用的Python解释器版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ poetry env use python3.7</span><br></pre></td></tr></table></figure>

<p><strong>激活虚拟环境</strong><br>$ poetry shell<br><strong>查看虚拟环境信息</strong><br>$ poetry env info<br><strong>显示虚拟环境列表</strong><br>$ poetry env list<br><strong>显示虚拟环境绝对路径</strong><br>$ poetry env list –full-path</p>
<p><strong>删除虚拟环境</strong><br>$ poetry env remove python3.7</p>
<p><strong>查看python版本</strong><br>$ poetry run python -V</p>
<blockquote>
<p> 转自：<a href="https://www.cnblogs.com/-wenli/p/13337188.html" target="_blank" rel="noopener">https://www.cnblogs.com/-wenli/p/13337188.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis使用笔记</title>
    <url>//post/32112.html</url>
    <content><![CDATA[<p>命令详解</p><p><a href="https://cloud.tencent.com/developer/article/1151834" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1151834</a></p>]]></content>
      <categories>
        <category>Redis</category>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Flask-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Rose画图</title>
    <url>//post/undefined.html</url>
    <content><![CDATA[<p>1、BCE    (边界类、控制类、实体类)</p><p>概念：</p><p>​    <a href="https://blog.csdn.net/u012372720/article/details/71171660" target="_blank" rel="noopener">https://blog.csdn.net/u012372720/article/details/71171660</a></p><a id="more"></a>


<p>​    <a href="https://www.cnblogs.com/dandanlovehamhamzo/p/4967980.html" target="_blank" rel="noopener">https://www.cnblogs.com/dandanlovehamhamzo/p/4967980.html</a></p>
<p>画法：<a href="https://blog.csdn.net/qq_41937388/article/details/103695719" target="_blank" rel="noopener">https://blog.csdn.net/qq_41937388/article/details/103695719</a></p>
<p>2、时序图</p>
<p><a href="https://blog.csdn.net/yinbucheng/article/details/65631301" target="_blank" rel="noopener">https://blog.csdn.net/yinbucheng/article/details/65631301</a></p>
]]></content>
  </entry>
  <entry>
    <title>Scrapy基本使用</title>
    <url>//post/47501.html</url>
    <content><![CDATA[<h1 id="1、css选择器"><a href="#1、css选择器" class="headerlink" title="1、css选择器"></a>1、css选择器</h1><p><img src="https://upload-images.jianshu.io/upload_images/15317419-0e56fc83d895cf1c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="img"></p>]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor使用</title>
    <url>//post/40974.html</url>
    <content><![CDATA[<h2 id="1、常用命令"><a href="#1、常用命令" class="headerlink" title="1、常用命令"></a>1、常用命令</h2><p>开机自启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable supervisord</span><br><span class="line"></span><br><span class="line">#验证是否开机自启</span><br><span class="line">systemctl is-enabled supervisord</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>TinyDB使用</title>
    <url>//post/61034.html</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/watalo/p/12343260.html" target="_blank" rel="noopener">https://www.cnblogs.com/watalo/p/12343260.html</a></p>]]></content>
  </entry>
  <entry>
    <title>Trojan使用记录</title>
    <url>//post/50747.html</url>
    <content><![CDATA[<h3 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h3><p><a href="https://github.com/trojan-gfw/trojan/releases" target="_blank" rel="noopener">https://github.com/trojan-gfw/trojan/releases</a></p><p>搭配浏览器插件</p><a id="more"></a>

<p><a href="https://blog.csdn.net/shanghaibao123/article/details/44154489" target="_blank" rel="noopener">https://blog.csdn.net/shanghaibao123/article/details/44154489</a></p>
<p>搭配v2rayN实现去全局代理</p>
<p>v2rayN</p>
<p>Windows客户端<a href="https://www.v2rayssr.com/winv2ray.html" target="_blank" rel="noopener">https://www.v2rayssr.com/winv2ray.html</a> </p>
<p>Android客户端 <a href="https://www.v2rayssr.com/v2rayandroid.html" target="_blank" rel="noopener">https://www.v2rayssr.com/v2rayandroid.html</a></p>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Trojan</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8踩坑</title>
    <url>//post/44793.html</url>
    <content><![CDATA[<h5 id="1-启动MySQL报错-ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘localhost’-10061"><a href="#1-启动MySQL报错-ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘localhost’-10061" class="headerlink" title="1.启动MySQL报错:ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)"></a>1.启动MySQL报错:ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)</h5><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;BigData_Mining&#x2F;article&#x2F;details&#x2F;88344513</span><br><span class="line">3、如果【步骤2】中找不到Mysql服务需要手动安装Mysql服务，安装命令为mysqld -install，由于本机中已经安装了mysql服务，所以有如下提示The service already exists!</span><br><span class="line">5、此外，还可以通过在cmd中执行命令net start mysql命令来启动Mysql服务；</span><br></pre></td></tr></table></figure>

<h5 id="2-【错误解决】本地计算机上的mysql服务启动停止后-某些服务在未由其他服务或程序使用时将自动停止"><a href="#2-【错误解决】本地计算机上的mysql服务启动停止后-某些服务在未由其他服务或程序使用时将自动停止" class="headerlink" title="2.【错误解决】本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止"></a>2.【错误解决】本地计算机上的mysql服务启动停止后,某些服务在未由其他服务或程序使用时将自动停止</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_26525215&#x2F;article&#x2F;details&#x2F;53424152</span><br><span class="line">首先，你需要把原来的服务删除：</span><br><span class="line"></span><br><span class="line">mysqld --remove mysql</span><br><span class="line">注意:mysql为你的服务名称，自己可以随便定义的。</span><br><span class="line">此命令需要进入mysql安装目录下的bin目录运行！</span><br><span class="line"></span><br><span class="line">mysql的根目录下：</span><br><span class="line">你需要清空data目录。</span><br><span class="line"></span><br><span class="line">如果没有data目录，请自行创建一个空目录，起名为data！</span><br><span class="line"></span><br><span class="line">然后在bin目录下运行命令:</span><br><span class="line"></span><br><span class="line">mysqld --initialize-insecure --user&#x3D;mysql</span><br><span class="line">mysqld --install mysql --defaults-file&#x3D;d:\mysql-5.7.14-winx64\my.ini</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<h5 id="3-MySQL没有-data-目录的解决方法或者重建-data-目录"><a href="#3-MySQL没有-data-目录的解决方法或者重建-data-目录" class="headerlink" title="3.MySQL没有 data 目录的解决方法或者重建 data 目录"></a>3.MySQL没有 data 目录的解决方法或者重建 data 目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;yicixing7&#x2F;article&#x2F;details&#x2F;52399726</span><br><span class="line">下载 MySQL 免安装版，从 5.7 版本以后，不再含有 data 目录，没有 data 目录也就是没有默认数据库，需要用户手动创建。</span><br><span class="line"></span><br><span class="line">运行创建 data 的命令</span><br><span class="line"></span><br><span class="line">D:\mysql\5.7.12\bin&gt;mysqld --initialize-insecure --user&#x3D;mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将自动创建目录于 home 位置</span><br><span class="line"></span><br><span class="line">D:&#x2F;mysql&#x2F;5.7.12&#x2F;data</span><br><span class="line"></span><br><span class="line">创建完成并启动服务器，此时密码为空</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;mysql -u root -p 即可进入</span><br></pre></td></tr></table></figure>

<p>无法再终端连接mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【1】mysql8 的坑 密码加密规则</span><br><span class="line">　　在MySQL 8.0.以上版本中，caching_sha2_password是默认的身份验证插件，而不是以往的mysql_native_password。</span><br><span class="line"></span><br><span class="line">　　有关此更改对服务器操作的影响以及服务器与客户端和连接器的兼容性的信息，请参阅caching_sha2_password作为首选的身份验证插件。</span><br><span class="line"></span><br><span class="line">　　(翻译自https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.0&#x2F;en&#x2F;caching-sha2-pluggable-authentication.html）</span><br><span class="line"></span><br><span class="line">#如果您还没有配置，那么在配置文件中可以修改，修改配置文件并重启Mysql服务后，新建的用户就可以远程连接了。但现有用户仍然无法远程连接</span><br><span class="line">[mysqld]</span><br><span class="line"># 默认使用 mysql_native_password 插件认证</span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line">终端连接必须设置为caching_sha2_password</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中新建超级管理员</title>
    <url>//post/58909.html</url>
    <content><![CDATA[<p>创建超级管理员账户</p><p>useradd -o -u 0 -g 0 -M -d /root -s /bin/bash admin</p><a id="more"></a>

<p>passwd admin</p>
<p>删除用户</p>
<p>userdel -r admin</p>
<p>查看系统的管理员</p>
<p>vim /etc/passwd </p>
<p>cat /etc/passwd </p>
<p>cat /dev/null &gt; ~/.bash_history &amp;&amp; history -c &amp;&amp; exit</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D人物模型和动作</title>
    <url>//post/54234.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unity3D人物模型和动作</span><br><span class="line">【链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1wtjWZvXET1cjLi3z8UohEQ 密码：6dy5】-模型-【游戏蛮牛】-ar增强现实,虚拟现实,unity3d,unity3d教程下载首选u3d,unity3d官网</span><br><span class="line">|- unity3d角色 elitetrooper 带动作 CS角色 - 0 B</span><br><span class="line"></span><br><span class="line">|- unity3d角色 ArcherWithHorse 骑士带动画Archer WithHorse - 0 B</span><br><span class="line"></span><br><span class="line">|- unity3d 游戏人物模型 野蛮人 Barbarian（带19动作动画） - 0 B</span><br><span class="line"></span><br><span class="line">|- unity3d 游戏人物模型 Ubrin Character Costumization RPG 角色模型换装 - 0 B</span><br><span class="line"></span><br><span class="line">|- unity3d 游戏人物模型 Thief Fantasy Character - 0 B</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode开发环境配置</title>
    <url>//post/50613.html</url>
    <content><![CDATA[<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>图标主题 vscode-icons</p><p><a href="https://www.zhihu.com/question/38435139" target="_blank" rel="noopener">https://www.zhihu.com/question/38435139</a></p><a id="more"></a>

<p>配色主题 </p>
<p><strong>One Dark Pro</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-8a3893a1b55d6e036fb24fa311b5b73a_hd.jpg" alt></p>
<h5 id="Brackets-Light-Pro"><a href="#Brackets-Light-Pro" class="headerlink" title="Brackets Light Pro"></a>Brackets Light Pro</h5><p><img src="https://pic2.zhimg.com/80/v2-eb243facac1a66036c32f78d2c089faf_hd.jpg" alt></p>
<h4 id="Tiny-Light"><a href="#Tiny-Light" class="headerlink" title="Tiny Light"></a>Tiny Light</h4><p><img src="https://pic3.zhimg.com/80/v2-486f1b54ef49edcb4c0550d3185e4973_hd.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插件安装</span><br><span class="line">有两种方式，随便一种就好。</span><br><span class="line">F1 输入 extensions： || ext install。extensions：还可以显示已经安装过的插件。</span><br><span class="line">ctrl + P 然后输入 &gt;ext install</span><br><span class="line"></span><br><span class="line">koroFileHeader 插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OBKoro1&#x2F;koro1FileHeader&#x2F;blob&#x2F;master&#x2F;README.md</span><br><span class="line">顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间</span><br><span class="line">filesize  在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</span><br><span class="line">vetur  vue框架所需的插件，语法高亮、智能感知、Emmet等</span><br><span class="line">Bootstrap 3 Sinnpet  常用 bootstrap 的可以安装。</span><br><span class="line">jQuery Code Snippets  jquery 重度患者必须品</span><br><span class="line">HTML CSS Support 让 html 标签上写class 智能提示当前项目所支持的样式</span><br><span class="line">Atuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改</span><br><span class="line">HTML Snippets   超级实用且初级的 H5代码片段以及提示</span><br><span class="line"></span><br><span class="line">Git history 这样可以看整个仓库文件提交历史，及修改地方</span><br><span class="line">https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5b00474951882542ba08087a</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MirroZhou&#x2F;Blog&#x2F;issues&#x2F;6</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName&#x3D;michelemelluso.gitignore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Document This</span><br><span class="line">Document This 能够一键给代码中的类、函数加上注释，支持函数声明、函数表达式、箭头函数等；</span><br><span class="line"></span><br><span class="line">vscode-</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;f27f452ceb27faker 生成虚拟数 https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;itemsitemName&#x3D;deerawan.vscode-faker</span><br><span class="line"></span><br><span class="line">Icon Fonts</span><br><span class="line">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName&#x3D;idleberg.icon-fonts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Settings Sync同步功能设置插件</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4ffa3b0ad860</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类名自动补全</span><br><span class="line">IntelliSense for CSS class names in HTML</span><br><span class="line">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName&#x3D;Zignd.html-css-class-completion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Prettier</span><br><span class="line">https:&#x2F;&#x2F;medium.com&#x2F;@thoamsy&#x2F;%E4%BD%BF%E7%94%A8-vs-code-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BE%88%E7%88%BD%E7%9A%84%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83-2d393ba5cc45</span><br><span class="line">这个是最近一年最火的格式化工具，能够将你写成💩一样的 JS 也能格式成十分漂亮的代码（前提是没有语法没错）。同时也支持 HTML，CSS，JSON，Markdown 等等文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">括号高亮</span><br><span class="line"></span><br><span class="line">Bracket Pair Colorizer 如果仅仅看它的介绍的话，这个插件是一个会将你的 ([&#123;&#125;]) 这些使用不同的颜色区分出来，提升鉴别度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Path Intellisense</span><br><span class="line">提供 URL 的自动补全功能，这个必须装吧。支持任何语言，触发条件一般是在一对引号中，输入 .&#x2F; ，..&#x2F;, &#x2F; 这些表示路径的前缀，就会跳出来了。像我们的 JS，HTML 中引用文件，CSS 中 url 就再也不用担心了。</span><br><span class="line"></span><br><span class="line">Live Server</span><br><span class="line">这个肯定是一个神器，如果你还不会使用 webpack 或者 parcel 的话。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">颜色选取插件 Color Info	</span><br><span class="line">这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了</span><br><span class="line"></span><br><span class="line">GitLens 显示文件最近的 commit 和作者，显示当前行 commit 信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置滚轮缩放</span><br><span class="line">配置文件如下：</span><br><span class="line">在文件--&gt;首选项--&gt;设置--&gt;用户设置中添加如下代码：</span><br><span class="line">&quot;editor.mouseWheelZoom&quot;: true,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">局部同时编辑</span><br><span class="line">5、按shift+alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VsCode编辑器的字体</span><br><span class="line">据悉，Cascadia Code 是与新版 Windows终端应用程序共同开发的，因此官方推荐最好将该字体与 Windows Terminal 和 Visual Studio &#x2F; VS Code 等文本编辑器搭配使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境变量高亮插件</span><br><span class="line">https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName&#x3D;mikestead.dotenv</span><br><span class="line">VSCode .env syntax highlighting</span><br></pre></td></tr></table></figure>

<h2 id="侧边栏字体"><a href="#侧边栏字体" class="headerlink" title="侧边栏字体"></a>侧边栏字体</h2><p>打开设置，找到settings.json<img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/14/a90d3629fed7ed326f342958720d3e83.png" alt="在这里插入图片描述"><br>其中<br>“editor.fontSize”: 15, //第一个是编辑面板的<br>“window.zoomLevel”: 1.5 //第二个是系统界面的</p>
]]></content>
      <tags>
        <tag>IDE</tag>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用命令</title>
    <url>//post/20075.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除全部</span><br><span class="line">光标移到第一行，然后输入 :.,$d 一回车就全没了，在命令模式下执行的。</span><br><span class="line">：0跳转首行</span><br><span class="line">G跳转末尾</span><br><span class="line">set number 显示行号</span><br><span class="line">yy复制</span><br><span class="line">p粘贴</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>frp + v2ray 利用路由器做代理服务器</title>
    <url>//post/17334.html</url>
    <content><![CDATA[<h2 id="1、Dokcer安装-frps"><a href="#1、Dokcer安装-frps" class="headerlink" title="1、Dokcer安装 frps"></a>1、Dokcer安装 frps</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always --network host -d -v $PWD:/etc/frp --name frps snowdreamtech/frps</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>服务端配置文件 <strong>frps.ini</strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="attr">kcp_bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">81</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">84</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = user</span><br><span class="line"><span class="attr">dashboard_pwd</span> = pwd</span><br><span class="line"><span class="attr">subdomain_host</span> = host</span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">7</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">token</span> = token</span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">1</span>-<span class="number">65535</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">log_file</span> = /etc/frp/frps.log</span><br><span class="line"><span class="attr">log_level</span> = info</span><br></pre></td></tr></table></figure>

<h2 id="2、v2ray-自定义配置"><a href="#2、v2ray-自定义配置" class="headerlink" title="2、v2ray 自定义配置"></a>2、v2ray 自定义配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;inbounds&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;port&quot;: 12340,</span><br><span class="line">            &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">            &quot;sniffing&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: true,</span><br><span class="line">                &quot;destOverride&quot;: [</span><br><span class="line">                    &quot;http&quot;,</span><br><span class="line">                    &quot;tls&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;settings&quot;: &#123;</span><br><span class="line">                &quot;auth&quot;: &quot;noauth&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;port&quot;: 12341,</span><br><span class="line">            &quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">            &quot;sniffing&quot;: &#123;</span><br><span class="line">                &quot;enabled&quot;: true,</span><br><span class="line">                &quot;destOverride&quot;: [</span><br><span class="line">                    &quot;http&quot;,</span><br><span class="line">                    &quot;tls&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;settings&quot;: &#123;</span><br><span class="line">                &quot;auth&quot;: &quot;noauth&quot;,</span><br><span class="line">                &quot;udp&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outbounds&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">            &quot;settings&quot;: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、frpc-配置"><a href="#2、frpc-配置" class="headerlink" title="2、frpc 配置"></a>2、frpc 配置</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#frp.jsxz.cf是免费提供的frp服务器，如果需要使用，请修改下面两处的“test”为你的名称，比如"hello"</span></span><br><span class="line"><span class="comment">#然后可以通过http://hello.jsxz.cf访问你的设备</span></span><br><span class="line"><span class="comment">#如果无法正常使用，请更改名称，注意名称不能和别人重复</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = host</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = token</span><br><span class="line"><span class="attr">user</span> = user</span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">subdomain</span> = w1</span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[socks5_proxy]</span></span><br><span class="line"><span class="comment">#type = tcp</span></span><br><span class="line"><span class="comment">#remote_port = 12340</span></span><br><span class="line"><span class="comment">#plugin = socks5</span></span><br><span class="line"><span class="comment">#use_encryption = true</span></span><br><span class="line"><span class="comment">#plugin_http_user = user</span></span><br><span class="line"><span class="comment">#plugin_http_passwd =pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[http_proxy]</span></span><br><span class="line"><span class="comment">#type = tcp</span></span><br><span class="line"><span class="comment">#remote_port = 12341</span></span><br><span class="line"><span class="comment">#plugin = http_proxy</span></span><br><span class="line"><span class="comment">#use_encryption = true</span></span><br><span class="line"><span class="comment">#plugin_http_user = user</span></span><br><span class="line"><span class="comment">#plugin_http_passwd = pwd</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ftp]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">1234</span></span><br><span class="line"><span class="attr">plugin</span> = static_file</span><br><span class="line"><span class="comment"># 要对外暴露的文件目录</span></span><br><span class="line"><span class="attr">plugin_local_path</span> = /tmp/log</span><br><span class="line"><span class="comment"># 用户访问 URL 中会被去除的前缀，保留的内容即为要访问的文件路径</span></span><br><span class="line"><span class="attr">plugin_strip_prefix</span> = static</span><br><span class="line"><span class="attr">plugin_http_user</span> = user</span><br><span class="line"><span class="attr">plugin_http_passwd</span> = pwd</span><br><span class="line"></span><br><span class="line"><span class="section">[v2ray_socks5_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> =  <span class="number">12340</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">12340</span></span><br><span class="line"></span><br><span class="line"><span class="section">[v2ray_http_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">12341</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">12341</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore使用记录</title>
    <url>//post/29976.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用.gitignore文件删除掉已经提交的文件</span><br><span class="line"> </span><br><span class="line">顺序依次执行如下命令：</span><br><span class="line"></span><br><span class="line">First commit any outstanding code changes, and then, run this command:</span><br><span class="line"></span><br><span class="line">git rm -r --cached .</span><br><span class="line">This removes any changed files from the index(staging area), then just run:</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">Commit it:</span><br><span class="line"></span><br><span class="line">git commit -m &quot;.gitignore is now working&quot;</span><br><span class="line">最后提交到远程仓库，会发现.gitignore文件起作用了。</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Git与GitHub的使用</title>
    <url>//post/22555.html</url>
    <content><![CDATA[<blockquote>
<p>git真的是一个很方便的一个工具，非常值得学习，而且搭配github使用或者是多人项目的开发，真的是很牛x。</p>
</blockquote><a id="more"></a>
<h1 id="分布式与集中式"><a href="#分布式与集中式" class="headerlink" title="分布式与集中式"></a>分布式与集中式</h1><p>学习之前了解一下分布式与集中式<br>假如我们要办一件事,一个人包揽就是集中式，一件事分成几个部分分成几个人做就是分布式，二者最取得的效果是一样的。<br>比如一个javaweb的项目,我们把它简单的分成web页面服务:数据库服务，service服务。</p>
<blockquote>
<p>集中式: 我们将它部署在服务器上，如果服务器出了问题，这个网站就崩了。</p>
</blockquote>
<blockquote>
<p>分布式: 上面的三个，我们用独立服务器放，同一类我们还可以用多个服务器组成，即使一个崩了，还有其他的服务器顶着。</p>
</blockquote>
<p>集中式版本控制: 版本库存放在中央服务器，每次工作都要从中央服务器取出最新的版本，修改以后再提交上去，一旦服务器崩了，或者没网了，工作无法执行。<br>分布式版本控制: 没有中央服务器，每个人的电脑上都有一个完整的版本库，每次工作完以后只要将每次的修改提交给对方就行了。</p>
<h1 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h1><h2 id="git使用前的最小配置"><a href="#git使用前的最小配置" class="headerlink" title="git使用前的最小配置"></a>git使用前的最小配置</h2><blockquote>
<p>git config –global user.name ‘your_name’<br>git config –global user.email ‘your_email@domain.com’<br>缺省等同于local</p>
</blockquote>
<ul>
<li>git config –local        local只对某个仓库有效</li>
<li>git config –global       global对当前用户的所有仓库有效</li>
<li>git config –system       system对系统所有登录的用户有效</li>
</ul>
<blockquote>
<p>在当前仓库中，如果设置了local的话，local优先级要高，system指令用不上</p>
</blockquote>
<p>查看一些配置信息：</p>
<ul>
<li>git config –list –local     只在某一个仓库有效</li>
<li>git config –list –global    所有仓库有效</li>
<li>git config –list –system</li>
</ul>
<h2 id="了解工作区，暂存区，历史版本库"><a href="#了解工作区，暂存区，历史版本库" class="headerlink" title="了解工作区，暂存区，历史版本库"></a>了解工作区，暂存区，历史版本库</h2><p><img src="/static/img/git-github/%E4%B8%89%E4%B8%AA%E5%88%86%E5%8C%BA.png" alt="分区"></p>
<h3 id="git是如何保存数据的"><a href="#git是如何保存数据的" class="headerlink" title="git是如何保存数据的"></a>git是如何保存数据的</h3><p>git存储文件的方式不是存储文件的变化或者差异，他存储的是一系列不同时刻文件的 <strong>快照</strong> .例如，每次你执行 <kbd>git add</kbd> 或者 <kbd>git commmit</kbd> 操作，就会将文件压缩成一个二进制文件，这就是一个Git对象，存在于 ==.git/objects== 目录下。文件的名字是用SHA1算法计算的一个hash值(长度40的字符串)， ==.git/objects== 下成一个子目录，前两个字符是子目录名，后38位是文件名。</p>
<h2 id="git文件"><a href="#git文件" class="headerlink" title=".git文件"></a>.git文件</h2><p>两个比较重要的文件:</p>
<blockquote>
<p>refs/ </p>
<blockquote>
<p>heads    -分支       (例如：前端分支，后端分支，两者互不影响)<br>tags       -里程碑     (标签)</p>
</blockquote>
<p>HEAD      - 查看当前仓库在哪个分支上<br>conig     - 仓库信息<br>objects   - 存储每次操作的二进制文件</p>
</blockquote>
<h2 id="git中文件的几种状态"><a href="#git中文件的几种状态" class="headerlink" title="git中文件的几种状态"></a>git中文件的几种状态</h2><blockquote>
<p>Untracked:   未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<kbd>git add</kbd> 状态变为Staged.</p>
</blockquote>
<blockquote>
<p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.</p>
</blockquote>
<blockquote>
<p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用<kbd>git checkout</kbd> 则丢弃修改过,返回到unmodify状态, 这个<kbd>git checkout</kbd>即从库中取出文件, 覆盖当前修改</p>
</blockquote>
<blockquote>
<p>Staged: 暂存状态. 执行<kbd>git commit</kbd>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行<kbd>git reset HEAD filename </kbd> 取消暂存,文件状态为Modified</p>
</blockquote>
<h2 id="git的常用操作"><a href="#git的常用操作" class="headerlink" title="git的常用操作"></a>git的常用操作</h2><h3 id="1-查看工作区状态"><a href="#1-查看工作区状态" class="headerlink" title="1. 查看工作区状态"></a>1. 查看工作区状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="2-工作区提交到暂存区"><a href="#2-工作区提交到暂存区" class="headerlink" title="2. 工作区提交到暂存区"></a>2. 工作区提交到暂存区</h3><p>对暂存区文件的修改：添加，删除，更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;file-name&gt;</span><br><span class="line">git add .                   //提交所有文件</span><br><span class="line"></span><br><span class="line">git add --ignore-removal    //不提交删除文件</span><br><span class="line">git add -u                  //不提交新文件</span><br></pre></td></tr></table></figure>

<h3 id="3-暂存区提交到版本库"><a href="#3-暂存区提交到版本库" class="headerlink" title="3. 暂存区提交到版本库"></a>3. 暂存区提交到版本库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'message'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-查看历史版本"><a href="#4-查看历史版本" class="headerlink" title="4. 查看历史版本"></a>4. 查看历史版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>                             //查看所有版本历史</span><br><span class="line">git <span class="built_in">log</span> &lt;branch-name&gt;               //查看当前分支</span><br><span class="line">git <span class="built_in">log</span> --graph                     //以图的形式查看版本历史</span><br><span class="line">git <span class="built_in">log</span> --oneline                   //省略一些信息，一次commit只展示一行</span><br></pre></td></tr></table></figure>

<h3 id="5-比较文件差异"><a href="#5-比较文件差异" class="headerlink" title="5. 比较文件差异"></a>5. 比较文件差异</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff [--&lt;file-nameA&gt; [&lt;file-nameB&gt;]]                //比较工作区与暂存区差异，加文件名就只比较文件(可以比多个)的差异</span><br><span class="line"></span><br><span class="line">git diff -cached [--&lt;file-nameA&gt; [&lt;file-nameB&gt;]]        //比较暂存区与head指针所含文件的差异</span><br></pre></td></tr></table></figure>

<h3 id="6-删除工作区和暂存区文件"><a href="#6-删除工作区和暂存区文件" class="headerlink" title="6. 删除工作区和暂存区文件"></a>6. 删除工作区和暂存区文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm &lt;file-name&gt;</span><br></pre></td></tr></table></figure>


<h3 id="7-工作区同步与暂存区一样"><a href="#7-工作区同步与暂存区一样" class="headerlink" title="7. 工作区同步与暂存区一样"></a>7. 工作区同步与暂存区一样</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file-nameA&gt; [file-nameB]</span><br><span class="line">git checkout -- *</span><br></pre></td></tr></table></figure>

<h3 id="8-暂存区同步与历史版本库一样"><a href="#8-暂存区同步与历史版本库一样" class="headerlink" title="8. 暂存区同步与历史版本库一样"></a>8. 暂存区同步与历史版本库一样</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset &lt;branch-name&gt;                     //同步到某一个分支</span><br><span class="line">git reset HEAD -- &lt;filenameA&gt; [filenameB]   //同步到某一个分支的一个或者多个文件</span><br></pre></td></tr></table></figure>

<h3 id="9-版本回溯"><a href="#9-版本回溯" class="headerlink" title="9. 版本回溯"></a>9. 版本回溯</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft &lt;commit-id&gt;</span><br><span class="line">git reset --hard &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
<table style="text-align:center">
   <tr>
      <td colspan="4"> git reset 影响范围</td>
   </tr>
   <tr>
      <td>指令</td>
      <td>HEAD</td>
      <td>暂存区</td>
      <td>工作区</td>
   </tr>
   <tr>
      <td>--soft</td>
      <td>是</td>
      <td>否</td>
      <td>否</td>
   </tr>
   <tr>
      <td>--mixed</td>
      <td>是</td>
      <td>是</td>
      <td>否</td>
   </tr>
   <tr>
      <td>--hard</td>
      <td>是</td>
      <td>是</td>
      <td>是</td>
   </tr>
</table>


<h3 id="10-合并分支"><a href="#10-合并分支" class="headerlink" title="10.  合并分支"></a>10.  合并分支</h3><p>– 基于 <strong>merge</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;merge-nameA&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --abort   //如果不想合并，此命令会返回合并之前的状态</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>fast-forward(快进)与non-fast-forward</strong><br>分支合并，其中一个分支，是另外一个分支的父分支，叫做fast-forward，否则就是non-fast-forward</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/u012937029/article/details/77161584" target="_blank" rel="noopener">merge操作</a>：利用三路合并算法，merge结果与时间先后无关，就是两个人分支会找到一个基准Base(历史版本中的某一次commit,简单情况下就是分支分叉的位置)，如果两个文件相对于Base都不一样，就会产生冲突，需要手动解决。查看两个分支的Base命令： <strong>git merge-base &lt;merge-nameA&gt; &lt;merge-name-B&gt;</strong>。<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6#r_merge_log" target="_blank" rel="noopener">merge之前的文件在merge过程中可以导出查看</a>。</p>
</blockquote>
<p>– 基于 <strong>rebase</strong>的变基操作</p>
<blockquote>
<p>将一个分支的修改移到另外一个分支上，好像”重新播放”一样.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase &lt;branchA&gt;        //相当于在B分支上，把B整合到A上，A，B最近的共同父分支(就是分叉的位置)往后的B分支都不见了，会在A分支后生成一段新的提交。这样，提交历史就是一条干净的直线了。</span><br><span class="line"></span><br><span class="line">//如果发生冲突</span><br><span class="line">git add .</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>最好是在提交到远程仓库之前之前，将自己的版本库进行一次变基操作，再向主项目提交。<br><strong>变基操作的准则：不要对在你的仓库外有副本的分支执行变基。</strong></p>
<h3 id="11-修改工作区和暂存区文件名"><a href="#11-修改工作区和暂存区文件名" class="headerlink" title="11. 修改工作区和暂存区文件名"></a>11. 修改工作区和暂存区文件名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="12-关于分支的操作"><a href="#12-关于分支的操作" class="headerlink" title="12. 关于分支的操作"></a>12. 关于分支的操作</h3><p>– 创建分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>– 查看分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [-v]</span><br></pre></td></tr></table></figure>

<p>– 切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>– 删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>


<h3 id="13-将多个commit整理成一个commit"><a href="#13-将多个commit整理成一个commit" class="headerlink" title="13. 将多个commit整理成一个commit"></a>13. 将多个commit整理成一个commit</h3><p>– 不连续的commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;要整合的最早的一个commit&gt;</span><br></pre></td></tr></table></figure>
<p>演示：<br>先看一段版本历史:<br><img src="/static/img/git-github/rebase%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2.png" alt="版本历史"><br>容易看出版本号为： d09341c ，e3a6b32 ，603e2b3 都是对readme.md的操作，我们想整理成一次commit。<br>先找到要整合的最早的commit的版本号 为 603e2b3<br>执行：<kbd>git rebase -i 603e2b3<kbd><br>进入界面:<br><img src="/static/img/git-github/rebase%E7%89%88%E6%9C%AC%E7%BC%96%E8%BE%91.png" alt="版本历史"><br>修改后：<br>注意看p,s均为简写，下方有注释<br><img src="/static/img/git-github/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84rebase%E7%BC%96%E8%BE%91.png" alt="版本历史"></kbd></kbd></p>
<p>退出后，执行 <kbd>git rebase --continue<kbd></kbd></kbd></p>
<p>进入界面：<br><img src="/static/img/git-github/rebase%E7%BC%96%E8%BE%91%E6%B3%A8%E9%87%8A%E5%89%8D.png" alt="版本历史"><br>添加注释：<br><img src="/static/img/git-github/rebase%E7%BC%96%E8%BE%91%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E5%90%8E.png" alt="版本历史"></p>
<p>-- 连续的commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;整合的最早的一个commit&gt;</span><br></pre></td></tr></table></figure>
<p>类似上方，更简单。</p>
<h3 id="14-消除最近的几个commit"><a href="#14-消除最近的几个commit" class="headerlink" title="14. 消除最近的几个commit"></a>14. 消除最近的几个commit</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit-number&gt;        //工作区和暂存区都会恢复成指定的commit版本号的内容(慎用)</span><br></pre></td></tr></table></figure>


<h3 id="15-开发中如果紧急加塞怎么处理"><a href="#15-开发中如果紧急加塞怎么处理" class="headerlink" title="15. 开发中如果紧急加塞怎么处理"></a>15. 开发中如果紧急加塞怎么处理</h3><p>git stash会将此时工作区和暂存区的内容压入Git的栈中，工作区就是干净的了，此时工作区的内容会和上次的commit内容一样。来避免一次脏提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash:                      //备份当前的工作区和暂存区的已经被track的文件，保存到Git栈中。从最近的一次提交中读取相关内容，让工作区保证和上次提交</span><br><span class="line">git stash save <span class="string">"message"</span>        //同上并添加备注信息</span><br><span class="line">git stash list:                 //显示git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</span><br><span class="line">git stash pop stash@&#123;0&#125;         //从git栈中读取并恢复工作区，然后删除对应的记录，默认恢复最新的（stash@&#123;0&#125;为最新）</span><br><span class="line">git stash apply stash@&#123;0&#125;       //同git stash pop，但不会删除对应的记录</span><br><span class="line">git stash clear                 //清空git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</span><br></pre></td></tr></table></figure>


<h1 id="多人协作以及GitHub的使用"><a href="#多人协作以及GitHub的使用" class="headerlink" title="多人协作以及GitHub的使用"></a>多人协作以及GitHub的使用</h1><h2 id="git备份"><a href="#git备份" class="headerlink" title="git备份"></a>git备份</h2><p>哑协议与智能协议<br>直观区别：哑协议传输进度不可见；智能协议传输可见<br>传输速度：智能协议比哑协议传输速度快</p>
<table>
<thead>
<tr>
<th>常用协议</th>
<th>语法格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>本地协议（1）</td>
<td>/d/Desktop/gitcommit/commit2/.git</td>
<td>哑协议</td>
</tr>
<tr>
<td>本地协议（2）</td>
<td>file:///d/Desktop/gitcommit/commit2/.git</td>
<td>智能协议</td>
</tr>
<tr>
<td>http/https协议</td>
<td><a href="https://github.com/name/learngit.git" target="_blank" rel="noopener">https://github.com/name/learngit.git</a></td>
<td>平时接触到的都是智能协议</td>
</tr>
<tr>
<td>ssh协议</td>
<td><a href="mailto:git@github.com">git@github.com</a>:name/learngit.git</td>
<td>工作中最常用的智能协议</td>
</tr>
</tbody></table>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><h3 id="git-clone的使用"><a href="#git-clone的使用" class="headerlink" title="git clone的使用"></a>git clone的使用</h3><ul>
<li>git clone <版本库的网址> [file-name]<br>如果附带[file-name]，则会生成一个目录名字为[file-name]，默认则为版本库的名字。(注意网址后面是附带.git的)</版本库的网址></li>
</ul>
<h3 id="git-remote的使用"><a href="#git-remote的使用" class="headerlink" title="git remote的使用"></a>git remote的使用</h3><ul>
<li>git remote [-v]<br>查看远程主机 [与网址]</li>
<li>git remote add <主机名> <网址><br>添加主机</网址></主机名></li>
<li>git remote rename <原主机名> <新主机名><br>修改主机名字</新主机名></原主机名></li>
<li>git remote rm <主机名><br>删除主机</主机名></li>
<li>git remote show <主机名><br>查看主机信息</主机名></li>
</ul>
<h3 id="git-fetch的使用"><a href="#git-fetch的使用" class="headerlink" title="git fetch的使用"></a>git fetch的使用</h3><ul>
<li>git fetch <远程主机名> [分支名]<br>取回远程主机所有分支的更新(若附带括号则取指定分支名的更新)</远程主机名></li>
</ul>
<h3 id="git-push的使用"><a href="#git-push的使用" class="headerlink" title="git push的使用"></a>git push的使用</h3><p>git push <远程主机名> [远程分支名]:[本地分支名]</远程主机名></p>
<h3 id="git-pull的使用"><a href="#git-pull的使用" class="headerlink" title="git pull的使用"></a>git pull的使用</h3><ul>
<li>git pull <远程主机名> <远程分支名>:<本地分支名><br>取回远程主机的指定分支，并与指定本地分支合并(一个git pull操作等于先git fetch再git merge)</本地分支名></远程分支名></远程主机名></li>
</ul>
<blockquote>
<p>在git clone的过程中，Git会在本地分支与远程分支之间建立一种追踪关系(tracking)。例如，git clone过程中，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动"追踪"origin/master分支。</p>
</blockquote>
<p>Git也允许手动建立追踪关系</p>
<blockquote>
<p>git branch --set-upstream <本地分支名> <远程仓库名>/<远程分支名></远程分支名></远程仓库名></本地分支名></p>
</blockquote>
<p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>
<blockquote>
<p>git pull <远程仓库名></远程仓库名></p>
</blockquote>
<h3 id="第一次提交到非空GitHub仓库"><a href="#第一次提交到非空GitHub仓库" class="headerlink" title="第一次提交到非空GitHub仓库"></a>第一次提交到非空GitHub仓库</h3><p>例如：github初始化时，带有readme和<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">开源协议</a><br>记得git pull一下</p>
<h3 id="不同人的人修改了不同的文件"><a href="#不同人的人修改了不同的文件" class="headerlink" title="不同人的人修改了不同的文件"></a>不同人的人修改了不同的文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push github chase</span><br><span class="line">To github.com:shanqianyouyu/Learning.git</span><br><span class="line"> ! [rejected]        chase -&gt; chase (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:shanqianyouyu/Learning.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>先 merge一下再push</p>
<h3 id="不同的人修改了相同文件的不同位置"><a href="#不同的人修改了相同文件的不同位置" class="headerlink" title="不同的人修改了相同文件的不同位置"></a>不同的人修改了相同文件的不同位置</h3><p>同上，git会自己整合</p>
<h3 id="不同的人修改了相同文件的相同位置"><a href="#不同的人修改了相同文件的相同位置" class="headerlink" title="不同的人修改了相同文件的相同位置"></a>不同的人修改了相同文件的相同位置</h3><p>同上操作，不过此时，会提示冲突，git会自己整合，但是需要自己解决冲突</p>
<h3 id="不同的人同时变更了文件名和文件内容"><a href="#不同的人同时变更了文件名和文件内容" class="headerlink" title="不同的人同时变更了文件名和文件内容"></a>不同的人同时变更了文件名和文件内容</h3><p>例如：</p>
<ol>
<li>(先)A修改 <strong>index.html</strong> 为 <strong>index.htm</strong> 并且 push到远程仓库</li>
<li>(后)B修改 <strong>index.html</strong> (B不知道文件名已经被修改了),并且修改了文件的内容，push到远端，发现错误，git pull(等同于上面的 git fetch 再 git merge) 一下，发现git自动识别出来，就是git会将B仓库下的   <strong>index.html</strong> 修改成 <strong>index.htm</strong> ，并且内容被修改，再push到远程仓库即可</li>
</ol>
<h3 id="不同的人同时修改了文件名"><a href="#不同的人同时修改了文件名" class="headerlink" title="不同的人同时修改了文件名"></a>不同的人同时修改了文件名</h3><ol>
<li>(先)A修改了 <strong>index.html</strong> 为 <strong>index1.html</strong> ,并且push到远端</li>
<li>(后)B修改 <strong>index.html</strong> 为 <strong>index2.html</strong> ，push到远端报错， <strong>git pull</strong> 到本地，发现发生冲突，这时候需要手动解决冲突， <strong>git status</strong> 会发现，工作区有两个文件 <strong>index1.html</strong> <strong>index2.html</strong> ， <strong>git status</strong> 发现暂存区提示 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">both deleted:    index.html</span><br><span class="line">added by them:   index1.html</span><br><span class="line">added by us:     index2.html</span><br></pre></td></tr></table></figure>
这时候你需要和你的同伴讨论最后的名字是哪一个，然后手动删除不需要的两个文件，提交另外一个即可，再 <strong>git push</strong> 到远程仓库。</li>
</ol>
<h3 id="FETCH-HEAD"><a href="#FETCH-HEAD" class="headerlink" title="FETCH_HEAD"></a>FETCH_HEAD</h3><p>FETCH_HEAD是一个短期引用，以跟踪刚刚从远程存储库获取的内容。 git pull首先调用git fetch，在正常情况下从远程获取一个分支; FETCH_HEAD指向这个分支的提示(它存储提交的SHA1，就像分支一样)。 git pull然后调用git merge，将FETCH_HEAD合并到当前分支。</p>
<h2 id="团队协作中禁止的操作"><a href="#团队协作中禁止的操作" class="headerlink" title="团队协作中禁止的操作"></a><em>团队协作中禁止的操作</em></h2><ul>
<li>git push -f <commit版本号></commit版本号></li>
<li>禁止向集成分支执行变更历史操作(变基操作)</li>
</ul>
<h2 id="如何在Github上找到想要的开源项目呢"><a href="#如何在Github上找到想要的开源项目呢" class="headerlink" title="如何在Github上找到想要的开源项目呢"></a>如何在Github上找到想要的开源项目呢</h2><p>进入<a href="https://github.com/search/advanced" target="_blank" rel="noopener">链接</a>： <a href="https://github.com/search/advanced" target="_blank" rel="noopener">https://github.com/search/advanced</a><br>或者在搜索栏空搜，<img src="/static/img/git-github/git%E7%9A%84%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD.png" alt="git的搜索功能.png"><br>github的help中有教怎么用，或者看看这个<a href="https://zhuanlan.zhihu.com/p/55294261" target="_blank" rel="noopener">链接</a>吧.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">补充：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;450cd21b36a4</span><br><span class="line">#允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false </span><br><span class="line">windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv虚拟环境包管理工具</title>
    <url>//post/58768.html</url>
    <content><![CDATA[<h1 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a>一：前言</h1><p>介绍一个包管理神器-pipenv，这个工具可以让我们在写代码、创建Python运行环境、package依赖关系以及项目合作的时候更有效率。</p><a id="more"></a>
<p>在pycon2018上，Kenneth Reitz介绍的Pipenv在不久就成为了Python官方推荐的包管理工具。下面是pycon2018的链接，推荐大家看看：<a href="https://www.bilibili.com/video/av26610021/?p=1。" target="_blank" rel="noopener">https://www.bilibili.com/video/av26610021/?p=1。</a></p>
<h1 id="二：Python包管理历史"><a href="#二：Python包管理历史" class="headerlink" title="二：Python包管理历史"></a>二：Python包管理历史</h1><p>最初的时候，我们有了Python，但是没有干净的方法来安装软件包，早期的时候，当用户想安装包时，需要先从网上把文件下载下来，解压，然后执行Python setup.py install,就能将包安装好。</p>
<p>后来有了PyPI，开发者可以把他们的包上传到上面，然后其他开发者可以从这里下载他们需要的包，然后再执行python setup.py install 进行安装，但是这样还是存在许多的问题，比如说：整个过程需要人工，不方便自动化，无法安装多个不同版本等等。</p>
<p>再后来有了easy_install，当用户想要安装某个包的是否，只要执行easy_install 包名，工具就会自动把包以及依赖下载下来进行安装，这解决了无法自动化的问题，但是这种方法又带来了新的问题，只能安装，却没有方法卸载。</p>
<p>到了2008年，pip出现了，还引入了requirements files的概念，可以使用户非常方便的复制Python环境。比如说安装某个包，执行pip install 包名，需要卸载，执行pip uninstall 包名，需要批量安装，执行pip install -r requirements.txt。直到现在，pip已经成为非常好用的包管理工具了。pip解决了单个环境下的包管理问题，但是如果我们需要在一台机器上开发多个项目，这多个项目用到了相同包的不同版本，这就成了非常棘手的问题了。</p>
<p>为了解决这个问题，virtualenv出现了。virtualenv可以为每个项目创建一套隔离的Python环境，再使用pip进行包管理。目前pip+virtualenv是目前比较主流的Python开发流程。慢慢的这种方式也逐渐暴露出了缺点，比如pip的requirements.txt过于简单，没办法表示具体的依赖关系，需要使用两个工具（pip+virtualenv）才能完成工作。</p>
<p>为了解决这两个问题pipenv登场了，它主要使用pipfile来取代之前的requirements.txt，pipfile比requirements.txt表达能力更强，默认支持两种依赖，可以将多个requirements.txt的内容合并到一起，方便管理，并且通过pipfile.lock对环境进行明确，详细的描述。pipenv可以让你无缝的使用pipfile，pipfile.lock，保证每个依赖的信息都是明确的，它提供简洁的命令操作virtualenv，并且提供很多辅助工具，比如pipenv graph，可以显示项目的完整依赖关系。</p>
<p>目前Pipenv已经是Python官方推荐的工作流工具了。</p>
<h1 id="三：Pipenv实操"><a href="#三：Pipenv实操" class="headerlink" title="三：Pipenv实操"></a>三：Pipenv实操</h1><p>目前pycharm2018.2.4版本以上已经支持pipenv了。</p>
<p>首先打开命令行：输入pip install pipenv 安装pipenv库。</p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085050252-1351013491.png" alt="img"></p>
<p>然后输入：pipenv，如果有如下提示说明安装成功。</p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085129892-981808638.png" alt="img"></p>
<ul>
<li>接着打开pycharm创建一个项目。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085151756-939121853.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085237419-1349695997.png" alt="img"></p>
<ul>
<li>项目创建完成否生成一个pipfile文件，该文件默认的源是国外的，为了增加安装库的速度，我们把源改成清华源：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085319672-2101539750.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085330856-2099737980.png" alt="img"></p>
<p>下面我们打开pycharm自带的terminal来安装一个简单的模块，检测是否成功。</p>
<p>在命令行输入：pipenv install requests</p>
<p> <img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085726379-2072554360.png" alt="img"></p>
<p>如果出现下面提示，说明安装成功。</p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085510944-1925436841.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085552557-1259083927.png" alt="img"></p>
<p>如果出现如下错误，说明项目名称包含中文名。</p>
<p><img src="https://img2018.cnblogs.com/blog/1277642/201810/1277642-20181011085424601-716320841.png" alt="img"></p>
<p>至此，基本的pipenv环境就搭建好了。</p>
<h1 id="四：pipenv命令详解"><a href="#四：pipenv命令详解" class="headerlink" title="四：pipenv命令详解"></a>四：pipenv命令详解</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install --user --upgrade pipenv # 用户安装pipenv </span><br><span class="line">pipenv --three # 会使用当前系统的Python3创建环境 </span><br><span class="line">pipenv --two # 使用python2创建 </span><br><span class="line">pipenv --python 3.6 指定某一Python版本创建环境 </span><br><span class="line">pipenv run python 文件名 pipenv run pip ...# 运行pip </span><br><span class="line">pipenv shell 激活虚拟环境 </span><br><span class="line">pipenv --where 显示目录信息 </span><br><span class="line">pipenv --venv 显示虚拟环境信息 </span><br><span class="line">pipenv --py 显示Python解释器信息 </span><br><span class="line">pipenv install requests 安装相关模块并加入到Pipfile </span><br><span class="line">pipenv install django==1.11 安装固定版本模块并加入到Pipfile </span><br><span class="line">pipenv graph # 显示依赖图 </span><br><span class="line">pipenv check #检查安全漏洞 </span><br><span class="line">pipenv lock # 生成lockfile</span><br><span class="line">pipenv update # 更新所有的包</span><br><span class="line">pipenv --rm # 删除虚拟环境</span><br><span class="line">pipenv uninstall requests # 卸载包并从Pipfile中移除 </span><br><span class="line">pipenv uninstall --all # 卸载全部包</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title>云尚发卡Docker化</title>
    <url>//post/3462.html</url>
    <content><![CDATA[<h1 id="1、基础镜像"><a href="#1、基础镜像" class="headerlink" title="1、基础镜像"></a>1、基础镜像</h1><p>环境要求</p><ul>
<li><strong>环境要求：</strong><code>Mysql</code>至少<code>5.2</code>、<code>Nginx</code>/<code>Apache</code>、<code>PHP</code>至少<code>5.4</code>。</li>
</ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="number">5.6</span><span class="number">.40</span>-fpm-alpine3<span class="number">.8</span></span><br></pre></td></tr></table></figure><a id="more"></a>



<h1 id="2、需要安装的插件"><a href="#2、需要安装的插件" class="headerlink" title="2、需要安装的插件"></a>2、需要安装的插件</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g'</span> /etc/apk/repositories</span><br><span class="line">docker-php-ext-install pdo_mysql</span><br><span class="line">docker-php-ext-install mysql</span><br></pre></td></tr></table></figure>

<h1 id="3、PHP扩展安装"><a href="#3、PHP扩展安装" class="headerlink" title="3、PHP扩展安装"></a>3、PHP扩展安装</h1><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">说明</th>
<th align="left">状态</th>
<th align="left">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZendGuardLoader</td>
<td align="left">脚本解密</td>
<td align="left">用于解密ZendGuard加密脚本!</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">卸载</a></td>
</tr>
<tr>
<td align="left">ionCube</td>
<td align="left">脚本解密</td>
<td align="left">用于解密ionCube Encoder加密脚本!</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">fileinfo</td>
<td align="left">通用扩展</td>
<td align="left">若可用内存小于1G，可能会安装不上</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">opcache</td>
<td align="left">缓存器</td>
<td align="left">用于加速PHP脚本!</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">卸载</a></td>
</tr>
<tr>
<td align="left">xcache</td>
<td align="left">缓存器</td>
<td align="left">支持脚本缓存和变量缓存!</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">memcache</td>
<td align="left">缓存器</td>
<td align="left">强大的内容缓存器</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">memcached</td>
<td align="left">缓存器</td>
<td align="left">比memcache支持更多高级功能</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">卸载</a></td>
</tr>
<tr>
<td align="left">redis</td>
<td align="left">缓存器</td>
<td align="left">基于内存亦可持久化的Key-Value数据库</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">卸载</a></td>
</tr>
<tr>
<td align="left">apcu</td>
<td align="left">缓存器</td>
<td align="left">脚本缓存器</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">imagemagick</td>
<td align="left">通用扩展</td>
<td align="left">Imagick高性能图形库</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">xdebug</td>
<td align="left">调试器</td>
<td align="left">开源的PHP程序调试器</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">imap</td>
<td align="left">邮件服务</td>
<td align="left">邮件服务器必备</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">exif</td>
<td align="left">通用扩展</td>
<td align="left">用于读取图片EXIF信息</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">intl</td>
<td align="left">通用扩展</td>
<td align="left">提供国际化支持</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">xsl</td>
<td align="left">通用扩展</td>
<td align="left">xsl解析扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">Swoole</td>
<td align="left">通用扩展</td>
<td align="left">异步、并行、高性能网络通信引擎</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">yaf</td>
<td align="left">框架</td>
<td align="left">Yaf是一个C语言编写的PHP框架</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">phalcon</td>
<td align="left">框架</td>
<td align="left">phalcon是一个C语言编写的PHP框架</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">mongo</td>
<td align="left">通用扩展</td>
<td align="left">Mongodb数据库连接驱动</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">sg11</td>
<td align="left">脚本加密</td>
<td align="left">php代码混淆加密</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">pgsql</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展(需提前安装postgresql)</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">pdo_pgsql</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展(需提前安装postgresql)</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">readline</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">snmp</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">ldap</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">recode</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">enchant</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">pspell</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">bz2</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">sysvshm</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">calendar</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">gmp</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">wddx</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
<tr>
<td align="left">sysvmsg</td>
<td align="left">通用扩展</td>
<td align="left">php官方扩展</td>
<td align="left"></td>
<td align="left"><a href="javascript:;">安装</a></td>
</tr>
</tbody></table>
<h1 id="4、访问"><a href="#4、访问" class="headerlink" title="4、访问"></a>4、访问</h1><p>然后新建一个数据库，再打开域名进行安装。<br>        如果遇到权限不足，请修改根目录下的app和install文件夹权限为777.</p>
<p>程序后台入口：<code>http://xx.com/ysmd</code>。</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>云尚</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的备份Hexo博客</title>
    <url>//post/39661.html</url>
    <content><![CDATA[<p>花了一中午的时间把博客从github迁移到了coding，至于为什么要迁移，对比一下就知道了，也可以迁移到其他地方比如  <a href="https://zeit.co/home，提供简短的域名以及全球CDN还有证书，可以关联github" target="_blank" rel="noopener">https://zeit.co/home，提供简短的域名以及全球CDN还有证书，可以关联github</a> 仓库实现自动构建，</p><a id="more"></a>
<p>当然还是coding好用，毕竟是国内的2020年1月coding全面更新，之前的博客都用不了了，拖了很久，终于把博客折腾好了，顺便总结一下寒假学到的东西，先说一下备份吧，偷得帖子，讲的很详细了，主要怕被删帖</p>
<p>用的是一个插件：<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">hexo-git-backup</a>，Hexo官网的插件里搜不到，这个插件发布在了GitHub上，关于安装使用官方也给了很简洁易懂的说明文档。</p>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果你的Hexo版本是2.x.x（查看Hexo版本可使用命令：<code>hexo version</code>）在终端中使用如下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-git-backup@0.0.91 --save</span><br></pre></td></tr></table></figure>

<p>如果你的Hexo版本是3.x.x则使用如下命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>

<h2 id="插件升级"><a href="#插件升级" class="headerlink" title="插件升级"></a>插件升级</h2><p>如果你是通过<code>--save</code>安装的，那么升级之前你必须先删除旧的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm remove hexo-git-backup$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>

<h3 id="新建GitHub仓库"><a href="#新建GitHub仓库" class="headerlink" title="新建GitHub仓库"></a>新建GitHub仓库</h3><p>新建一个 GitHub 仓库用来备份博客（具体操作不再赘述）</p>
<p>复制仓库ＳＳＨ链接备用，此处需确保你的电脑已通过SSH连接到 GitHub ，具体操作可参考<a href="https://help.github.com/en/articles/connecting-to-github-with-ssh" target="_blank" rel="noopener"> GitHub 官方帮助文档</a>。</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>在博客根目录下的 <code>_config.yml</code> 文件中配置插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">backup:    </span><br><span class="line">	type: git    </span><br><span class="line">	repository: github: git@github.com:xxx/xxx.git,branchName       </span><br><span class="line">	gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure>

<h4 id="配置说明："><a href="#配置说明：" class="headerlink" title="配置说明："></a>配置说明：</h4><p>如果你想连同主题一起备份，在 <code>_config.yml</code> 文件中添加主题名即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">backup:    </span><br><span class="line">    type: git    </span><br><span class="line">    theme: coney,landscape,xxx    </span><br><span class="line">	repository:       </span><br><span class="line">    github: git@github.com:xxx/xxx.git,branchName       </span><br><span class="line">    gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果你选择了备份主题例如landscape，那么landscape主题文件夹下的 themes/landscape/.git 文件就会被删除</strong></p>
<p>如果你想自定义 commit 信息，添加一行 <code>message: update xxx</code> 即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">backup:    </span><br><span class="line">	type: git    </span><br><span class="line">	message: update xxx    </span><br><span class="line">	repository:       </span><br><span class="line">        github: git@github.com:xxx/xxx.git,branchName       </span><br><span class="line">        gitcafe: git@github.com:xxx/xxx.git,branchName</span><br></pre></td></tr></table></figure>

<h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>现在就可以使用以下命令备份你的博客到GitHub了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo backup</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo b</span><br></pre></td></tr></table></figure>

<p>博客备份至此就已经结束！安全起见可以每次 <code>hexo d</code> 的时候同步 <code>hexo b</code> 备份一下博文。</p>
<h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p>有时候换了另一台电脑或者另一个系统环境下，想要写博客就不得不把博客文件迁移过去，这一部分是关于博客的迁移，接上文使用 hexo-git-backup 插件的情况下（其他方法备份的博客原理类似）。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>根据 Hexo 官网说明安装 Hexo 即可</p>
<p>附上官网地址：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<p>要部署博客到 GitHub 还需要安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h3><p>下载或者 clone 前文所述备份的博客到本地任意位置，复制备份文件夹内所有文件到新安装的博客目录下，重复文件保留备份的即可。</p>
<p>至此博客迁移已完成，可以”三部曲“测试一下是否迁移成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean$ hexo g$ hexo s</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">分支操作：</span><br><span class="line">git branch -a #查看所有分支 </span><br><span class="line">git branch -r #查看远程分支 </span><br><span class="line">git branch -vv #查看本地分支所关联的远程分支</span><br><span class="line">git branch -m old_branch new_branch # 重命令本地分支</span><br><span class="line">版本回退</span><br><span class="line">git log 显示提交日志</span><br><span class="line">git reset --hard a7e1d279</span><br><span class="line">git checkout -b add_orderdesc 在本地创建+切换分支 </span><br><span class="line">git push origin add_orderdesc 新建远程分支</span><br><span class="line">git branch --set-upstream-to=origin/add_orderdesc 把本地分支与远程origin的分支进行关联处理</span><br><span class="line">git branch -u origin/addFile  建立当前分支与远程分支的映射关系:</span><br><span class="line">git branch --unset-upstream  撤销本地分支与远程分支的映射关系</span><br><span class="line"></span><br><span class="line">touch README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git remote add origin https://xxxxxxx/wangdong/helloworld.git</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">如果本地的代码，没有关联任何远程分支</span><br><span class="line">git remote add origin https://xxxxxxx/wangdong/helloworld.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git remote remove origin 解除当前分支与远程仓库关联</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Coding</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>人月神话读后感</title>
    <url>//post/30551.html</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27521161" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27521161</a></p><h2 id="第一章-焦油坑"><a href="#第一章-焦油坑" class="headerlink" title="第一章 焦油坑"></a>第一章 焦油坑</h2><p>程序变成编程系统产品，它的成本高达九倍。然而，只有它才是真正有用的产品，是大多数系统开发的目标。 编程的乐趣：1.创造事物的快乐。2.来自开发对别人有帮助的东西。3. 将各个零件组装起来并精确运行得到预先想要得到的效果。4.学习的乐趣。5.代码这种介质可以使程序员轻松的创造自己的“城堡”。总之编程非常有趣，在于它不仅满足了我们内心深处进行创造的渴望，而且还愉悦了每个人内在的情感。 编程的苦恼：1.追求完美。2.寻找bug。3.产品完成时已经过时的威胁。4编程人员很少能控制工作环境和工作目标。实际的权威来自于每次任务的完成。5.常常需要依赖别人糟糕的程序和文档。</p><a id="more"></a>

<h2 id="第二章-人月神话"><a href="#第二章-人月神话" class="headerlink" title="第二章 人月神话"></a>第二章 人月神话</h2><p>在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大。 导致这种灾难的原因：</p>
<ol>
<li>乐观主义：编程人员潜在认为程序会一切运行良好，但我们的构思总会存在缺陷，因此总会存在bug，在大型的编程任务中一切正常的概率非常小甚至接近于无。</li>
<li>人月：作者认为用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。 它暗示着人员数量和时间是可以相互替换的。人数和时间的互换仅仅适用于以下情况：某个任务可以分解给参与人员，并且他们之间不需要相互的交流。这在割小麦或收获棉花的工作中是可行的；而在系统编程中近乎不可能。系统编程在增加人力的时候需要额外增加的交流成本，这种交流和沟通的工作量巨大，在相同人月下，增加更多的人手实际上会增加时间进度而不是减少。</li>
<li>系统测试：传统项目往往不重视测试，不安排足够的时间但实际中测试占用了大量时间，因此作者提出1/3 计划 1/6 编码1/4 构件测试和早期系统测试 1/4 系统测试</li>
<li>空泛的估算：产品经理要对自己的估算自信，避免为了顾客的期望的日期而造成不合理的进度安排</li>
<li>重复产生的进度灾难：作者认为向进度落后的项目中增加人手，只会使进度更加落后</li>
</ol>
<h2 id="第三章-外科手术队伍"><a href="#第三章-外科手术队伍" class="headerlink" title="第三章 外科手术队伍"></a>第三章 外科手术队伍</h2><p>优秀的程序员和较差的程序员之间生产率的差异惊人 对于效率和概念的完整性来说最好由少数干练的人员设计和开发。 对于大型系统，需要大量人手来满足产品在时间上的要求 为了调和上述矛盾Mills提出了一种提出了一种类似外科手术队伍组建方式即十人组成的团队由一个人来完成问题的分解，其他人给予他所需要的支持以提高效率和生产力。 对十人的团队进行扩建仅仅对 “外科医生”进行协调即可</p>
<h2 id="第四章-贵族专制-民主政治和系统设计"><a href="#第四章-贵族专制-民主政治和系统设计" class="headerlink" title="第四章 贵族专制,民主政治和系统设计"></a>第四章 贵族专制,民主政治和系统设计</h2><p>作者主张在系统设计中，概念完整性应该是最重要的考虑因素，概念的完整性要求设计必须由一个人或者非常少数由默契的人员来实现。对于大型的项目将设计方法，体系结构方面的工作与具体实现相分离是获得概念完整性的强有力方法。 外部体系结构规定实际上是增强小组的创造性，在毫无限制的实现小组中会产生大量的想法和争议而忽视了具体实现。</p>
<h2 id="第五章-画蛇添足"><a href="#第五章-画蛇添足" class="headerlink" title="第五章 画蛇添足"></a>第五章 画蛇添足</h2><p>实际情况中，尽早的交流和持续沟通能使结构师有较好的成本意识，以及使开发人员获得对设计的信息。 当实现产品时，某些次要特性的修改会造成意料不到的成本开销。 第二个系统是设计师们所设计的最危险的系统。过分的设计，添加很多不需要的功能</p>
<h2 id="第六章-贯彻执行"><a href="#第六章-贯彻执行" class="headerlink" title="第六章 贯彻执行"></a>第六章 贯彻执行</h2><p>为了开发人员准确理解并实现架构师的决策以及架构师小组内的概念一致性，作者提出了以下办法 1.手册或者书面规格说明是非常必要的。 2.形式化定义精确但难以理解，规格说明要形式化定义要与记述性文字相结合。 3.周会和年会是必要的。 4.当存在多重实现时如实地遵从手册更新机器所造成的延迟和成本的消耗，比根据机器调整手册要低。 5.一种有用的机制是由结构师保存电话日志。日志中，他记录了每一个问题和相应的回答。每周，对若干结构师的日志进行合并，重新整理，并发布给用户和实现人员。 6.设立测试小组是使设计决策得以贯彻执行的必要手段，同样也是需要尽早着手，与设计同时实施的重要环节。</p>
<h2 id="第七章-为什么巴比伦塔会失败"><a href="#第七章-为什么巴比伦塔会失败" class="headerlink" title="第七章 为什么巴比伦塔会失败"></a>第七章 为什么巴比伦塔会失败</h2><p>巴比伦塔可能是第一个工程上的彻底失败，但它不是最后一个。交流和交流的结果—组织，是成功的关键。交流和组织的技能需要管理者仔细考虑，相关经验的积累和能力的提高同软件技术本身一样重要。 作者总结巴比伦塔项目失败的原因是缺乏交流和缺乏组织，因此作者认为在软件项目中有效的交流和组织是十分重要的，项目工作手册作为成员交流的成果并且保证了项目的概念一致性。在大型编程项目的组织架构中，为了减少交流的数量提出了树状管理结构。作者建议在小型团队以技术主管为主产品负责人为辅，大型团队中产品负责人为主技术主管为辅。</p>
<h2 id="第八章-胸有成足"><a href="#第八章-胸有成足" class="headerlink" title="第八章 胸有成足"></a>第八章 胸有成足</h2><p>对编码时间的估计使用时间的比值反推各个任务的时间是不合理的并且很可能会带来糟糕的后果 不能以小型程序的工作量来估计大型编程系统产品，两者之间的关系不是线性的。 使用适当的高级语言，编程的生产率可以提高 5 倍。</p>
<h2 id="第九章-削足适履"><a href="#第九章-削足适履" class="headerlink" title="第九章 削足适履"></a>第九章 削足适履</h2><p>开发人员必须设置规模的目标，控制规模，考虑减少规模的方法。同任何开销一样，规模本身不是坏事，但不必要的规模是不可取的。 仅仅对核心程序设定规模目标是不够的，必须把所有方面的规模都编入预算。在指明模块有多大的同时，确切定义模块的功能。开发人员从系统整体出发，面向用户。</p>
<h2 id="第十章-提纲挈领"><a href="#第十章-提纲挈领" class="headerlink" title="第十章 提纲挈领"></a>第十章 提纲挈领</h2><p>项目经理的任务是制订计划，并根据计划实现。但是只有书面计划是精确和可以沟通的。计划中包括了时间、地点、人物、做什么、资金。这些少量的关键文档封装了一些项目经理的工作。如果一开始就认识到它们的普遍性和重要性，那么就可以将文档作为工具友好地利用起来，而不会让它成为令人厌烦的繁重任务。通过遵循文档开展工作，项目经理能更清晰和快速地设定自己的方向。</p>
<h2 id="第十一章-未雨绸缪"><a href="#第十一章-未雨绸缪" class="headerlink" title="第十一章 未雨绸缪"></a>第十一章 未雨绸缪</h2><p>软件开发过程中一定会出现抛弃最初开发的实验性系统因此一定要为舍弃而计划 变化是与生俱来的，不是不合时宜和令人生厌的异常情况，开发人员是交付的用户满意度而不仅仅是有形的产品。 程序后期维护的成本惊人，在解决bug的同时会产生新的bug，所有的修改都倾向于破坏系统的架构，增加了系统的混乱程度</p>
<h2 id="第十二章-干将莫邪"><a href="#第十二章-干将莫邪" class="headerlink" title="第十二章 干将莫邪"></a>第十二章 干将莫邪</h2><p>在软件项目中开发和维护公共的通用编程工具的效率更高。作者建议在团队中加入工具管理人员来统一管理通用工具并且对此不能吝啬人力和物力。 目标机器的使用时间分配成连续的块，机器的利用程度会降低但生产率却能提高。不在使用机器的时间块中的小组可以从事文档书写工作。 作者在开发OS/360中使用了程序库和程序库的管理，是现在版本控制工具的雏形，该工具使得程序是可控的并且程序的开发进展变得正式。 高级语言和交互式编程工具极大的提高开发的效率。</p>
<h2 id="第十三章-整体部分"><a href="#第十三章-整体部分" class="headerlink" title="第十三章 整体部分"></a>第十三章 整体部分</h2><p>开发一个能用的系统容易，但开发一个可靠好用的系统并不容易。本章作者讨论了如何设计一个可靠的系统，首先是前面已经说过的程序开发要保持概念完整性，其次是编写任何代码之前，规格说明必须交给外部测试小组进行测试。作者又提到了自上而下的设计即将系统开发划分为体系结构设计，设计实现和物理编码实现以及结构化编程的概念。无疑这些思想在当时都是比较先进的。并且这些概念现在也有应用。作者再一次强调了测试的复杂性和困难度，作者认为在系统集成测试中使用经过调试的构建单元比“合在一起尝试”更节省时间。可以在集成测试中搭建辅助测试平台，简单来说就是现在测试中使用的桩模块和驱动模块。还有控制变更，一次添加一个构件以及阶段化、定期变更等方法来进行集成。</p>
<h2 id="第十四章-祸起萧墙"><a href="#第十四章-祸起萧墙" class="headerlink" title="第十四章 祸起萧墙"></a>第十四章 祸起萧墙</h2><p>项目进度大幅度落后的原因往往不是重大灾害造成的而是一天一天进度落后造成的。项目进度表的每一件事被称为“里程碑”。里程碑的选择只有一个原则，那就是，里程碑必须是具体的、特定的、可度量的事件，能够进行清晰定义。必须关心每一天的滞后，他们是大灾祸的基本组成部分。计划偏离时一线经理的利益和老板的利益是内在冲突的，但为了解决计划偏离就必须把问题暴露给老板，作者提出了两种办法一是老板和一线经理应该减少角色的冲突，在经理可以处理的情况下老板不要插手，二是以周和月为单位进行项目评审，评审中使得每个人都知道问题的所在，而产品构件经理应准备解释延迟的原因，什么时候结束，采取的步骤和需要的任何帮助——老板提供的，或者是其他小组间接提供的。</p>
<h2 id="第十五章-另外一面"><a href="#第十五章-另外一面" class="headerlink" title="第十五章 另外一面"></a>第十五章 另外一面</h2><p>书写文档是必要的即使是完全开发给自己使用的程序。因为记忆衰退的规律会使用户－作者失去对程序的了解，于是他不得不重拾自己劳动的各个细节。不同用户需要不同的文档作。对使用程序的用户来说需要从文档中了解目的、环境、范围、输入输出等信息这份文档的绝大部分需要在程序编制之前书写。 对验证程序的用户来说需要从文档中了解程序边界值进行测试。 对于修改程序的用户来说需要从文档中了解程序详细的实现细节包括结构图、算法描述、接口描述等。 流程图是被吹捧得最过分的一种程序文档。事实上，很多程序甚至不需要流程图，很少有程序需要一页纸以上的流程图。 作者提倡自文档化的程序即把文档整合到源代码。这对正确维护是直接有力的推动，保证编程用户能方便、即时地得到文档资料。</p>
<h2 id="第十六章-没有银弹"><a href="#第十六章-没有银弹" class="headerlink" title="第十六章 没有银弹"></a>第十六章 没有银弹</h2><p>在未来的十年内，无论是在技术还是管理方法上，都看不出有任何突破性的进步，能够保证在十年内大幅度地提高软件的生产率、可靠性和简洁性。软件活动包括根本任务和次要任务，软件近年来出现的进步都在次要任务上但除非次要任务占了所有工作的9/10，否则即使全部次要任务的时间缩减到零也不会带来生产率数量级上的提高。 作者认为不是软件发展太慢而是硬件发展地太快。软件开发中困难的部分是规格化、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。如果这是事实，那么软件开发总是非常困难的。天生就没有银弹。软件开发具有复杂度、一致性、可变性和不可见性等特点。 针对软件开发中的根本问题的解决方法作者认为目前有购买而不是开发软件、需求精炼和快速原型、增量开发、培养卓越的设计人员这几种。</p>
]]></content>
  </entry>
  <entry>
    <title>pyppeteer 手册</title>
    <url>//post/63440.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间因为有任务，需要四个电商(京东、淘宝、天猫、拼多多)的数据。而其中京东的没什么反爬，基本是随便抓。拼多多的加密参数有点复杂，而且变化也挺频繁的，用的是 selenium，也没什么可提的。抓淘宝和天猫因为用 selenium 滑块过不了，于是就改成了 pyppeteer。现在我说一下使用的心得。有些细节因为当时没有记录，现在也记不起来了。</p><a id="more"></a>
<p>首先 <code>pip install pyppeteer</code> , 这时候我们先看一下 websockets 这个库的版本，因为必须保证这个库是 7.0 的版本。8.0 和 6.0 虽然可以使用，但是在访问多个网页会出现一些无法解决的异常。现在安装 pyppeteer，websockets 的版本默认是 8.0，我们需要先 <code>pip uninstall websockets</code> 卸载 8.0，然后 <code>pip install websockets==7.0</code>。然后我们按照 <a href="https://link.ld246.com/forward?goto=https%3A%2F%2Fgithub.com%2Fmiyakogi%2Fpyppeteer%2Fpull%2F160%2Ffiles" target="_blank" rel="noopener">https://github.com/miyakogi/pyppeteer/pull/160/files</a> 这个网页修改 pyppeteer 的源码(如果是 anaconda，则路径是 anaconda 安装路径\Lib\site-packages\pyppeteer\connection.py 这个文件)。这样准备工作就完成了，这样操作之后就可以避免很多异常。</p>
<p>需要这么费劲的折腾，是因为 pyppeteer 这个库已经很久没有做大的更新了，虽然有点小的改动，但是基本的 bug 还是没有解决。所以如果有 js 基础，最好还是使用 JavaScript 的 puppeteer 这个工具，这个是谷歌出品的，一直在更新维护，基本没有 bug。</p>
<p><strong>补充：有时候会出现明明网页加载完成了，但是还是会出现超时的情况。不知道是什么 bug，解决方法也很简单，只要捕获这个异常，然后该做啥做啥。</strong></p>
<p><strong>以下有的方法前面带 coroutine 这个关键字，有点没有，这是因为带这个参数的方法都是异步方法，这种方法必须被 async 关键字修饰，调用的时候也必须 await 关键字修饰。不过我们既然使用浏览器爬虫了，肯定已经不在乎效率了，异步等于在等网站封，所以只需要遵守某些规则即可(不懂的请百度 asyncio 的使用)，实际上还是同步运行。另外，虽然 page.on（）这个方法是存在的，但是官方文档中并未给出详细的说明，甚至我查看 pyppeteer 的源码也未找到这个函数，不知道是怎么回事。但是参考 puppeteer 的文档也是可以用的，不过报错居多，我也就没有深究了。</strong></p>
<h2 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h2><h2 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h2><ol>
<li>pyppeteer.launcher.launch()<br> 启动 Chrome 进程并返回浏览器实例</li>
</ol>
<p>参数：</p>
<ul>
<li><code>ignoreHTTPSErrors</code>（bool）：是否忽略 HTTPS 错误。默认为 <code>False</code></li>
<li><code>headless</code>（bool）：是否在无头模式下运行浏览器。默认为 <code>True</code> 除非 <code>appMode</code> 或 <code>devtools</code> 选项 <code>True</code></li>
<li><code>executablePath</code> （str）：运行 Chromium 或 Chrome 可执行文件的路径，而不是默认捆绑的 Chromium</li>
<li><code>slowMo</code> （int | float）：按指定的毫秒数减慢 pyppeteer 操作。</li>
<li><code>args</code> （List [str]）：传递给浏览器进程的附加参数（标志）。</li>
<li><code>dumpio</code>（bool）：是否管道浏览器进程 stdout 和 stderr 进入 <code>process.stdout</code> 和 <code>process.stderr</code>。默认为 <code>False</code>。</li>
<li><code>userDataDir</code> （str）：用户数据目录的路径。</li>
<li><code>env</code>（dict）：指定浏览器可见的环境变量。默认与 python 进程相同。</li>
<li><code>devtools</code>（bool）：是否为每个选项卡自动打开 DevTools 面板。如果是此选项 <code>True</code>，<code>headless</code> 则将设置该选项 <code>False</code>。</li>
<li><code>logLevel</code>（int | str）：用于打印日志的日志级别。默认值与根记录器相同。</li>
<li><code>autoClose</code>（bool）：脚本完成时自动关闭浏览器进程。默认为 <code>True</code>。</li>
<li><code>loop</code>（asyncio.AbstractEventLoop）：事件循环（<strong>实验</strong>）。</li>
</ul>
<hr>
<ul>
<li>ignoreHTTPSErrors：意思很明显，不解释</li>
<li>headless：不解释</li>
<li>executablePath：这个一般是默认的路径就行</li>
<li>slowMo：我一般会加这个参数，至于效果吗，好像有点。</li>
<li>args：常用的有[‘–no-sandbox’,’–disable-gpu’, ‘–disable-setuid-sandbox’,’–window-size=1440x900’]</li>
<li>dumpio: 不知道为什么，如果不加 dumpio=True 有时会出现浏览器卡顿</li>
<li>userDataDir：selenium 的 userdata 可以保留 cookie，下次启动可以达到免登录，而这个参数没什么用</li>
<li>env：看需求</li>
<li>devtools：用的不深，没用过</li>
<li>logLevel：没什么用，在 Linux 下还是打印大量的日志</li>
<li>autoClose：默认就好，不过如果你需要保持浏览器状态，可以不关闭，下次直接连接这个已存在的浏览器</li>
<li>loop：暂时不知道有什么用</li>
</ul>
<ol>
<li>pyppeteer.launcher.connect()<br> 连接到现有的 Chrome</li>
</ol>
<p>参数：</p>
<ul>
<li><code>browserWSEndpoint</code>（str）：要连接的浏览器 WebSocket 端点。（<strong>必填</strong>）</li>
<li><code>ignoreHTTPSErrors</code>（bool）：是否忽略 HTTPS 错误。默认为 <code>False</code>。</li>
<li><code>slowMo</code> （int | float）：按指定的毫秒数减慢 pyppeteer 的速度。</li>
<li><code>logLevel</code>（int | str）：用于打印日志的日志级别。默认值与根记录器相同。</li>
<li><code>loop</code>（asyncio.AbstractEventLoop）：事件循环（<strong>实验</strong>）。</li>
</ul>
<p>browserWSEndpoint：格式是 <code>ws://${host}:${port}/devtools/browser/&lt;id&gt;</code>。以前浏览器的 wsEndpoint 这个值，可以通过 <code>brower = pyppeteer.launcher.launch()</code> <code>dev = brower. wsEndpoint</code> 保存这个值就可以下次启动了</p>
<ol>
<li>pyppeteer.launcher.executablePath()<br> 获取默认 Chrome 的可执行路径</li>
</ol>
<h2 id="浏览器类"><a href="#浏览器类" class="headerlink" title="浏览器类"></a>浏览器类</h2><p>pyppeteer.browser.Browser()<br> 这个类是由 launch()返回的实例</p>
<ul>
<li>browserContexts： 返回所有打开的浏览器上下文的列表，在新创建的浏览器中，这将返回单个实例</li>
<li>coroutine close()： 关闭连接并终止浏览器进程</li>
<li>coroutine createIncognitoBrowserContext(): 创建一个新的隐身浏览器上下文。这不会与其他浏览器上下文共享 cookie /缓存</li>
<li>coroutine disconnect(): 断开浏览器</li>
<li>coroutine newPage(): 在此浏览器上创建新页面并返回其对象</li>
<li>coroutine pages(): 获取此浏览器的所有页面。返回格式为列表，包含所有页面</li>
<li>process：返回此浏览器的进程</li>
<li>target(): 获取浏览器中所有活动目标的列表</li>
<li>coroutine userAgent()：返回浏览器的原始 UA</li>
<li>coroutine version(): 获取浏览器的版本</li>
<li>wsEndpoint: 返回 WebSocket 端点 url</li>
</ul>
<h2 id="页面类"><a href="#页面类" class="headerlink" title="页面类"></a>页面类</h2><p>pyppeteer.page.Page()<br> 由 brower.newPage()或者 brower.pages()得到</p>
<ul>
<li>coroutine J()：别名 querySelector(),看名字就知道通过 CSS 选择器来选出元素</li>
<li>coroutine JJ(): 别名 querySelectorAll()</li>
<li>coroutine Jeval(): 功能比 page.J()功能多一点，可以选出网页文本或者属性指</li>
<li>coroutine JJeval(): querySelectorAllEval()</li>
<li>coroutine Jx(): 别名 xpath()</li>
<li>coroutine addScriptTag(): 将脚本标记添加到此页面, 返回 ElementHandle<br> 其中一个 url，path 或 content 选择是必要的。<ul>
<li><code>url</code> （字符串）：要添加的脚本的 URL。</li>
<li><code>path</code> （字符串）：要添加的本地 JavaScript 文件的路径。</li>
<li><code>content</code> （字符串）：要添加的 JavaScript 字符串。</li>
<li><code>type</code>（字符串）：脚本类型。使用 <code>module</code> 以加载一个 JavaScript ES6 模块。</li>
</ul>
</li>
<li>coroutine addStyleTag(): 将样式或链接标记添加到此页面, 返回 ElementHandle<br> 其中一个 <code>url</code>，<code>path</code> 或 <code>content</code> 选择是必要的。<ul>
<li><code>url</code> （字符串）：要添加的链接标记的 URL。</li>
<li><code>path</code> （字符串）：要添加的本地 CSS 文件的路径。</li>
<li><code>content</code> （字符串）：要添加的 CSS 字符串。</li>
</ul>
</li>
<li>coroutine authenticate(): 提供 http 身份验证的凭据</li>
<li>coroutine bringToFront(): 将页面置于前面</li>
<li>browser: 获取该页面所属的浏览器</li>
<li>coroutine click(): 相当于鼠标左键单击匹配的元素,参数是 CSS 选择器的字符串。如果没有匹配到元素，则会引发 PageError<br> 可选参数：<ul>
<li><code>button</code>（str）： ，left，right 或 middle，默认为 left。</li>
<li><code>clickCount</code> （int）：默认为 1。</li>
<li><code>delay</code>（int | float）：等待时间 mousedown 和 mouseup 以毫秒为单位的时间。默认为 0。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong><br> 如果此方法触发导航事件并且存在单独的事件，则 waitForNavigation()最终可能会出现产生意外结果的竞争条件。单击并等待导航的正确模式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure>
<p>await asyncio.gather(</p>
<pre><code>page.waitForNavigation(waitOptions),

page.click(selector, clickOptions),</code></pre><p>)<br>​```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">大概意思是 click()触发如果会跳转网页，则需要 page.waitForNavigation()这个函数来等待。但点击事件和触发事件是同时的，所以需要将这两个事件绑定，代码如上。</span><br><span class="line"></span><br><span class="line">- coroutine close(): 关闭此页面</span><br><span class="line"></span><br><span class="line">- coroutine content(): 获取页面的完整 HTML 内容</span><br><span class="line"></span><br><span class="line">- coroutine cookies(): 获取 cookie。参数为 URL，如果未指定 URL，则此方法返回当前页面 URL 的 cookie。如果指定了 URL，则仅返回这些 URL 的 cookie</span><br><span class="line"></span><br><span class="line">- coverage： 返回 coverage</span><br><span class="line"></span><br><span class="line">- coroutine deleteCookie(): 删除 cookie，参数为 cookie 字段参数，比如 name、url、domain、path 等</span><br><span class="line"></span><br><span class="line">- coroutine emulate(): 模拟给定的设备指标和用户代理。相当于同时设置了 setUserAgent()、setViewport()</span><br><span class="line"></span><br><span class="line">- coroutine emulateMedia(): 模拟页面的 CSS 媒体类型。参数为：screen、print、None。</span><br><span class="line"></span><br><span class="line">- coroutine evaluate(): 在浏览器上执行 js 并获取结果</span><br><span class="line"></span><br><span class="line">- coroutine evaluateHandle(): 同上，只是会返回一个值。至于是什么，没用过</span><br><span class="line"></span><br><span class="line">- coroutine evaluateOnNewDocument(): 也是执行 js，至于区别。好像是在页面跳转时执行</span><br><span class="line"></span><br><span class="line">- coroutine exposeFunction(): 将 python 函数添加到浏览器的 window 对象中 name。不知道有什么用</span><br><span class="line"></span><br><span class="line">- coroutine focus(): 聚焦匹配的元素。如果不存在，抛出 PageError</span><br><span class="line"></span><br><span class="line">- frames：获取此页面的所有 frame</span><br><span class="line"></span><br><span class="line">- coroutine goBack()：返回上一个网页。如果不存在，则返回 None</span><br><span class="line"></span><br><span class="line">- coroutine goForward(): 跳转到下一页。如果不存在，则返回 None</span><br><span class="line"></span><br><span class="line">- coroutine goto(): 访问某个 URL。</span><br><span class="line">   参数：</span><br><span class="line"></span><br><span class="line">  - url：。。。</span><br><span class="line">  - timeout：。。。</span><br><span class="line">  - waitUntil：什么情况下算成功访问。没看懂参数的几个值有什么用</span><br><span class="line"></span><br><span class="line">- coroutine hover(): 鼠标悬停匹配的元素</span><br><span class="line"></span><br><span class="line">- isClosed(): 判断页面是否关闭</span><br><span class="line"></span><br><span class="line">- keyboard： 获取 keyboard 对象</span><br><span class="line"></span><br><span class="line">- mainFrame： 获取 frame 页面的主要内容</span><br><span class="line"></span><br><span class="line">- coroutine metrics(): 好像是获取页面中的信息</span><br><span class="line"></span><br><span class="line">- mouse： 获取 mouse 对象</span><br><span class="line"></span><br><span class="line">- coroutine reload(): 刷新网页</span><br><span class="line"></span><br><span class="line">- coroutine screenshot(): 截图</span><br><span class="line">   参数：</span><br><span class="line"></span><br><span class="line">  - &#96;path&#96;（str）：保存图像的文件路径。屏幕截图类型将从文件扩展名中推断出来。</span><br><span class="line"></span><br><span class="line">  - &#96;type&#96;（str）：指定屏幕截图类型，可以是 &#96;jpeg&#96; 或 &#96;png&#96;。默认为 &#96;png&#96;。</span><br><span class="line"></span><br><span class="line">  - &#96;quality&#96;（int）：图像的质量，在 0-100 之间。不适用于 &#96;png&#96; 图像。</span><br><span class="line"></span><br><span class="line">  - &#96;fullPage&#96;（bool）：如果为 true，请截取完整的可滚动页面。默认为 &#96;False&#96;。</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
<pre><code>clip
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    （字典）：指定页面剪切区域的对象。此选项应包含以下字段：     </span><br><span class="line"></span><br><span class="line">    - &#96;x&#96; （int）：剪辑区域左上角的 x 坐标。</span><br><span class="line">    - &#96;y&#96; （int）：剪辑区域左上角的 y 坐标。</span><br><span class="line">    - &#96;width&#96; （int）：剪切区域的宽度。</span><br><span class="line">    - &#96;height&#96; （int）：剪切区域的高度。</span><br><span class="line"></span><br><span class="line">  - &#96;omitBackground&#96; （bool）：隐藏默认的白色背景并允许捕获具有透明度的屏幕截图。</span><br><span class="line"></span><br><span class="line">  - &#96;encoding&#96;（str）：图像的编码可以是 &#96;&#39;base64&#39;&#96; 或 &#96;&#39;binary&#39;&#96;。默认为 &#96;&#39;binary&#39;&#96;。</span><br><span class="line"></span><br><span class="line">- coroutine select(): 选择选项并返回所选值。如果未找到元素，抛出 ElementHandleError。</span><br><span class="line"></span><br><span class="line">- coroutine setCacheEnabled(): 为每个请求启用&#x2F;禁用缓存。默认启用</span><br><span class="line"></span><br><span class="line">- coroutine setContent(): 将 HTML 加到网页</span><br><span class="line"></span><br><span class="line">- coroutine setCookie(): 设置 cookie</span><br><span class="line"></span><br><span class="line">- setDefaultNavigationTimeout(): 更改默认的最大导航超时。默认 30 秒</span><br><span class="line"></span><br><span class="line">- coroutine setJavaScriptEnabled(): 设置 JavaScript 启用&#x2F;禁用</span><br><span class="line"></span><br><span class="line">- coroutine setExtraHTTPHeaders(): 设置默认 headers 头，值为一个字典</span><br><span class="line"></span><br><span class="line">- coroutine setRequestInterception(): 启用&#x2F;禁用请求拦截。配合 page.on()</span><br><span class="line"></span><br><span class="line">- coroutine setUserAgent(): 设置要在此页面中使用的 UA</span><br><span class="line"></span><br><span class="line">- coroutine setViewport(): 设置窗口大小。</span><br><span class="line">   参数：</span><br><span class="line"></span><br><span class="line">  - &#96;width&#96; （int）：以像素为单位的页面宽度。</span><br><span class="line">  - &#96;height&#96; （int）：以像素为单位的页面高度。</span><br><span class="line">  - &#96;deviceScaleFactor&#96; （float）：默认为 1.0。</span><br><span class="line">  - &#96;isMobile&#96;（bool）：默认为 &#96;False&#96;。</span><br><span class="line">  - &#96;hasTouch&#96;（bool）：默认为 &#96;False&#96;。</span><br><span class="line">  - &#96;isLandscape&#96;（bool）：默认为 &#96;False&#96;。</span><br><span class="line"></span><br><span class="line">- coroutine tap(): 点击与之匹配的元素</span><br><span class="line"></span><br><span class="line">- coroutine title(): 获取页面标签</span><br><span class="line"></span><br><span class="line">- tracing：获取 tracing 对象</span><br><span class="line"></span><br><span class="line">- coroutine type(): 往输入框中输入内容，第一个参数为 CSS 选择器，第二个为文本内容</span><br><span class="line"></span><br><span class="line">- url：获取此页面的 url</span><br><span class="line"></span><br><span class="line">- waitFor(): 等待页面上匹配的函数，超时或元素。参数可以是 int 或者 float，单位毫秒。也可以是 CSS 选择器</span><br><span class="line"></span><br><span class="line">- waitForFunction():</span><br><span class="line"></span><br><span class="line">- coroutine waitForNavigation(): 等到网页跳转</span><br><span class="line"></span><br><span class="line">- coroutine waitForRequest(): 等待请求</span><br><span class="line"></span><br><span class="line">- coroutine waitForResponse(): 等待回应</span><br><span class="line"></span><br><span class="line">- waitForSelector(): 等到页面上出现匹配的元素。其实 waitFor()也有同样功能。</span><br><span class="line"></span><br><span class="line">- waitForFunction(): 等到函数完成并返回一个值</span><br><span class="line"></span><br><span class="line">- coroutine waitForXPath(): 等到 xpath 页面上出现匹配的元素</span><br><span class="line"></span><br><span class="line">- workers: 获取页面的所有 worker。至于是什么，我不知道</span><br><span class="line"></span><br><span class="line">- coroutine xpath(): ..</span><br><span class="line"></span><br><span class="line">## worker 类</span><br><span class="line"></span><br><span class="line">page.on(&#39;workercreated&#39;, 函数) 这个函数传入的参数就是 worker 类</span><br><span class="line"></span><br><span class="line">- coroutine evaluate(): 同上</span><br><span class="line">- coroutine evaluateHandle():同上</span><br><span class="line">- coroutine executionContext():同上</span><br><span class="line">- url: 同上</span><br><span class="line"></span><br><span class="line">## 键盘类</span><br><span class="line"></span><br><span class="line">- coroutine down(): 如果没有参数，则是按下鼠标左键。如果是键盘的某个值比如 shift、A 等键，则是相当于按下这些键。</span><br><span class="line">- coroutine press(): 同 down()，但是上面是不会释放鼠标或者键盘，需要调用 up 方法释放鼠标。</span><br><span class="line">- coroutine sendCharacter：将字符发送到页面。没用过</span><br><span class="line">- coroutine type(): 同上</span><br><span class="line">- coroutine up(): 释放由 down 按下的键或者鼠标</span><br><span class="line"></span><br><span class="line">## 鼠标类</span><br><span class="line"></span><br><span class="line">- coroutine click(): 按下(x, y)处的按钮</span><br><span class="line">   参数：</span><br><span class="line">  - &#96;button&#96;（STR）： ，left（左键）、right（右键）或 middle（中键），默认为 &#96;left&#96;。</span><br><span class="line">  - &#96;clickCount&#96; （int）：默认为 1。</span><br><span class="line">  - &#96;delay&#96;（int | float）：等待时间 &#96;mousedown&#96; 和 &#96;mouseup&#96; 以毫秒为单位的时间。默认为 0。</span><br><span class="line">- coroutine down(): 同上</span><br><span class="line">- coroutine move(): 移动鼠标光标。</span><br><span class="line">- coroutine up()： 同上</span><br><span class="line"></span><br><span class="line">## tracing 类</span><br><span class="line"></span><br><span class="line">创建可在 Chrome DevTools 或时间线查看器打开的跟踪文件 ，使用如下</span><br></pre></td></tr></table></figure></code></pre><p>await page.tracing.start({‘path’: ‘trace.json’})</p>
<p>await page.goto(‘<a href="https://www.google.com&#39;" target="_blank" rel="noopener">https://www.google.com&#39;</a>)</p>
<p>await page.tracing.stop()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- coroutine start(): 开始跟踪</span><br><span class="line">- coroutine stop(): 停止跟踪</span><br><span class="line"></span><br><span class="line">不好用，可能是我不知道用</span><br><span class="line"></span><br><span class="line">## Dialog 类</span><br><span class="line"></span><br><span class="line">&#96;page.on( &#39;dialog&#39;, 函数)&#96;，函数的参数就是这个类</span><br><span class="line"></span><br><span class="line">- coroutine accept(): 接受对话框</span><br><span class="line">- defaultValue： 如果对话框提示，则获取默认提示值</span><br><span class="line">- coroutine dismiss(): 关闭对话框</span><br><span class="line">- message: 获取对话框消息</span><br><span class="line">- type： 获取对话框类型。类型有：&#96;alert&#96;，&#96;beforeunload&#96;，&#96;confirm&#96;，或 &#96;prompt&#96;</span><br><span class="line"></span><br><span class="line">## frame 类</span><br><span class="line"></span><br><span class="line">- coroutine J():同上</span><br><span class="line">- coroutine JJ():同上</span><br><span class="line">- coroutine JJeval(): 同上</span><br><span class="line">- coroutine Jeval(): 同上</span><br><span class="line">- coroutine Jx(): 同上</span><br><span class="line">- coroutine addScriptTag(): 同上</span><br><span class="line">- coroutine addStyleTag(): 同上</span><br><span class="line">- childFrames: 获取子框架</span><br><span class="line">- coroutine click(): 同上</span><br><span class="line">- coroutine content(): 同上</span><br><span class="line">- coroutine evaluate(): 同上</span><br><span class="line">- coroutine evaluateHandle(): 同上</span><br><span class="line">- coroutine executionContext(): 同上</span><br><span class="line">- coroutine focus(): 同上</span><br><span class="line">- coroutine hover(): 同上</span><br><span class="line">- isDetached()： 如果此框架已分离，则返回 True</span><br><span class="line">- name：获取 frame 的名称，如果没有则返回 ID</span><br><span class="line">- parentFrame：获取父框架</span><br><span class="line">   后面这些属性和 page 类一模一样</span><br><span class="line"></span><br><span class="line">## ElementHandle 类</span><br><span class="line"></span><br><span class="line">- coroutine J()</span><br><span class="line">- coroutine JJ()</span><br><span class="line">- coroutine JJeval()</span><br><span class="line">- coroutine Jeval()</span><br><span class="line">- asElement</span><br><span class="line">- coroutine boundingBox(): 返回此元素的边界框,如果元素不可见，则返回 None</span><br><span class="line">- coroutine boxModel():返回元素框</span><br><span class="line">- coroutine click()</span><br><span class="line">- coroutine contentFrame(): 返回元素句柄的 frame</span><br><span class="line">- coroutine focus()</span><br><span class="line">- coroutine hover()</span><br><span class="line">- coroutine isIntersectingViewport(): 如果元素在视口中可见，则返回 True</span><br><span class="line">- coroutine press()</span><br><span class="line">- coroutine screenshot()</span><br><span class="line">- coroutine tap()</span><br><span class="line">- coroutine type()</span><br><span class="line">- coroutine uploadFile(): 上传文件</span><br><span class="line"></span><br><span class="line">## request 类</span><br><span class="line"></span><br><span class="line">page.on(&#39;request&#39;, 函数) 这个函数传入的参数就是 request 类</span><br><span class="line"></span><br><span class="line">- coroutine abort(): 中断请求</span><br><span class="line"></span><br><span class="line">- coroutine continue_(): 使用可选的请求覆盖继续请求</span><br><span class="line"></span><br><span class="line">   参数：   </span><br><span class="line"></span><br><span class="line">  - &#96;url&#96; （str）：如果设置，请求 URL 将被更改。</span><br><span class="line">  - &#96;method&#96;（str）：如果设置，则更改请求方法（例如 &#96;GET&#96;）。</span><br><span class="line">  - &#96;postData&#96; （str）：如果设置，则更改发布数据或请求。</span><br><span class="line">  - &#96;headers&#96; （dict）：如果设置，则更改请求 HTTP 标头</span><br><span class="line"></span><br><span class="line">- failure(): 返回错误文本</span><br><span class="line"></span><br><span class="line">- frame : 返回匹配的 frame 对象</span><br><span class="line"></span><br><span class="line">- headers: 返回此请求的 HTTP 标头字典</span><br><span class="line"></span><br><span class="line">- isNavigationRequest(): ？？</span><br><span class="line"></span><br><span class="line">- method：返回此请求的方法</span><br><span class="line"></span><br><span class="line">- postData： 返回此请求的帖子正文</span><br><span class="line"></span><br><span class="line">- redirectChain： request 类重定向的所有请求</span><br><span class="line"></span><br><span class="line">- resourceType：渲染引擎感知的此请求的资源类型</span><br><span class="line"></span><br><span class="line">- coroutine respond(): 通过给定的参数修改请求</span><br><span class="line"></span><br><span class="line">   参数：   </span><br><span class="line"></span><br><span class="line">  - &#96;status&#96; （int）：响应状态代码，默认为 200。</span><br><span class="line">  - &#96;headers&#96; （dict）：可选的响应头。</span><br><span class="line">  - &#96;contentType&#96;（str）：如果设置，则等于设置 &#96;Content-Type&#96; 响应头。</span><br><span class="line">  - &#96;body&#96; （str | bytes）：可选的响应主体。</span><br><span class="line"></span><br><span class="line">- response(): 返回匹配的 response 对象</span><br><span class="line"></span><br><span class="line">- url： 此请求的 URL</span><br><span class="line"></span><br><span class="line">## response 类</span><br><span class="line"></span><br><span class="line">- buffer(): 返回相应的字节内容</span><br><span class="line">- fromCache： 如果响应是从缓存提供的，则返回 True。缓存可能是浏览器的磁盘缓存或者内存，而不是服务器响应的</span><br><span class="line">- fromServiceWorker： 如果响应由服务器提供，则返回 True</span><br><span class="line">- headers： 返回此响应的 HTTP 标头字典</span><br><span class="line">- coroutine json(): 获取响应正文的 JSON</span><br><span class="line">- ok： 返回 bool 此请求是否成功</span><br><span class="line">- request： 获取匹配的 request 对象</span><br><span class="line">- securityDetails： 返回与此响应关联的安全详细信息</span><br><span class="line">- status： 响应的状态代码</span><br><span class="line">- coroutine text(): 获取响应正文的文本</span><br><span class="line">- url : 响应的 URL</span><br><span class="line"></span><br><span class="line">## target 类</span><br><span class="line"></span><br><span class="line">我到现在还没明白这是干什么的</span><br><span class="line"></span><br><span class="line">- browser： 获取目标所属的浏览器</span><br><span class="line">- browserContext： 返回目标所属的浏览器上下文</span><br><span class="line">- coroutine createCDPSession(): 创建附加到目标的 Chrome Devtools 协议会话</span><br><span class="line">- opener: 获取打开此目标的目标</span><br><span class="line">- coroutine page(): 获取此目标的页面</span><br><span class="line">- type: 获取此目标的类型</span><br><span class="line">- url: 获取此目标的网址</span><br><span class="line"></span><br><span class="line">## CDPSession 类</span><br><span class="line"></span><br><span class="line">- coroutine detach(): 从目标分离会话</span><br><span class="line">- send() :</span><br><span class="line"></span><br><span class="line">## Debugging</span><br><span class="line"></span><br><span class="line">对于调试，您可以设置 for 和 功能 &#96;logLevel&#96; 选项。但是，此选项会打印太多日志，包括 pyppeteer 的 SEND &#x2F; RECV 消息。为了只显示被抑制的错误消息，您应该设置 logging.DEBUG 为 True</span><br></pre></td></tr></table></figure>
<p>import asyncio<br>import pyppeteer<br>from pyppeteer import launch</p>
<p>pyppeteer.DEBUG = True  # print suppressed errors as error log</p>
<p>async def main():</p>
<pre><code>browser = await launch()

...  # do something</code></pre><p>asyncio.get_event_loop().run_until_complete(main())</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 实践</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">import asyncio</span><br><span class="line">from asyncio.tasks import wait</span><br><span class="line">from logging import lastResort</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pyquery import PyQuery as pq</span><br><span class="line"></span><br><span class="line"># 第一步 去除浏览器自动化参数</span><br><span class="line"># 必须在 from pyppeteer import launch 前去除参数</span><br><span class="line"># 去除自动化 启动参数</span><br><span class="line"># from pyppeteer import launcher</span><br><span class="line"># launcher.AUTOMATION_ARGS.remove(&quot;--enable-automation&quot;)</span><br><span class="line">from pyppeteer import launch</span><br><span class="line"></span><br><span class="line">browser &#x3D; None</span><br><span class="line">launch_kwargs &#x3D; &#123;</span><br><span class="line">    # 控制是否为无头模式</span><br><span class="line">    &quot;headless&quot;: False,</span><br><span class="line">    # chrome启动命令行参数</span><br><span class="line">    &quot;args&quot;: [</span><br><span class="line">        # 浏览器代理 配合某些中间人代理使用</span><br><span class="line">        # &quot;--proxy-server&#x3D;http:&#x2F;&#x2F;127.0.0.1:8008&quot;,</span><br><span class="line">        # 最大化窗口</span><br><span class="line">        &quot;--start-maximized&quot;,</span><br><span class="line">        # 取消沙盒模式 沙盒模式下权限太小</span><br><span class="line">        &quot;--no-sandbox&quot;,</span><br><span class="line">        # 不显示信息栏  比如 chrome正在受到自动测试软件的控制 ...</span><br><span class="line">        &quot;--disable-infobars&quot;,</span><br><span class="line">        # log等级设置 在某些不是那么完整的系统里 如果使用默认的日志等级 可能会出现一大堆的warning信息</span><br><span class="line">        &quot;--log-level&#x3D;3&quot;,</span><br><span class="line">        # 设置UA</span><br><span class="line">        &quot;--user-agent&#x3D;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;,</span><br><span class="line">    ],</span><br><span class="line">    &quot;dumpio&quot;: True,</span><br><span class="line">    # 当界面开多了时会卡住，设置这个参数就不会了</span><br><span class="line">    # 用户数据保存目录 这个最好也自己指定一个目录</span><br><span class="line">    # 如果不指定的话，chrome会自动新建一个临时目录使用，在浏览器退出的时候会自动删除临时目录</span><br><span class="line">    # 在删除的时候可能会删除失败（不知道为什么会出现权限问题，我用的windows） 导致浏览器退出失败</span><br><span class="line">    # 然后chrome进程就会一直没有退出 CPU就会狂飙到99%</span><br><span class="line">    &quot;userDataDir&quot;: &quot;.&#x2F;userdata&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def screen_size():</span><br><span class="line">    &quot;&quot;&quot;使用tkinter获取屏幕大小&quot;&quot;&quot;</span><br><span class="line">    import tkinter</span><br><span class="line"></span><br><span class="line">    tk &#x3D; tkinter.Tk()</span><br><span class="line">    width &#x3D; tk.winfo_screenwidth()</span><br><span class="line">    height &#x3D; tk.winfo_screenheight()</span><br><span class="line">    tk.quit()</span><br><span class="line">    return width, height</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    global browser</span><br><span class="line">    if browser is None:</span><br><span class="line">        browser &#x3D; await launch(launch_kwargs)</span><br><span class="line"></span><br><span class="line">    page &#x3D; await browser.newPage()</span><br><span class="line">    width, height &#x3D; screen_size()</span><br><span class="line">    # 设置网页可视区域大小</span><br><span class="line">    # await page.setViewport(&#123;</span><br><span class="line">    #     &quot;width&quot;: width,</span><br><span class="line">    #     &quot;height&quot;: height</span><br><span class="line">    # &#125;)</span><br><span class="line">    # 第二步，修改 navigator.webdriver检测</span><br><span class="line">    # 其实各种网站的检测js是不一样的，这是比较通用的。有的网站会检测运行的电脑运行系统，cpu核心数量，鼠标运行轨迹等等。</span><br><span class="line">    # 反爬js</span><br><span class="line">    # 隐藏浏览器驱动信息，防检测</span><br><span class="line">    await page.evaluateOnNewDocument(</span><br><span class="line">        &quot;Object.defineProperty(&quot; &#39;navigator, &quot;webdriver&quot;, &#123;get: () &#x3D;&gt; undefined&#125;)&#39;</span><br><span class="line">    )</span><br><span class="line">    js_text &#x3D; &quot;&quot;&quot;</span><br><span class="line">() &#x3D;&gt;&#123; </span><br><span class="line">    Object.defineProperties(navigator,&#123; webdriver:&#123; get: () &#x3D;&gt; false &#125; &#125;);</span><br><span class="line">    window.navigator.chrome &#x3D; &#123; runtime: &#123;&#125;,  &#125;;</span><br><span class="line">    Object.defineProperty(navigator, &#39;languages&#39;, &#123; get: () &#x3D;&gt; [&#39;en-US&#39;, &#39;en&#39;] &#125;);</span><br><span class="line">    Object.defineProperty(navigator, &#39;plugins&#39;, &#123; get: () &#x3D;&gt; [1, 2, 3, 4, 5,6], &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    await page.evaluateOnNewDocument(js_text)  # 本页刷新后值不变，自动执行js</span><br><span class="line"></span><br><span class="line">    await page.setUserAgent(</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.67 Safari&#x2F;537.36&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    await page.goto(&quot;http:&#x2F;&#x2F;sxdxjwc.ctgu.edu.cn&#x2F;index.jsp&quot;)</span><br><span class="line"></span><br><span class="line">    await page.screenshot(path&#x3D;&quot;example.png&quot;, quality&#x3D;100, fullPage&#x3D;True)</span><br><span class="line">    latest_notice &#x3D; await page.querySelector(&quot;div.jwtz_nr &gt; ul &gt; ul &gt; li:nth-child(1)&quot;)</span><br><span class="line">    url &#x3D; await (await latest_notice.getProperty(&quot;href&quot;)).jsonValue()</span><br><span class="line">    print(str(url))</span><br><span class="line">    print(page.url)</span><br><span class="line">    title &#x3D; await page.evaluate(&quot;(element) &#x3D;&gt; element.textContent&quot;, latest_notice)</span><br><span class="line">    print(title)</span><br><span class="line">    url &#x3D; await page.evaluate(&quot;(element) &#x3D;&gt; element.URL&quot;, latest_notice)</span><br><span class="line">    print(&quot;获取的链接&quot;, url)</span><br><span class="line">    await page.click(</span><br><span class="line">        &quot;body &gt; div.width &gt; div.maina &gt; div.jwtz &gt; div.jwtz_nr &gt; ul &gt; ul &gt; li:nth-child(1)&quot;</span><br><span class="line">    )</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    # await page.waitForNavigation(timeout&#x3D;0)</span><br><span class="line">    # await asyncio.wait(</span><br><span class="line">    #     [</span><br><span class="line">    #         page.click(</span><br><span class="line">    #             &quot;body &gt; div.width &gt; div.maina &gt; div.jwtz &gt; div.jwtz_nr &gt; ul &gt; ul &gt; li:nth-child(1)&quot;</span><br><span class="line">    #         ),</span><br><span class="line">    #         page.waitForNavigation(&#123;&quot;timeout&quot;: 0&#125;),</span><br><span class="line">    #     ]</span><br><span class="line">    # )</span><br><span class="line"></span><br><span class="line">    pages &#x3D; await browser.pages()</span><br><span class="line">    print(&quot;所有的页面&quot;, pages)</span><br><span class="line">    for p in pages:</span><br><span class="line">        print(p.title,p.url)</span><br><span class="line">    # pages[0].close()</span><br><span class="line">    # await page.click(</span><br><span class="line">    #     &quot;body &gt; div.width &gt; div.maina &gt; div.jwtz &gt; div.jwtz_nr &gt; ul &gt; ul &gt; li:nth-child(1)&quot;</span><br><span class="line">    # )</span><br><span class="line">    # await page.waitFor(1)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    # page.mouse  # 模拟真实点击</span><br><span class="line">    # time.sleep(10)</span><br><span class="line">    # page.bringToFront()</span><br><span class="line">    cookies &#x3D; await page.cookies()</span><br><span class="line">    print(cookies)</span><br><span class="line">    # 然后导入cookie</span><br><span class="line">    # await page.setCookie(*cookies)</span><br><span class="line">    # browser.retainLastPage()</span><br><span class="line">    # 前进</span><br><span class="line">    # await page.goForward()</span><br><span class="line">    # page&#x3D;pages[1]</span><br><span class="line">    await pages[-1].screenshot(path&#x3D;&quot;news.png&quot;, quality&#x3D;100, fullPage&#x3D;True)</span><br><span class="line">    # await page.waitFor(2)  # 停顿</span><br><span class="line">    await browser.close()</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>



<blockquote>
<p>转自：<a href="https://ld246.com/article/1566221786951" target="_blank" rel="noopener">https://ld246.com/article/1566221786951</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>分区扩容</title>
    <url>//post/undefined.html</url>
    <content><![CDATA[<p>1、分区的挂载</p><p><a href="https://blog.csdn.net/qq_14824885/article/details/82664635" target="_blank" rel="noopener">https://blog.csdn.net/qq_14824885/article/details/82664635</a></p><a id="more"></a>

<p>2、增加swap分区</p>
<p><a href="https://blog.csdn.net/weixin_43532644/article/details/106762314" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43532644/article/details/106762314</a></p>
<p>3、gparted图形化分区工具的使用</p>
<p><a href="https://blog.csdn.net/superxlcr/article/details/78822770" target="_blank" rel="noopener">https://blog.csdn.net/superxlcr/article/details/78822770</a></p>
<p><a href="https://blog.csdn.net/wang328452854/article/details/51036724" target="_blank" rel="noopener">https://blog.csdn.net/wang328452854/article/details/51036724</a></p>
<p>使用文件和磁盘作为swap分区</p>
<p><a href="https://www.cnblogs.com/wuxie1989/p/5888595.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuxie1989/p/5888595.html</a></p>
<p>4、常用命令</p>
<p> free -h查看剩余内存和交互分区</p>
<p>fdisk -l 获取分区列表</p>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的解决Typora的图片上传问题</title>
    <url>//post/38968.html</url>
    <content><![CDATA[<p>1、本地相对路径</p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/08/26/49722b78124638e97c62f309629c8416.png" alt="image-20200826144350474"></p><p>2、PicGo上传</p><p><a href="https://blog.csdn.net/qq_42573684/article/details/105414197" target="_blank" rel="noopener">https://blog.csdn.net/qq_42573684/article/details/105414197</a></p><a id="more"></a>



<p>PicGo使用</p>
<p><a href="https://blog.csdn.net/weixin_45701789/article/details/107427487" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45701789/article/details/107427487</a></p>
<p>解决上传的稳定性</p>
<p><a href="https://wblog.tech/hexo-picgoup.html" target="_blank" rel="noopener">https://wblog.tech/hexo-picgoup.html</a></p>
<p>自己在原基础上做了一些改进</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yumusb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-03-27 14:45:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@LastEditors</span>: yumusb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@LastEditTime</span>: 2020-03-27 14:45:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">URL https://github.com/yumusb/autoPicCdn</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">header(<span class="string">'Content-Type: text/html; charset=UTF-8'</span>);</span><br><span class="line">date_default_timezone_set(<span class="string">"PRC"</span>);</span><br><span class="line">define(<span class="string">"REPO"</span>,<span class="string">"repo"</span>);<span class="comment">//必须是下面用户名下的公开仓库</span></span><br><span class="line">define(<span class="string">"USER"</span>,<span class="string">"user"</span>);<span class="comment">//必须是当前GitHub用户名</span></span><br><span class="line">define(<span class="string">"MAIL"</span>,<span class="string">"mail"</span>);<span class="comment">//</span></span><br><span class="line">define(<span class="string">"TOKEN"</span>,<span class="string">"5d031c61e77557cbef6068d9214d75b3"</span>);<span class="comment">//https://github.com/settings/tokens 去这个页面生成一个有写权限的token（write:packages前打勾）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span><span class="params">($url, $content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    $defaultOptions=[</span><br><span class="line">        CURLOPT_URL =&gt; $url,</span><br><span class="line">        CURLOPT_FOLLOWLOCATION =&gt; <span class="keyword">true</span>,</span><br><span class="line">        CURLOPT_RETURNTRANSFER =&gt; <span class="keyword">true</span>,</span><br><span class="line">        CURLOPT_CUSTOMREQUEST=&gt;<span class="string">"PUT"</span>,</span><br><span class="line">        CURLOPT_POSTFIELDS=&gt;json_encode([</span><br><span class="line">            <span class="string">"message"</span>=&gt; date(<span class="string">"Y-m-d H:i:s "</span>),</span><br><span class="line">            <span class="string">"committer"</span>=&gt; [</span><br><span class="line">                <span class="string">"name"</span>=&gt; USER,</span><br><span class="line">                <span class="string">"email"</span>=&gt;MAIL,</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"content"</span>=&gt; $content,</span><br><span class="line">        ]),</span><br><span class="line">        CURLOPT_HTTPHEADER =&gt; [</span><br><span class="line">            <span class="string">"Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>,</span><br><span class="line">            <span class="string">"Accept-Language:zh-CN,en-US;q=0.7,en;q=0.3"</span>,</span><br><span class="line">            <span class="string">"User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36"</span>,</span><br><span class="line">            <span class="string">'Authorization:token '</span>.TOKEN,</span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">    curl_setopt_array($ch, $defaultOptions);</span><br><span class="line">    $chContents = curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">    <span class="keyword">return</span> $chContents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span> &amp;&amp; $_FILES[<span class="string">"pic"</span>][<span class="string">"error"</span>] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    $filename = <span class="string">'images'</span> . <span class="string">'/'</span> . date(<span class="string">'Y'</span>) . <span class="string">'/'</span> . date(<span class="string">'m'</span>) . <span class="string">'/'</span> . date(<span class="string">'d'</span>) . <span class="string">'/'</span> . md5(time()) . <span class="string">".png"</span>;</span><br><span class="line">    $url = <span class="string">"https://api.github.com/repos/"</span> . USER . <span class="string">"/"</span> . REPO . <span class="string">"/contents/"</span> . $filename;</span><br><span class="line">    $tmpName = <span class="string">'./tmp'</span> . md5($filename);</span><br><span class="line">    move_uploaded_file($_FILES[<span class="string">'pic'</span>][<span class="string">'tmp_name'</span>], $tmpName);</span><br><span class="line">    $content = base64_encode(file_get_contents($tmpName));</span><br><span class="line">    $res = json_decode(upload($url, $content), <span class="keyword">true</span>);</span><br><span class="line">    unlink($tmpName);</span><br><span class="line">    <span class="keyword">if</span> ($res[<span class="string">'content'</span>][<span class="string">'path'</span>] != <span class="string">""</span>) &#123;</span><br><span class="line">        $return[<span class="string">'code'</span>] = <span class="string">'success'</span>;</span><br><span class="line">        $return[<span class="string">'data'</span>][<span class="string">'filename'</span>] = $filename;</span><br><span class="line">        $return[<span class="string">'data'</span>][<span class="string">'url'</span>] = <span class="string">'https://cdn.jsdelivr.net/gh/'</span> . USER . <span class="string">'/'</span> . REPO . <span class="string">'/'</span> . $res[<span class="string">'content'</span>][<span class="string">'path'</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $return[<span class="string">'code'</span>] = <span class="number">500</span>;</span><br><span class="line">        $return[<span class="string">'url'</span>] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $return[<span class="string">'code'</span>] = <span class="number">404</span>;</span><br><span class="line">    $return[<span class="string">'url'</span>] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">exit</span>(json_encode($return));</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>加密解密</title>
    <url>//post/49371.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pycrypto-2.6.1-cp36-cp36m-win_amd64.whl</span><br><span class="line">可能的报错</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jinpingzhao&#x2F;p&#x2F;12492878.html</span><br><span class="line">pip install pycryptodome</span><br><span class="line">pyinstaller -F -i key.ico --key 123456789 qq.py</span><br></pre></td></tr></table></figure><a id="more"></a>

<p><a href="https://blog.csdn.net/HW140701/article/details/93494869" target="_blank" rel="noopener">https://blog.csdn.net/HW140701/article/details/93494869</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出现如下警告，说明同时安装了</span><br><span class="line">pycrypto 与 pycryptodome</span><br><span class="line"></span><br><span class="line">[22048] WARNING: file already exists but </span><br><span class="line">should not: C:\Users\DEFAUL~3\AppData\Local\Temp\_MEI220482\Crypto\Cipher\_AES.cp37-win_amd64.pyd</span><br><span class="line"></span><br><span class="line">解决办法</span><br><span class="line">进入</span><br><span class="line">D:\Program Files\Python37\Lib\site-packages\Crypto\Cipher</span><br><span class="line">复制_raw_cfb.cp37-win_amd64.pyd做备份</span><br><span class="line">然后pip uninstall pycryptodome</span><br></pre></td></tr></table></figure>

<h1 id="打包pyd文件"><a href="#打包pyd文件" class="headerlink" title="打包pyd文件"></a>打包pyd文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install  cython</span><br><span class="line"></span><br><span class="line">pip install pyinstaller</span><br><span class="line"></span><br><span class="line">建立build_pyd.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">'Anything you want'</span>,</span><br><span class="line">    ext_modules=cythonize([<span class="string">"course.py"</span></span><br><span class="line">                            ], language_level=<span class="number">3</span></span><br><span class="line">        ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python build_pyd.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<h1 id="安装Visual-C-Build-Tools-2015"><a href="#安装Visual-C-Build-Tools-2015" class="headerlink" title="安装Visual C++ Build Tools 2015"></a>安装<a href="http://go.microsoft.com/fwlink/?LinkId=691126" target="_blank" rel="noopener">Visual C++ Build Tools 2015</a></h1><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> set PATH=%path%;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\;C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\amd64\</span><br><span class="line">set include=C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include\;C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt;C:\Program Files (x86)\Windows Kits\8.1\Include\shared\</span><br><span class="line">set lib=C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\lib\amd64\;C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.10240.0\ucrt\x64\</span><br></pre></td></tr></table></figure>

<h1 id="反编译pyc"><a href="#反编译pyc" class="headerlink" title="反编译pyc"></a>反编译pyc</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install uncompyle</span><br><span class="line">uncompyle6 搜索引擎.pyc &gt; 搜索引擎.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反编译：<a href="https://blog.csdn.net/qq_44198436/article/details/97314626" target="_blank" rel="noopener">https://blog.csdn.net/qq_44198436/article/details/97314626</a></p>
<p>pyd：<a href="https://blog.csdn.net/fangkailove/article/details/104965270" target="_blank" rel="noopener">https://blog.csdn.net/fangkailove/article/details/104965270</a></p>
<p>pyd引导：<a href="https://www.lizenghai.com/archives/898.html#pyd" target="_blank" rel="noopener">https://www.lizenghai.com/archives/898.html#pyd</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移</title>
    <url>//post/53348.html</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.19042 win32 x64</span><br><span class="line">node: 13.14.0</span><br><span class="line">v8: 7.9.317.25-node.32</span><br><span class="line">uv: 1.37.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.16.0</span><br><span class="line">modules: 79</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 6</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 36.1</span><br><span class="line">icu: 66.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>node 下载：<a href="https://nodejs.org/download/release/v13.14.0/node-v13.14.0-x64.msi" target="_blank" rel="noopener">https://nodejs.org/download/release/v13.14.0/node-v13.14.0-x64.msi</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据</title>
    <url>//post/5394.html</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任务描述</span><br><span class="line">相关知识</span><br><span class="line">如何使用happpybase连接HBase数据库</span><br><span class="line">编程要求</span><br><span class="line">好了，到你啦，使用本关知识，在右侧命令行完成下面的任务要求：</span><br><span class="line">任务描述</span><br><span class="line">本关任务：使用python代码在HBase中创建表。</span><br><span class="line"></span><br><span class="line">相关知识</span><br><span class="line">为了完成本关任务，你需要掌握：<span class="number">1.</span>如何使用happybase 连接HBase数据库，<span class="number">2.</span>如何使用python代码在HBase中创建表。</span><br><span class="line"></span><br><span class="line">如何使用happpybase连接HBase数据库</span><br><span class="line">一、连接(happybase.Connection)</span><br><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line">happybase.Connection(host=’localhost’, port=<span class="number">9090</span>, timeout=<span class="literal">None</span>, autoconnect=<span class="literal">True</span>, table_prefix=<span class="literal">None</span>, table_prefix_separator=b’_’, compat=’<span class="number">0.98</span>’, transport=’buffered’, protocol=’binary’)</span><br><span class="line">获取连接实例</span><br><span class="line">host：主机名</span><br><span class="line">port：端口</span><br><span class="line">timeout：超时时间</span><br><span class="line">autoconnect：连接是否直接打开</span><br><span class="line">table_prefix：用于构造表名的前缀</span><br><span class="line">table_prefix_separator：用于table_prefix的分隔符</span><br><span class="line">compat：兼容模式</span><br><span class="line">transport：运输模式</span><br><span class="line">protocol：协议</span><br><span class="line">例：</span><br><span class="line">connection = happybase.Connection(host=”<span class="number">192.168</span><span class="number">.0</span><span class="number">.156</span>”,port=<span class="number">9090</span>,timeout=<span class="literal">None</span>,autoconnect=<span class="literal">True</span>,table_prefix=<span class="literal">None</span>,table_prefix_separator=b’_’,compat=’<span class="number">0.98</span>’, transport=’buffered’,protocol=’binary’)</span><br><span class="line"></span><br><span class="line">当connection被创建的时候，默认自动与Hbase建立socket连接的。</span><br><span class="line">若不想自动与Hbase建立socket连接，可以将autoconnect参数设置为<span class="literal">False</span></span><br><span class="line">connection = happybase.Connection(‘<span class="number">10.1</span><span class="number">.13</span><span class="number">.111</span>’, autoconnect=<span class="literal">False</span>)</span><br><span class="line">然后手动与Hbase建立socket连接</span><br><span class="line">connection.open()</span><br><span class="line">open()：打开传输，无返回值</span><br><span class="line">close()：关闭传输，无返回值</span><br><span class="line">connection.close()</span><br><span class="line">连接建立好之后查看可以使用的table</span><br><span class="line"><span class="keyword">print</span> connection.tables()</span><br><span class="line">因为还没有创建table，所以返回结果是 []</span><br><span class="line"></span><br><span class="line"> 二、创建一个table</span><br><span class="line">create_table(name,families)：创建表，无返回值 </span><br><span class="line">name：表名</span><br><span class="line">families：列族</span><br><span class="line">families = &#123; “cf”:dict(), “df”:dict()&#125;</span><br><span class="line">connection.create_table(name,families)</span><br><span class="line"> 如果连接时，有传递表前缀参数时，真实表名将会是：”&#123;&#125;_&#123;&#125;”.format(table_prefix,name)</span><br><span class="line"></span><br><span class="line">connection.create_table(</span><br><span class="line">    ‘my_table’,</span><br><span class="line">    &#123;</span><br><span class="line">        ‘cf1’: dict(max_versions=<span class="number">10</span>),</span><br><span class="line">        ‘cf2’:dict(max_versions=<span class="number">1</span>,block_cache_enabled=<span class="literal">False</span>),</span><br><span class="line">        ‘cf3’: dict(),  <span class="comment"># use defaults</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">此时，我们再通过connection.tables()查看可以使用的table，结果为[‘my_table’]</span><br><span class="line">创建的table即my_table包含<span class="number">3</span>个列族：cf1、cf2、cf3</span><br><span class="line"></span><br><span class="line">编程要求</span><br><span class="line">好了，到你啦，使用本关知识，在右侧命令行完成下面的任务要求：</span><br><span class="line"><span class="number">1</span>执行环节搭建脚本，为使用Python语言操作hbase做好准备。</span><br><span class="line">cd /data/workspace/myshixun/opt/</span><br><span class="line">chmod +x setup-env.sh</span><br><span class="line">./setup-env.sh</span><br><span class="line">这里可能需要等待几分钟，让脚本执行完，thrift和happybase就安装好了。</span><br><span class="line">接下来可以查看各个服务进程是否启动</span><br><span class="line">jps</span><br><span class="line">‘’</span><br><span class="line">root@evassh<span class="number">-2932225</span>:~<span class="comment"># jps</span></span><br><span class="line"><span class="number">1808</span> ResourceManager</span><br><span class="line"><span class="number">4785</span> Jps</span><br><span class="line"><span class="number">2820</span> ThriftServer</span><br><span class="line"><span class="number">1317</span> NameNode</span><br><span class="line"><span class="number">2694</span> HRegionServer</span><br><span class="line"><span class="number">1447</span> DataNode</span><br><span class="line"><span class="number">2506</span> HQuorumPeer</span><br><span class="line"><span class="number">1626</span> SecondaryNameNode</span><br><span class="line"><span class="number">2570</span> HMaster</span><br><span class="line">‘’</span><br><span class="line">如果启动过程中出现：</span><br><span class="line">localhost: zookeeper running <span class="keyword">as</span> process <span class="number">2474.</span> Stop it first. master running <span class="keyword">as</span> process <span class="number">2538.</span> Stop it first. : regionserver running <span class="keyword">as</span> process <span class="number">2665.</span> Stop it first. thrift running <span class="keyword">as</span> process <span class="number">2789.</span> Stop it first.</span><br><span class="line"></span><br><span class="line">需要我们重新</span><br><span class="line">/app/hbase<span class="number">-2.1</span><span class="number">.1</span>/binhbase-daemon.sh stop thrift stop-dfs.sh 和stop-hbase.sh，然后再重启。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 进入Python编译器完成连接和创建表</span><br><span class="line">python3</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 建立一个本地连接对象conn，使用本机和默认端口建立连接</span><br><span class="line"><span class="number">4</span> 创建一个名为student1的表，有两个列族：info和scores</span><br><span class="line">注意：列族定义之间的逗号后要空一格，否则会出错。</span><br><span class="line"><span class="number">5</span> 可以使用conn.tables()查看表是否创建好。</span><br><span class="line">如果出现‘BrokenPipeError: [Errno <span class="number">32</span>] Broken pipe’提示，说明连接已经自动关闭，每次连接如果超过<span class="number">60</span>秒没有操作，就会自动关闭，需要重新建立连接。</span><br><span class="line"><span class="number">6</span> 退出Python编译器</span><br><span class="line"></span><br><span class="line">开始你的任务吧，祝你成功！</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任务描述</span><br><span class="line">相关知识</span><br><span class="line">任务描述</span><br><span class="line">本关任务：使用python代码向HBase表中并添加、删除数据，并查看数据。</span><br><span class="line"></span><br><span class="line">相关知识</span><br><span class="line">一、添加数据</span><br><span class="line"></span><br><span class="line">要对一个表添加数据，我们需要一个table对象，使用table.put()方法添加数据：</span><br><span class="line"></span><br><span class="line">在上一关的例子中，我们创建了my_table表包含<span class="number">3</span>个列族：cf1、cf2、cf3，现在我们往里面写入数据。你可以试试先自己创建这个my_table表。</span><br><span class="line"></span><br><span class="line">table = connection.table(‘my_table’)       <span class="comment">#首先获得表对象</span></span><br><span class="line"></span><br><span class="line">Hbase里 存储的数据都是原始的字节字符串</span><br><span class="line"></span><br><span class="line">cloth_data = &#123;<span class="string">'cf1:content'</span>: <span class="string">'jeans'</span>, <span class="string">'cf1:price'</span>: <span class="string">'299'</span>, <span class="string">'cf1:rating'</span>: <span class="string">'98%'</span>&#125;</span><br><span class="line">hat_data = &#123;<span class="string">'cf1:content'</span>: <span class="string">'cap'</span>, <span class="string">'cf1:price'</span>: <span class="string">'88'</span>, <span class="string">'cf1:rating'</span>: <span class="string">'99%'</span>&#125;</span><br><span class="line">shoe_data = &#123;<span class="string">'cf1:content'</span>: <span class="string">'jacket'</span>, <span class="string">'cf1:price'</span>: <span class="string">'988'</span>, <span class="string">'cf1:rating'</span>: <span class="string">'100%'</span>&#125;</span><br><span class="line">author_data = &#123;<span class="string">'cf2:name'</span>: <span class="string">'LiuLin'</span>, <span class="string">'cf2:date'</span>: <span class="string">'2017-03-09'</span>&#125;</span><br><span class="line">table.put(row=<span class="string">'www.test1.com'</span>, data=cloth_data)</span><br><span class="line">table.put(row=<span class="string">'www.test2.com'</span>, data=hat_data)</span><br><span class="line">table.put(row=<span class="string">'www.test3.com'</span>, data=shoe_data)</span><br><span class="line">table.put(row=<span class="string">'www.test4.com'</span>, data=author_data)</span><br><span class="line">使用put一次只能存储一行数据</span><br><span class="line">如果row key已经存在，则变成了修改数据</span><br><span class="line"> </span><br><span class="line">更好的存储数据</span><br><span class="line">table.put()方法会立即给Hbase Thrift server发送一条命令。其实这种方法的效率并不高，我们可以使用更高效的table.batch()方法。</span><br><span class="line"></span><br><span class="line">使用batch一次插入多行数据</span><br><span class="line"></span><br><span class="line">bat = table.batch()</span><br><span class="line">bat.put(<span class="string">'www.test5.com'</span>, &#123;<span class="string">'cf1:price'</span>: <span class="number">999</span>, <span class="string">'cf2:title'</span>: <span class="string">'Hello Python'</span>, <span class="string">'cf2:length'</span>: <span class="number">34</span>, <span class="string">'cf3:code'</span>: <span class="string">'A43'</span>&#125;)</span><br><span class="line">bat.put(<span class="string">'www.test6.com'</span>, &#123;<span class="string">'cf1:content'</span>: <span class="string">'razor'</span>, <span class="string">'cf1:price'</span>: <span class="number">168</span>, <span class="string">'cf1:rating'</span>: <span class="string">'97%'</span>&#125;)</span><br><span class="line">bat.put(<span class="string">'www.test7.com'</span>, &#123;<span class="string">'cf3:function'</span>: <span class="string">'print'</span>&#125;)</span><br><span class="line">bat.send()</span><br><span class="line">更有用的方法是使用上下文管理器来管理batch，这样就不用手动发送数据了，即不再需要bat.send()</span><br><span class="line"></span><br><span class="line">*使用<span class="keyword">with</span>来管理batch *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> table.batch() <span class="keyword">as</span> bat:</span><br><span class="line">    bat.put(<span class="string">'www.test5.com'</span>, &#123;<span class="string">'cf1:price'</span>: <span class="string">'999'</span>, <span class="string">'cf2:title'</span>: <span class="string">'Hello Python'</span>, <span class="string">'cf2:length'</span>: <span class="string">'34'</span>, <span class="string">'cf3:code'</span>: <span class="string">'A43'</span>&#125;)</span><br><span class="line">    bat.put(<span class="string">'www.test6.com'</span>, &#123;<span class="string">'cf1:content'</span>: <span class="string">u'剃须刀'</span>, <span class="string">'cf1:price'</span>: <span class="string">'168'</span>, <span class="string">'cf1:rating'</span>: <span class="string">'97%'</span>&#125;)</span><br><span class="line">    bat.put(<span class="string">'www.test7.com'</span>, &#123;<span class="string">'cf3:function'</span>: <span class="string">'print'</span>&#125;)</span><br><span class="line">二、删除数据</span><br><span class="line">在batch中删除数据<span class="keyword">with</span> table.batch() <span class="keyword">as</span> bat:</span><br><span class="line">     bat.delete(‘www.test1.com<span class="string">')</span></span><br><span class="line"><span class="string"> batch将数据保存在内存中，知道数据被send，第一种send数据的方法是显示地发送，即bat.send()，第二种send数据的方法是到达with上下文管理器的结尾自动发送。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">** 三、检索数据**</span></span><br><span class="line"><span class="string"> 全局扫描一个table</span></span><br><span class="line"><span class="string"> for key, value in table.scan():</span></span><br><span class="line"><span class="string">    print key, value</span></span><br><span class="line"><span class="string">结果如下：</span></span><br><span class="line"><span class="string">,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">检索一行数据</span></span><br><span class="line"><span class="string">row = table.row(‘www.test4.com'</span>) <span class="keyword">print</span> row</span><br><span class="line">直接返回该row key的值（以字典的形式），结果为：</span><br><span class="line">&#123;‘cf2:name’: ‘LiuLin’, ‘cf2:date’: ‘<span class="number">2017</span><span class="number">-03</span><span class="number">-09</span>’&#125;</span><br><span class="line"></span><br><span class="line">检索多行数据</span><br><span class="line">rows = table.rows([‘www.test1.com<span class="string">', ‘www.test4.com'</span>])<span class="keyword">print</span> rows</span><br><span class="line">返回的是一个list，list的一个元素是一个tuple，tuple的第一个元素是rowkey，第二个元素是rowkey的值</span><br><span class="line">如果想使检索多行数据即table.rows()返回的结果是一个字典，可以这样处理检索多行数据，返回字典</span><br><span class="line">rows_dict = dict(table.rows([‘www.test1.com<span class="string">', ‘www.test4.com'</span>]))<span class="keyword">print</span> rows_dict</span><br><span class="line">如果想使table.rows()返回的结果是一个有序字典，即OrderedDict，可以这样处理检索多行数据，返回有序字典</span><br><span class="line"><span class="keyword">from</span> collection <span class="keyword">import</span> OrderedDict</span><br><span class="line">rows_ordered_dict = OrderedDict(table.rows([‘www.test1.com<span class="string">', ‘www.test4.com'</span>]))</span><br><span class="line"><span class="keyword">print</span> rows_ordered_dict</span><br><span class="line"></span><br><span class="line">好了，下面开始你的任务啦：</span><br><span class="line">按照右边的文件要求补完代码。</span><br><span class="line">预期输出：</span><br><span class="line">OrderedDict([(b’info:name’, b’John’), (b’scores:Bigdata’, b’<span class="number">89</span>’), (b’scores:database’, b’<span class="number">88</span>’)])</span><br><span class="line">b’<span class="number">95001</span>’ OrderedDict([(b’info:name’, b’John’), (b’scores:Bigdata’, b’<span class="number">89</span>’), (b’scores:database’, b’<span class="number">88</span>’)])</span><br><span class="line">b’<span class="number">95002</span>’ OrderedDict([(b’info:name’, b’Rose’), (b’scores:database’, b’<span class="number">68</span>’)])</span><br><span class="line">b’<span class="number">95003</span>’ OrderedDict([(b’info:name’, b’Greens’), (b’scores:Bigdata’, b’<span class="number">76</span>’)])</span><br><span class="line">如果运行结果报错提示显示表已经存在，</span><br><span class="line">,</span><br><span class="line">查看各个服务进程是否启动</span><br><span class="line">‘’</span><br><span class="line">root@evassh<span class="number">-2932225</span>:~<span class="comment"># jps</span></span><br><span class="line"><span class="number">1808</span> ResourceManager</span><br><span class="line"><span class="number">4785</span> Jps</span><br><span class="line"><span class="number">2820</span> ThriftServer</span><br><span class="line"><span class="number">1317</span> NameNode</span><br><span class="line"><span class="number">2694</span> HRegionServer</span><br><span class="line"><span class="number">1447</span> DataNode</span><br><span class="line"><span class="number">2506</span> HQuorumPeer</span><br><span class="line"><span class="number">1626</span> SecondaryNameNode</span><br><span class="line"><span class="number">2570</span> HMaster</span><br><span class="line">‘’</span><br><span class="line">如果处于启动状态就到到hbase shell中手动删除该表。</span><br><span class="line"></span><br><span class="line">开始你的任务吧，祝你成功！</span><br></pre></td></tr></table></figure>



<p>HBase创建操作表 <a href="https://www.educoder.net/tasks/hc5rigv6y2t4" target="_blank" rel="noopener">https://www.educoder.net/tasks/hc5rigv6y2t4</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一个大题 </span></span><br><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line">happybase.Connection(host=’localhost’, port=<span class="number">9090</span>, timeout=<span class="literal">None</span>, autoconnect=<span class="literal">True</span>, table_prefix=<span class="literal">None</span>, table_prefix_separator=b’_’, compat=’<span class="number">0.98</span>’, transport=’buffered’, protocol=’binary’)</span><br><span class="line"></span><br><span class="line">创建表：</span><br><span class="line">connection.create_table(</span><br><span class="line">    ‘shop’,</span><br><span class="line">    &#123;</span><br><span class="line">        ‘cf1’: dict(max_versions=<span class="number">10</span>),</span><br><span class="line">        ‘cf2’:dict(max_versions=<span class="number">1</span>,block_cache_enabled=<span class="literal">False</span>),</span><br><span class="line">        ‘cf3’: dict(),  <span class="comment"># use defaults</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入</span></span><br><span class="line">table = conn.table(<span class="string">"shop"</span>)</span><br><span class="line">bat = table.batch()</span><br><span class="line">bat.put(<span class="string">'0001'</span>,&#123;<span class="string">'interfaceInfo:inter_show'</span>:<span class="string">'HDM1'</span>, <span class="string">'interfaseInfo:inter_network'</span>:<span class="string">'10Mbps'</span>, <span class="string">'interfaceInfo:inter_three'</span>:<span class="string">'1个'</span>,<span class="string">'interfaceInfo:inter_Type-c'</span>:<span class="string">'1个'</span>&#125;)</span><br><span class="line">bat.put(<span class="string">'0002'</span>,&#123;<span class="string">'inputInfo:input_one'</span>:<span class="string">'有指点杆'</span>,<span class="string">'inputInfo:input_tow'</span>:<span class="string">'全尺寸键盘'</span>,<span class="string">'inputInfo:input_three'</span>:<span class="string">'多点触控'</span>,<span class="string">'inputInfo:input_four'</span>:<span class="string">'多点触控'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/eb29e8c5f3d070871e889a7df0c0648f.png" alt="image-20201222151712603"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/d62b69bbd06221ffbd8b6774aa4e984a.png" alt="image-20201222153426834"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/c62409102e9d05d8e27391cb9bd3f862.png" alt="image-20201222153450963"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/f575719efe0cbc47a6c0170f333c5019.png" alt="image-20201222142737837"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/c2d6d280fcca0e5c8ab064dfa4c7b587.png" alt="QQ图片20201222151459"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/eadce52255b38a7599c09f1141e02933.png" alt="QQ图片20201222151503"></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/22/ceac3a666c81d839a67c97e51c4eafa6.png" alt="QQ图片20201222151509"></p>
<p>mapper.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapper</span><span class="params">(line)</span>:</span></span><br><span class="line">    key = float(line.split(<span class="string">","</span>)[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    cat = <span class="string">''</span>        </span><br><span class="line">    <span class="keyword">if</span> key &lt;= <span class="number">630.00</span>:</span><br><span class="line">        cat = <span class="string">"mini"</span></span><br><span class="line">    <span class="keyword">elif</span> key &lt;= <span class="number">6300</span>:</span><br><span class="line">        cat = <span class="string">"mid"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cat = <span class="string">"over"</span></span><br><span class="line">    print(<span class="string">"%s\t%s"</span> % (cat, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">'child'</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mapper(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>reduce.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reducer</span><span class="params">(k, values)</span>:</span></span><br><span class="line">    print(<span class="string">"%s:\t:%s"</span> % (k, sum(values)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    current_key = <span class="literal">None</span></span><br><span class="line">    values = []</span><br><span class="line">    akey, avalue = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        line = line.strip()</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            akey, avalue = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#            2还是上次哪台</span></span><br><span class="line">        <span class="keyword">if</span> current_key == akey:</span><br><span class="line">            values.append(int(avalue))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"><span class="comment">#        3已经初始化过</span></span><br><span class="line">            <span class="keyword">if</span> current_key:</span><br><span class="line"><span class="comment">#          4    做一次计算</span></span><br><span class="line">                reducer(current_key, values)</span><br><span class="line"><span class="comment">#                重新计数</span></span><br><span class="line">                values = []</span><br><span class="line">                <span class="comment">#           1 初始化</span></span><br><span class="line">            values.append(int(avalue))</span><br><span class="line">            current_key = akey</span><br><span class="line"><span class="comment">#    循环完毕后处理最后一波        </span></span><br><span class="line">    <span class="keyword">if</span> current_key == akey:</span><br><span class="line">        reducer(current_key, values)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>spark.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mingqing yisi</span><br><span class="line">xianying nobody</span><br><span class="line">xueling mingqing</span><br><span class="line">xueling xianying</span><br><span class="line">qingqing xueling</span><br><span class="line">qingqing yuelin</span><br><span class="line"></span><br><span class="line"><span class="comment">#grand.py</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">        .appName(<span class="string">"grandparent"</span>) \</span><br><span class="line">        .getOrCreate()</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">raw = sc.textFile(<span class="string">"/root/childs.txt"</span>) \</span><br><span class="line">        .map(<span class="keyword">lambda</span> x:x.strip().lower().encode(<span class="string">"utf-8"</span>).split(<span class="string">" "</span>)) \</span><br><span class="line">        .map(<span class="keyword">lambda</span> x: Row(child=x[<span class="number">0</span>], parent=x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">relations = spark.createDataFrame(raw)</span><br><span class="line"></span><br><span class="line"><span class="comment"># relations.show()</span></span><br><span class="line"></span><br><span class="line">relations.createOrReplaceTempView(<span class="string">"table"</span>)</span><br><span class="line"></span><br><span class="line">result = spark.sql(<span class="string">"select a.child as grandchild, b.parent as grandparent from table as a inner join table as b  on a.parent=b.child "</span>)</span><br><span class="line"></span><br><span class="line">result.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spark.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------</span></span><br><span class="line"><span class="comment"># word count via sparksql</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">        .appName(<span class="string">"word count via sql"</span>) \</span><br><span class="line">        .getOrCreate()</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">raw = sc.textFile(<span class="string">"/root/words.txt"</span>) \</span><br><span class="line">        .flatMap(<span class="keyword">lambda</span> x:x.strip().lower().encode(<span class="string">"utf-8"</span>).split(<span class="string">" "</span>)) \</span><br><span class="line">        .map(<span class="keyword">lambda</span> x:(x, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">words = raw.map(<span class="keyword">lambda</span> x:Row(counts=int(x[<span class="number">1</span>]), word=x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">words_df = spark.createDataFrame(words)</span><br><span class="line">words_df.createOrReplaceTempView(<span class="string">"words_table"</span>)</span><br><span class="line"><span class="comment"># words_df.show(2)</span></span><br><span class="line">result = spark.sql(<span class="string">"select word, sum(counts) as cnt from words_table group by word order by cnt desc"</span>)</span><br><span class="line"> </span><br><span class="line">result.show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">spark.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">####------------------</span></span><br><span class="line"><span class="comment"># word cout by rdd</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder \</span><br><span class="line">       .appName(<span class="string">"app"</span>) \</span><br><span class="line">       .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)   \</span><br><span class="line">       .getOrCreate()</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">rdd = sc.textFile(<span class="string">"/root/words.txt"</span>) \</span><br><span class="line">        .flatMap(<span class="keyword">lambda</span> x:x.strip().lower().encode(<span class="string">"utf-8"</span>).split(<span class="string">" "</span>)) \</span><br><span class="line">        .map(<span class="keyword">lambda</span> x: (x, <span class="number">1</span>)) \</span><br><span class="line">        .reduceByKey(<span class="keyword">lambda</span> x, y: x+y) \</span><br><span class="line">        .sortBy(<span class="keyword">lambda</span> x:x[<span class="number">1</span>], <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">print(rdd.collect())</span><br><span class="line"></span><br><span class="line">spark.stop()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>失物招领Dokcer化部署</title>
    <url>//post/493714.html</url>
    <content><![CDATA[<h2 id="一、SSH配置"><a href="#一、SSH配置" class="headerlink" title="一、SSH配置"></a>一、SSH配置</h2><h3 id="1、更改Root用户密码"><a href="#1、更改Root用户密码" class="headerlink" title="1、更改Root用户密码"></a>1、更改Root用户密码</h3><p>初次使用先从管理员切换到root用户，并更改root用户密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">切换Root用户</span><br><span class="line">sudo su root</span><br><span class="line">为root用户设置密码</span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><a id="more"></a>


<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/23/f1044b5363673ba97e7dfd61c5dc0937.png" alt="image-20200810185454159"></p>
<h3 id="更改SSH默认配置-并重启SSH服务"><a href="#更改SSH默认配置-并重启SSH服务" class="headerlink" title="更改SSH默认配置 并重启SSH服务"></a>更改SSH默认配置 并重启SSH服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i "s/#PermitRootLogin.*/PermitRootLogin yes/g" /etc/ssh/sshd_config \</span><br><span class="line">&amp;&amp; sed -i "s/#PasswordAuthentication.*/PasswordAuthentication yes/g" /etc/ssh/sshd_config \</span><br><span class="line">&amp;&amp; sed -i "s/#PubkeyAuthentication.*/PubkeyAuthentication yes/g" /etc/ssh/sshd_config \</span><br><span class="line">&amp;&amp; /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>

<h2 id="二、Docker安装、启动、镜像加速、Docker-Compose安装"><a href="#二、Docker安装、启动、镜像加速、Docker-Compose安装" class="headerlink" title="二、Docker安装、启动、镜像加速、Docker Compose安装"></a>二、Docker安装、启动、镜像加速、Docker Compose安装</h2><p>使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，可以通过 –mirror 选项使用国内源进行安装，执行这组命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中并且设置开机自启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh \</span><br><span class="line">&amp;&amp; sudo sh get-docker.sh --mirror Aliyun \</span><br><span class="line">&amp;&amp; sudo systemctl enable docker \</span><br><span class="line">&amp;&amp; sudo systemctl start docker \</span><br><span class="line">&amp;&amp; echo " &#123; \</span><br><span class="line">\"registry-mirrors\": [ </span><br><span class="line">\"https://mirror.ccs.tencentyun.com\", </span><br><span class="line">\"https://eqcxmbvw.mirror.aliyuncs.com\" </span><br><span class="line">] </span><br><span class="line">&#125;" &gt;  /etc/docker/daemon.json \</span><br><span class="line">&amp;&amp; service docker restart \</span><br><span class="line">&amp;&amp; docker info \</span><br><span class="line">&amp;&amp; curl -k -L https://github.wuyanzheshui.workers.dev/docker/compose/releases/download/1.26.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/docker-compose \</span><br><span class="line">&amp;&amp; docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="Docker可视化面板安装（汉化版）"><a href="#Docker可视化面板安装（汉化版）" class="headerlink" title="Docker可视化面板安装（汉化版）"></a>Docker可视化面板安装（汉化版）</h3><p>汉化版的没有更新提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">registry.cn-zhangjiakou.aliyuncs.com/ctgu/portainer</span><br></pre></td></tr></table></figure>

<h2 id="三、开放安全组端口"><a href="#三、开放安全组端口" class="headerlink" title="三、开放安全组端口"></a>三、开放安全组端口</h2><blockquote>
<p>安装完成之后记得去阿里云或者腾讯云控制台开放对应端口，这里是<strong>9000</strong>端口</p>
<p>官方帮助文档：<a href="https://cloud.tencent.com/document/product/213/39740" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/213/39740</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/23/75f1d8904352a246428355bb4757d68c.png" alt="image-20200810190047023"></p>
<h2 id="四、服务器迁移"><a href="#四、服务器迁移" class="headerlink" title="四、服务器迁移"></a>四、服务器迁移</h2><h3 id="1、导出数据库文件，并删除mysql的安装文件"><a href="#1、导出数据库文件，并删除mysql的安装文件" class="headerlink" title="1、导出数据库文件，并删除mysql的安装文件"></a>1、导出数据库文件，并删除mysql的安装文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql sh -c "mysqldump -h127.0.0.1 -uroot -p数据库密码 swzl &gt; /docker-entrypoint-initdb.d/init.sql" \</span><br><span class="line">&amp;&amp; chmod +x /www/server/mysql/init/* \</span><br><span class="line">&amp;&amp; rm -rf /www/server/mysql/data/*</span><br></pre></td></tr></table></figure>

<h3 id="2、网站整站打包"><a href="#2、网站整站打包" class="headerlink" title="2、网站整站打包"></a>2、网站整站打包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.. \</span><br><span class="line">&amp;&amp; tar -zcvf www.tar.gz www</span><br><span class="line">scp www.tar.gz root@新服务的ip:..</span><br><span class="line"></span><br><span class="line">scp www.tar.gz root@49.235.194.44:..</span><br></pre></td></tr></table></figure>

<h2 id="五、网站证书"><a href="#五、网站证书" class="headerlink" title="五、网站证书"></a>五、网站证书</h2><h4 id="CDN证书需要每年到期后手动去云服务器控制台申请"><a href="#CDN证书需要每年到期后手动去云服务器控制台申请" class="headerlink" title="CDN证书需要每年到期后手动去云服务器控制台申请"></a>CDN证书需要每年到期后手动去云服务器控制台申请</h4><p>参考：<a href="https://blog.csdn.net/javaxw666/article/details/96602668" target="_blank" rel="noopener">https://blog.csdn.net/javaxw666/article/details/96602668</a></p>
<h2 id="五、网站证书设置定时任务，过期后自动替换"><a href="#五、网站证书设置定时任务，过期后自动替换" class="headerlink" title="五、网站证书设置定时任务，过期后自动替换"></a>五、网站证书设置定时任务，过期后自动替换</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">首次申请证书</span><br><span class="line">tar xvf www.tar.gz \</span><br><span class="line">&amp;&amp; /www/server/nginx/cert \</span><br><span class="line">&amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="六、定时任务设置"><a href="#六、定时任务设置" class="headerlink" title="六、定时任务设置"></a>六、定时任务设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建定时任务</span></span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 1 * * * cd /www/server/qiniu/ &amp;&amp; python main.py &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">0 0 */30 * * docker exec acme.sh --cron	--force &gt; /dev/null &amp;&amp; docker restart nginx</span><br></pre></td></tr></table></figure>

<h3 id="查看设置的定时任务"><a href="#查看设置的定时任务" class="headerlink" title="查看设置的定时任务"></a>查看设置的定时任务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2021/01/23/42e1ecbabac39741cfe4be888ff07aee.png" alt="image-20210123102953430"></p>
<h2 id="七、数据库注意事项"><a href="#七、数据库注意事项" class="headerlink" title="七、数据库注意事项"></a>七、数据库注意事项</h2><h3 id="1、数据库每天定时备份"><a href="#1、数据库每天定时备份" class="headerlink" title="1、数据库每天定时备份"></a>1、数据库每天定时备份</h3><p>备份用的七牛云OSS，每天定时备份，需要先安装依赖，然后添加定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装依赖</span><br><span class="line">apt install python-pip \</span><br><span class="line">&amp;&amp; pip install qiniu&#x3D;&#x3D;7.2.9</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">每晚凌晨1点备份数据库，保留最近30天的数据库，</span><br><span class="line">每隔30天检查一次证书</span><br><span class="line"><span class="meta">#</span><span class="bash">添加定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line">0 1 * * * cd /www/server/qiniu/ &amp;&amp; python main.py &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">0 0 */30 * * docker exec acme.sh --cron	--force &gt; /dev/null &amp;&amp; docker restart nginx</span><br></pre></td></tr></table></figure>

<h3 id="2、数据库目录权限问题"><a href="#2、数据库目录权限问题" class="headerlink" title="2、数据库目录权限问题"></a>2、数据库目录权限问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#数据库的权限</span><br><span class="line">chmod 777 &#x2F;www&#x2F;server&#x2F;mysql&#x2F;data</span><br></pre></td></tr></table></figure>

<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><blockquote>
<p>👉 Docker练习平台：<a href="http://play-with-docker.com" target="_blank" rel="noopener">http://play-with-docker.com</a></p>
<p>👉 Docker官方文档： <a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a></p>
<p>👉 Docker官网：<a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a></p>
<p>👉 Docker Hub：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
<p>👉 菜鸟教程Docker： <a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>实用工具站整理</title>
    <url>//post/43345.html</url>
    <content><![CDATA[<p>感觉收藏了很多书签，有些凌乱，还是把一些好用的工具放在这里吧</p><p>练习打字的：<a href="https://www.typingclub.com/da-zi" target="_blank" rel="noopener">https://www.typingclub.com/da-zi</a></p><a id="more"></a>

<p>Crontab定时任务表达式执行时间计算 <a href="http://www.matools.com/crontab" target="_blank" rel="noopener">http://www.matools.com/crontab</a></p>
]]></content>
      <tags>
        <tag>在线工具</tag>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>//post/1079.html</url>
    <content><![CDATA[<h2 id="4、调度与死锁"><a href="#4、调度与死锁" class="headerlink" title="4、调度与死锁"></a>4、调度与死锁</h2><p><strong>磁盘效率的计算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/18/1e3a04cc8e7bee7b8f8af0cfe9d73d1a.png" alt="image-20201218103303641"></p><p>调度算法</p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/18/649aa73aa185c7995e90a7428eec7d5e.png" alt="image-20201218103417049"></p><p>2分钟</p><p>0第一轮：A B C D E</p><p>8第二轮：A B D E</p><p>6第三轮： A B E</p><a id="more"></a>







<p>4第四轮：A E</p>
<p>2第五轮：A</p>
<hr>
<p><strong>银行家算法</strong></p>
<p><strong>例4.2.11</strong> 设系统中有三种类型的资源（A、B、C）和五个进程（P1、P2、P3、P4、P5），A资源的数量为17，B资源的数量为5，C资源的数量为20。在T0时刻系统状态如表1和表2所示。系统采用银行家算法实施死锁避免策略。</p>
<p>(1)  T0时刻是否为安全状态？若是，请给出安全序列。</p>
<p>(2)  在T0时刻若进程P2请求资源（0，3，4），是否能实施资源分配？为什么？</p>
<p>(3)  在②的基础上，若进程P4请求资源（2，0，1），是否能实施资源分配？为什么？</p>
<p>(4)  在③的基础上，若进程P1请求资源（0，2，0），是否能实施资源分配？为什么？</p>
<p>表4.1  T0时刻系统状态</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大资源需求量</th>
<th>已分配资源数量</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>P1</td>
<td>5</td>
<td>5</td>
<td>9</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>P2</td>
<td>5</td>
<td>3</td>
<td>6</td>
<td>4</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P3</td>
<td>4</td>
<td>0</td>
<td>11</td>
<td>4</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>P4</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>P5</td>
<td>4</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<p>表4.2  T0时刻系统状态</p>
<table>
<thead>
<tr>
<th></th>
<th>A   B    C</th>
</tr>
</thead>
<tbody><tr>
<td>剩余资源数</td>
<td>2   3    3</td>
</tr>
</tbody></table>
<p><strong>解</strong></p>
<p>(1)  系统在T0时刻：存在一个安全的序列（P4、P5、P1、P2、P3），因而是安全的。</p>
<p>(2)  若在T0时刻进程P2请求资源（0，3，4），因为可用资源的数量不够，所以只能推迟分配。</p>
<p>(3)  在(2)基础上，若进程P4请求资源（2，0，1），系统可以予以满足。因为当分配给P4后，系统剩余的可用资源为（0，3，2），仍能找到一个安全的序列，比如（P4、P5、P1、P2、P3）。</p>
<p>(4)  在(3)的基础上，若进程P1请求资源（0，2，0），系统不予以分配。因为分配出去后，系统找不到一个安全序列。</p>
<hr>
<p>3.2.6</p>
<p>司机售票员同步问题</p>
]]></content>
  </entry>
  <entry>
    <title>数据库原理笔记</title>
    <url>//post/43793.html</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27330413" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27330413</a></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306163830681.png" alt="image-20200306163830681"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306164113473.png" alt="image-20200306164113473"></p><p>关系运算：</p><p>基本运算</p><p>传统运算</p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306164419437.png" alt="image-20200306164419437"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306164725454.png" alt="image-20200306164725454"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200306164802547.png" alt="image-20200306164802547"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt;B 不满足</span><br><span class="line">A-&gt;C 不满足</span><br><span class="line">AB-&gt;C 满足</span><br><span class="line">C-&gt;A 不满足</span><br><span class="line">AC-&gt;B 不满足</span><br></pre></td></tr></table></figure><a id="more"></a>










<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">学号课号决定教师</span><br><span class="line">教师决定教师职务</span><br><span class="line">产品编码 决定产品名称</span><br><span class="line">教师职务 部分依赖（班级和课程号）</span><br><span class="line"></span><br><span class="line">员工码 培训日期决定培训内容</span><br><span class="line">我钉钉延迟2分钟</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">候选键：邮编+街道名</span><br><span class="line">非主属性：街道名</span><br><span class="line">城市+街道确定邮编</span><br><span class="line">邮编确定 城市</span><br><span class="line"></span><br><span class="line">候选键:AB</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519143352601.png" alt="image-20200519143352601" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519150915792.png" alt="image-20200519150915792" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519151301901.png" alt="image-20200519151301901" style="zoom:33%;">



<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519152045413.png" alt="image-20200519152045413" style="zoom:33%;">对</p>
<p>考试题目</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519152125088.png" alt="image-20200519152125088" style="zoom:33%;">

<p>顾客ID+商品ID+交易时间</p>
<p>3NF</p>
<p>非主属性对码的传递依赖</p>
<p>AB-&gt;C C-&gt;D，AB-&gt;D</p>
<p>2NF，非主属性部分依赖于主属性 D依赖于E</p>
<p>1NF,存在非主属性对码的部分依赖</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522160944865.png" alt="image-20200522160944865" style="zoom: 80%;">





<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522161207628.png" alt="image-20200522161207628"></p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522161141503.png" alt="image-20200522161141503" style="zoom:50%;">

<p>BCNF必须保证决定因素都是候选码，而不是主属性</p>
<p>所有属性都是主属性</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522162812594.png" alt="image-20200522162812594" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522163013941.png" alt="image-20200522163013941" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522163252154.png" alt="image-20200522163252154" style="zoom: 50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522164433723.png" alt="image-20200522164433723" style="zoom: 80%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522164725099.png" alt="image-20200522164725099" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200522165246780.png" alt="image-20200522165246780" style="zoom: 50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200526151110703.png" alt="image-20200526151110703" style="zoom:50%;">

<p><strong>波浪线表示外键</strong></p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616151514024.png" alt="image-20200616151514024" style="zoom:50%;">

<p>关键属性不要忽略，非关键属性可以不忽略</p>
<p><strong>关系范式</strong> 规范化分析</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616152037633.png" alt="image-20200616152037633" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616152207996.png" alt="image-20200616152207996" style="zoom:50%;">

<p>考试重点不是写过程，恢复以后的值是多少</p>
<p>读到未提交，并且回滚的数据,是脏数据。</p>
<p>不可重复读</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616152911007.png" alt="image-20200616152911007" style="zoom:50%;">





<p>（1）冗余，删除材料的时候，会出现删除异常，插入的时候，没有材料号无法删除</p>
<p>（2）工程号–&gt;开工日期，完工日期</p>
<p>材料号-&gt;f(价格)</p>
<p>主键（工程号，材料号）</p>
<p>第二范式，非主属性对码的部分函数依赖</p>
<p>R1(<u>工程号</u>，开工日期，完工日期)</p>
<p>R2（<u>材料号</u>,价格）</p>
<p>R3（<u>工程号</u>，<u>材料号</u>，数量）</p>
]]></content>
      <tags>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python微信SDK</title>
    <url>//post/29637.html</url>
    <content><![CDATA[<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://wechat-python-sdk.readthedocs.io/" target="_blank" rel="noopener">https://wechat-python-sdk.readthedocs.io/</a></p>]]></content>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期培训-Docker</title>
    <url>//post/493759.html</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200727122403354.png" alt="image-20200727122403354"></p><blockquote>
<p>Docker是基于GO语言实现的开源项目。docker的主要目标是“build，ship and run APP，anywhere“</p>
<p>Build Ship and Run</p>
<p>Build（构建镜像） ： 镜像就像是集装箱，包含文件以及运行环境等等资源；</p>
<p>Ship（运输镜像） ：在<a href="https://cloud.tencent.com/product/cdh?from=10680" target="_blank" rel="noopener">宿主机</a>和仓库间进行运输，这里仓库就像是超级码头；</p>
<p>Run （运行镜像） ：运行的镜像就是一个容器，容器就是运行程序的地方。</p>
<p>也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，</p>
<p>使用户的APP及用户环境能够做到”一次封装，到处运行“</p>
</blockquote><a id="more"></a>

<p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200727125029710.png" alt="image-20200727125029710"></p>
<p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730152100412.png" alt="image-20200730152100412"></p>
<h1 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h1><p>首先，大家需要明确一点，<strong>Docker</strong>容器<strong>不是</strong>虚拟机。</p>
<p>!(<a href="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3029876800,3884924252&amp;fm=26&amp;gp=0.jpg" target="_blank" rel="noopener">https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3029876800,3884924252&amp;fm=26&amp;gp=0.jpg</a>)</p>
<img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730152144671.png" style="zoom: 80%;">

<img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730151735325.png" alt="image-20200730151735325" style="zoom: 80%;">

<p>虚拟机是在一台物理机器上，利用虚拟化技术，虚拟出来多个操作系统，每个操作系统之间是隔离的。Docker是开源的应用容器引擎，依然需要先在电脑上安装操作系统， 然后安装Docker容器的管理器，才可以。</p>
<p>虚拟机是在硬件级别进行虚拟化，而Docker是在操作系统的层面虚拟化；虚拟机是通过模拟硬件搭建操作系统，而Docker则是复用操作系统；虚拟机实现了操作系统之间的隔离，Docker只是进程之间的隔离，所以虚拟机隔离级别更高、安全性方面也更强，但Docker的运行速度很快，可以使用秒来计算，而虚拟机的速度通常要按分钟计算。</p>
<h1 id="Docker和虚拟机对比"><a href="#Docker和虚拟机对比" class="headerlink" title="Docker和虚拟机对比"></a>Docker和虚拟机对比</h1><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200727125346344.png" alt="image-20200727125346344" style="zoom: 80%;">

<img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730151935749.png" alt="image-20200730151935749" style="zoom:67%;">

<h1 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h1><ul>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>更轻松的迁移</li>
<li>统一的管理</li>
</ul>
<h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境，就是所谓的“集装箱” 。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200611162007055.png" alt="image-20200611162007055" style="zoom: 80%;">

<p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200611163818495.png" alt="image-20200611163818495"></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730152314260.png" alt="image-20200730152314260" style="zoom: 67%;">

<h1 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h1><p>使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，可以通过 –mirror 选项使用国内源进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh \</span><br><span class="line">&amp;&amp; sudo sh get-docker.sh --mirror Aliyun \</span><br><span class="line">&amp;&amp; sudo systemctl enable docker \</span><br><span class="line">&amp;&amp; sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</p>
<p>启动 Docker CE</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sed -i "s/#PermitRootLogin.*/PermitRootLogin yes/g" /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><p>Ubuntu 16.04+、Debian 8+、CentOS 7，在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">echo " &#123; \</span><br><span class="line">\"registry-mirrors\": [ </span><br><span class="line">\"https://mirror.ccs.tencentyun.com\", </span><br><span class="line">\"https://eqcxmbvw.mirror.aliyuncs.com\" </span><br><span class="line">] </span><br><span class="line">&#125;" &gt;  /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<h1 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker Compose安装"></a>Docker Compose安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/docker-compose \</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h1 id="Docker可视化"><a href="#Docker可视化" class="headerlink" title="Docker可视化"></a>Docker可视化</h1><h2 id="汉化版"><a href="#汉化版" class="headerlink" title="汉化版"></a>汉化版</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">registry.cn-zhangjiakou.aliyuncs.com/ctgu/portainer</span><br></pre></td></tr></table></figure>

<h2 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">portainer/portainer</span><br><span class="line"></span><br><span class="line">最新版</span><br><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">portainer/portainer-ce</span><br></pre></td></tr></table></figure>

<h1 id="镜像的构建"><a href="#镜像的构建" class="headerlink" title="镜像的构建"></a>镜像的构建</h1><h2 id="Python开发环境构建"><a href="#Python开发环境构建" class="headerlink" title="Python开发环境构建"></a>Python开发环境构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@iZ8vbc32qrjl6z690p658hZ:~/docker# docker build -t qmx:1.0 .</span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1/5 : FROM python:3.6-alpine</span><br><span class="line">3.6-alpine: Pulling from library/python</span><br><span class="line">df20fa9351a1: Pull complete </span><br><span class="line">36b3adc4ff6f: Pull complete </span><br><span class="line">98eb400f742f: Pull complete </span><br><span class="line">31cc876ef68f: Pull complete </span><br><span class="line">e8928b84e39a: Pull complete </span><br><span class="line">Digest: sha256:56320bd9f0d878ae0842fc03f078b4e081ca8cf58492bc71bd4aa53a6958a632</span><br><span class="line">Status: Downloaded newer image for python:3.6-alpine</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d6b500d78779</span></span><br><span class="line">Step 2/5 : WORKDIR ~/qmx</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 3aafa7bef149</span></span><br><span class="line">Removing intermediate container 3aafa7bef149</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> c2892117f608</span></span><br><span class="line">Step 3/5 : RUN echo "Hello Docker!"</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 33461defb47a</span></span><br><span class="line">Hello Docker!</span><br><span class="line">Removing intermediate container 33461defb47a</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 3da8c691a4c8</span></span><br><span class="line">Step 4/5 : COPY app.py main.py</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 82b24de5eae7</span></span><br><span class="line">Step 5/5 : CMD python main.py</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 8328eccf17a9</span></span><br><span class="line">Removing intermediate container 8328eccf17a9</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 8a05929b777c</span></span><br><span class="line">Successfully built 8a05929b777c</span><br><span class="line">Successfully tagged qmx:1.0</span><br><span class="line">root@iZ8vbc32qrjl6z690p658hZ:~/docker# ls</span><br><span class="line">1  app.py  Dockerfile</span><br></pre></td></tr></table></figure>



<h2 id="Flask环境构建"><a href="#Flask环境构建" class="headerlink" title="Flask环境构建"></a>Flask环境构建</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> author=<span class="string">"iBoy&lt;547142436@qq.com&gt;"</span> version=<span class="string">"1.0"</span> description=<span class="string">"CTGU SWZL"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /www/wwwroot/ctguswzl.cn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g'</span> /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  apk --update  add --no-cache --virtual build-dependencies g++ gcc  libxslt-dev python-dev zlib-dev python3-dev openssl-dev \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  apk add jpeg-dev mysql-dev freetype-dev \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  pip install  --upgrade pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  pip install --no-cache-dir -r requirements.txt \</span></span><br><span class="line"><span class="bash">    &amp;&amp;  apk del build-dependencies \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/cache/apk/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /root/.cache \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /tmp/*</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">ENV</span> C_FORCE_ROOT True</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"./docker-entrypoint.sh"</span> ]</span></span><br></pre></td></tr></table></figure>



<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pyproject.toml poetry.lock  bot.py  /app/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex; \</span></span><br><span class="line"><span class="bash">    sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g'</span> /etc/apk/repositories; \</span></span><br><span class="line"><span class="bash">    apk --update  add --no-cache --virtual build-dependencies  build-base gcc  g++  python3-dev musl-dev jpeg-dev libressl-dev libffi-dev libxslt-dev  zlib-dev  openssl-dev; \</span></span><br><span class="line"><span class="bash">	pip config <span class="built_in">set</span> global.index-url https://pypi.doubanio.com/simple; \</span></span><br><span class="line"><span class="bash">    pip install  --upgrade pip; \</span></span><br><span class="line"><span class="bash">    pip install -U setuptools pip; \</span></span><br><span class="line"><span class="bash">	python3 -m pip install poetry; \</span></span><br><span class="line"><span class="bash">    poetry config virtualenvs.create <span class="literal">false</span>; \</span></span><br><span class="line"><span class="bash">    poetry install --no-root --no-dev; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/cache/apk/*; \</span></span><br><span class="line"><span class="bash">    rm -rf /root/.cache; \</span></span><br><span class="line"><span class="bash">    rm -rf /tmp/* /var/tmp/* ;</span></span><br><span class="line">    <span class="comment">#apk --purge del build-dependencies; \</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"python"</span>,<span class="string">"bot.py"</span>]</span></span><br></pre></td></tr></table></figure>



<h2 id="Tomcat镜像构建"><a href="#Tomcat镜像构建" class="headerlink" title="Tomcat镜像构建"></a>Tomcat镜像构建</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="comment">#创建目录</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /docker_home/<span class="built_in">local</span></span></span><br><span class="line"><span class="comment">#把当前目录下的jdk文件夹添加到镜像</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> tomcat7 /docker_home/<span class="built_in">local</span>/tomcat7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> java18 /docker_home/<span class="built_in">local</span>/java18</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /docker_home/local/java18/</span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /docker_home/local/tomcat7</span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin</span><br><span class="line"><span class="comment">#暴露8080端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#启动时运行tomcat</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/docker_home/local/tomcat7/bin/catalina.sh"</span>,<span class="string">"run"</span>]</span></span><br></pre></td></tr></table></figure>

<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><p>容器和宿主机通信</p>
<p>容器之间如何通信</p>
<p>不同Docker网络之间怎么通信</p>
<p>Docker网络的原理</p>
<h1 id="卷技术-（数据卷-volumes）"><a href="#卷技术-（数据卷-volumes）" class="headerlink" title="卷技术 （数据卷 volumes）"></a>卷技术 （数据卷 volumes）</h1><p>具名挂载</p>
<p>匿名挂载</p>
<p>/vae/lib/docker/volumes/</p>
<p>实现容器数据的持久化（Mysql，Redis）</p>
<p>实现配置文件的自定义</p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>实现容器间的数据共享</p>
<h1 id="容器编排与自动化部署"><a href="#容器编排与自动化部署" class="headerlink" title="容器编排与自动化部署"></a>容器编排与自动化部署</h1><p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Docker/image-20200730194742362.png" alt="image-20200730194742362"></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">springboot1:</span></span><br><span class="line">    <span class="comment"># build: /www/wwwroot/ctguswzl.cn</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openjdk:8-jdk-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">web1</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - '8888:8888'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 容器数据卷挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/m.iboy.tech/demo-0.0.1-SNAPSHOT.jar:/www/wwwroot/m.iboy.tech/app.jar</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span>  <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"cd /www/wwwroot/m.iboy.tech &amp;&amp; nohup java -jar app.jar"</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">springboot2:</span></span><br><span class="line">    <span class="comment"># build: /www/wwwroot/ctguswzl.cn</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openjdk:8-jdk-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">web2</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - '8888:8888'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 容器数据卷挂载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/m.iboy.tech/demo-0.0.1-SNAPSHOT1.jar:/www/wwwroot/m.iboy.tech/app.jar</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"cd /www/wwwroot/m.iboy.tech &amp;&amp; nohup java -jar app.jar"</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span> <span class="comment"># 挂载数据目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/conf:/etc/mysql/conf.d</span> <span class="comment"># 挂载配置文件目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/logs:/var/log/mysql</span> <span class="comment"># 挂载配置文件目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">      </span><br><span class="line">    <span class="attr">privileged:</span> <span class="string">'true'</span></span><br><span class="line">    <span class="attr">env_file:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/mysql.env</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_unicode_ci</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis/data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis/conf/redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/usr/local/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7000:7000'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 文件夹映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/proxy:/etc/nginx/proxy</span> <span class="comment">#反向代理配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/cert:/etc/nginx/cert</span> <span class="comment">#证书文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf.d:/etc/nginx/conf.d</span> <span class="comment"># nginx站点配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./www/wwwroot:/etc/nginx/sites-available</span> <span class="comment"># 宿主:docker:只读  ,www目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span> <span class="comment"># nginx配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/logs:/var/log/nginx</span> <span class="comment"># 网站日志文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时间</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/server/nginx/cache:/etc/nginx/cache</span> <span class="comment">#缓存配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot:/www/wwwroot</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springboot1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">springboot2</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'net'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<h2 id="加入已有的项目"><a href="#加入已有的项目" class="headerlink" title="加入已有的项目"></a>加入已有的项目</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">springboot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openjdk:8-jdk-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">springboot_app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/www/wwwroot/java</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 文件夹映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/www/wwwroot/java:/www/wwwroot/java</span> <span class="comment"># 挂载源码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone</span> <span class="comment">#同步时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime</span> <span class="comment">#同步时区</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/sh</span> <span class="string">-c</span> <span class="string">"nohup java -jar app.jar"</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'server_net'</span></span><br><span class="line">    <span class="attr">cap_add:</span> <span class="comment">#内核能力</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">server_net:</span></span><br><span class="line"><span class="comment">#    driver: bridge</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><blockquote>
<p>👉 Docker练习平台：<a href="http://play-with-docker.com" target="_blank" rel="noopener">http://play-with-docker.com</a></p>
<p>👉 Docker官方文档： <a href="https://docs.docker.com" target="_blank" rel="noopener">https://docs.docker.com</a></p>
<p>👉 Docker官网：<a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a></p>
<p>👉 Docker Hub：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
<p>👉 菜鸟教程Docker： <a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a></p>
</blockquote>
<h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><p>docker machine</p>
<p>docker swam</p>
<p>k8s</p>
<p>jenkins</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云函数实现疫情上报</title>
    <url>//post/38264.html</url>
    <content><![CDATA[<p><strong>1、注册腾讯云</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//cloud.tencent.com/">腾讯云cloud.tencent.com</a></p><p><strong>2、进入“控制台”</strong></p><p><img src="https://pic3.zhimg.com/v2-2fdaf3097500f24daf4008f3f6c8098c_r.jpg" alt="img"></p><p><strong>3、搜索“云函数”</strong></p><p><a href="https://link.zhihu.com/?target=http%3A//weixin.qq.com/q/02gMBYFjDs9bT1DISyxucO">http://weixin.qq.com/q/02gMBYFjDs9bT1DISyxucO</a> (二维码自动识别)</p><a id="more"></a>





<p><strong>4、进行部署</strong><br>（1）创建新函数</p>
<p><img src="https://picb.zhimg.com/v2-45e4686aba99ac7f4afde359f2922d89_r.jpg" alt="img"></p>
<p>（2）函数配置</p>
<p><img src="https://pic4.zhimg.com/v2-836459b93f3bd626685f8b6aecd350dc_r.jpg" alt="img"></p>
<p>（3）将py复制到</p>
<p><img src="https://pic2.zhimg.com/v2-8504e0f875236bda458dab3984ec9fd7_r.jpg" alt="img"></p>
<p>填写完后往下翻进行高级设置，这个时间建议设长一点，保证脚本能够运行完，填完后就可以保存了</p>
<p><img src="https://pic1.zhimg.com/v2-075f5f6f13153700c8d3de46d8e268db_r.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-5f4d9794ab6fc7341bd61e25005bde1b_r.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-6119056b94a76a0bd14bcf4f5ba47004_r.jpg" alt="img"></p>
<p>这样就是可以用的了</p>
<p><img src="https://pic2.zhimg.com/v2-e1524f2862249b71cd8982f3f8f89ae5_r.jpg" alt="img"></p>
<p>ps：出现这种情况显示”该ip无法访问CX等问题，可以第四步，重新选择一个地区进行创建”。</p>
<p><img src="https://picb.zhimg.com/v2-9e3cee4b80fdacc3cf55c6954b5bcb23_r.jpg" alt="img"></p>
<p><img src="../static/img/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%96%AB%E6%83%85%E4%B8%8A%E6%8A%A5/image-20200823173713009.png" alt="image-20200823173713009"></p>
]]></content>
  </entry>
  <entry>
    <title>操作系统重点</title>
    <url>//post/10605.html</url>
    <content><![CDATA[<h2 id="第一章、操作系统概述"><a href="#第一章、操作系统概述" class="headerlink" title="第一章、操作系统概述"></a>第一章、操作系统概述</h2><p><strong>一、为什么要区分系统态和用户态？</strong></p><p>​        防止操作系统和关键数据受到用户程序有意或无意的破坏，通常将处理机的执行状态分为系统态和用户态</p><a id="more"></a>

<ol>
<li><p>​    用户态下操作受到限制不能执行特权指令，防止操作系统或其他程序收到破坏，用户态的程序通过系统调用</p>
<p>接受系统态下的运行的服务</p>
</li>
<li><p>用户态下的程序只能存取自己的指令和数据，不能存取其他程序和操作系统的指令和数据</p>
<p>但是系统态下的进程可以存取操作系统和用户进行的数据，可以执行一切指令</p>
</li>
</ol>
<p><strong>二、多道程序设计的意义？</strong></p>
<ol>
<li><p>提高系统资源利用率和吞吐率。当程序需要等待某种事情的发生时，操作系统不用空闲等待，可以执行其他程序、这样CPU和外设可以并行操作</p>
</li>
<li><p>客观世界本身就是一个多道，客观世界有些问题想要快速解决，需要多道系统的出现</p>
<hr>
</li>
</ol>
<p><strong>三、客户机和服务器模型常用语网络和分布式系统，是否可用于单机系统？</strong></p>
<p>​        客户机/服务器模型是通用模型，广义上讲，提供服务的叫服务器，请求服务的叫客户机，在客户机/服务器模型中的，文件服务，进程服务都是以服务器进程的形式运行与用户态，用户进程通过向服务器请求或得服务，所以客户机/服务器模型即可用于网络和分布式系统，也可用户单机系统</p>
<p><strong>四、系统调用和一般的函数调用的区别？</strong></p>
<p>​    系统调用执行的程序在操作系统中的系统态下执行，一般的函数调用由用户准备在用户态下执行</p>
<p><strong>五、过程调用和系统调用的相同点是什么？它们与中断调用的差别是什么？</strong></p>
<ol>
<li><p>过程调用和系统调用的执行是完全同步的，在相同的数据集上重复执行，都需要保存现场信息转而执行其他的程序，执行后返回。</p>
</li>
<li><p>中断调用的执行是异步的，在相同的数据集上重复执行，中断的发生点可以是不同刘的。</p>
</li>
</ol>
<p><strong>六、一般计算机的启动过程？</strong></p>
<ol>
<li><p>由ROM程序对硬件进行检测</p>
</li>
<li><p>ROM中的启动程序将磁盘引导块读入内存</p>
</li>
<li><p>引导块将OS内核调入内存</p>
</li>
<li><p>执行OS内核程序进行初始化</p>
</li>
<li><p>加载外核处理程序，给出提示，等待用户操作</p>
</li>
</ol>
<p><strong>七、多道程序如何实现CPU计算和IO操作并行？</strong></p>
<p>​        多道程序系统中CPU无需直接控制IO操作的完成，而是通过通道，DMA，和中断机构控制IO完成，CPU不是空闲等待IO操作的完成，而是转而执行其他应用程序</p>
<p><strong>八、为什么相同的硬件条件下，一个应用程序可以在DOS和Windows下运行却不能在UNIX下运行？</strong></p>
<p>​        虽然硬件是相同的，但是应用程序的运行需要OS的支持，Windows是兼容DOS的，所以在DOS下运行的应用程序也能在OS下面运行，但是DOS，Windows和UNIX在系统结构,用户接口,API等方面是不兼容的，比如应用用到了windows下的系统调用的API，但是UNIX下没有，程序就无法运行。</p>
<p><strong>九、为什么中断机构对多道操作系统来说是比不可少的？</strong></p>
<p>​    操作系统的进程切换很多时候都是通过中断来完成的，如时钟中断，特别是在分时系统中，系统调用通过软中断来实现，通道和外设的操作也需要向操作系统发送中断。</p>
<p><strong>十、网络操作系统和分布式操作系统的区别？</strong></p>
<p>​        1、网络操作系统用户使用自己的机器可以通过网络访问其他机器的资源，通过网络将很多的机器连接起来共享硬件资源，但整个系统对用户来说是分散的，不透明的</p>
<p>​        2、分布式OS也是通过网络将整个系统连接起来，但是整个系统对用户来说是透明的，用户使用分布式OS就像在使用自己的电脑</p>
<p><strong>十一、将手工操作，单道批处理，多道批处理，多用户分时系统按照CPU利用率从小到大排序</strong></p>
<p>手工&lt;单道批处理系统&lt;多用户分时系统&lt;多道批处理系统</p>
<hr>
<h2 id="第二章、进程和线程的管理"><a href="#第二章、进程和线程的管理" class="headerlink" title="第二章、进程和线程的管理"></a>第二章、进程和线程的管理</h2><p><strong>一、举例说明多道程序系统时区封闭性和再现性</strong></p>
<p>有两个循环程序，共享一个变量N，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Pa&#123;</span><br><span class="line">	repeat</span><br><span class="line">		N:=N+<span class="number">1</span>;</span><br><span class="line">	until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pb&#123;</span><br><span class="line">	repeat</span><br><span class="line">		print(N);</span><br><span class="line">		N=<span class="number">0</span>;</span><br><span class="line">	until <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某时刻N的初值为n,可能出现以下三种情况</p>
<p>​        1、在在print(N)和N:=0之前，n的变化过程为：n+1,n+1,0</p>
<p>​        2、在print(N)和N:=0中间，n的变化过程是：n,n+1,0</p>
<p>​        3、在print(N)和N:=0之后，n的变化过程是：n,0,n+1</p>
<p><strong>二、进程的挂起状态、阻塞状态、以及就绪状态的区别？</strong></p>
<p>​    共同点是它们都没有占用CPU</p>
<p>​    不同点是挂起的进程处于禁止状态，在解除挂起之前不会参与对资源的竞争，也没有机会占用CPU</p>
<p>​    阻塞状态和就绪状态的进程都处于活动状态，都有活动处理机的机会，都可能有新的资源要求</p>
<p><strong>三、、在多道程序系统中，当需要等待某种事情发生时，系统将处于何种状态？</strong></p>
<p>​            这取决于进程程序的处理方式</p>
<p>​            1、调用阻塞原语，阻塞自己、让出CPU资源</p>
<p>​            2、进行忙等，不放弃CPU</p>
<p>​            当等待某种事件发生时，不一定要进入阻塞状态</p>
<p><strong>四、用户线程和内核支持线程有何区别？</strong></p>
<p>​    1、用户级线程是OS不可感知的，内核支持级线程是OS可感知的</p>
<p>​    2、用户 级线程的创建、撤销和调度不需要OS内核支持，是在语言这一级处理的，而内核支持级线程的创建、撤销、调度都需要OS内核的支持，与进程的创建撤销和调度是大致相同的</p>
<p>​    3、用户级线程执行系统调用指令时会导致其所属进程被中断，内核支持线程执行系统调用指令时只会导致改线程被中断</p>
<p>​    4、在只有用户级线程的系统内，CPU调度是以进程为单位，一个进程所对应的多个线程由用户程序切换运行，而在内核支持系统，CPU的调度以线程为单位，通过OS的线程调度程序负责调度</p>
<p>​    5、用户级线程支持的程序实体是运行在用户态下面的程序，内核支持用户程序实体可以运行在任何状态下</p>
<h2 id="第三章、进程的同步与通信"><a href="#第三章、进程的同步与通信" class="headerlink" title="第三章、进程的同步与通信"></a>第三章、进程的同步与通信</h2><p><strong>一、多个进程对信号量S进行了5次 P操作，2次V操作后，现在信号量的值是 -3，与信号量S相关的处于阻塞状态的进程有几个？信号量的初值是多少？</strong> </p>
<ol>
<li><p>处于阻塞状态的进程有3个</p>
</li>
<li><p>初值为-3+5-2=0</p>
</li>
</ol>
<p><strong>二、设公共汽车上，司机和售票员的活动分别为：司机的活动为启动车辆，正常行车，到站停车；售票员的活动为关车门，售票，开车门。试问：</strong></p>
<p>(1)  在汽车不断地到站、停车、行驶过程中，司机和售票员的活动是同步关系还是互斥关系？</p>
<p>​    司机的活动：开车、停车</p>
<p>​    售票员的活动：关车门、售票、开车门</p>
<p>​    司机停车、售票员开门、乘客下车、售票员关门、司机开车、售票员售票</p>
<p>​     司机和售票员的活动是同步关系</p>
<p>(2)  用信号量和P、V操作实现他们间的协调操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;司机进程&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">      车门是否关闭?没关则等待</span><br><span class="line">      启动车辆</span><br><span class="line">      正常行车</span><br><span class="line">      到站停车</span><br><span class="line">      设置车辆已停标志</span><br><span class="line">    until <span class="literal">false</span> </span><br><span class="line">&#125;</span><br><span class="line">&lt;售票员进程&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        关车门</span><br><span class="line">        设置车门已关标志</span><br><span class="line">        售票</span><br><span class="line">        车辆是否到站？没到站则等待</span><br><span class="line">        开车门</span><br><span class="line">        乘客上下车</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置两个信号量</p>
<p>S1车门是否关闭 0</p>
<p>S2车辆是否停车 1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;司机进程&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        P(S1);</span><br><span class="line">        车辆启动;</span><br><span class="line">        正常行车;</span><br><span class="line">        到站停车;</span><br><span class="line">        V(S2);</span><br><span class="line">     until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;司机进程&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        V(S1);</span><br><span class="line">        售票;</span><br><span class="line">        P(S2);</span><br><span class="line">        开车门;</span><br><span class="line">        乘客上下车;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三、说明管程中条件变量的含义和作用？</strong></p>
<p>管程中的条件变量是调用管程过程的进程用来执行Wait和Signal操作来挂起或解挂的变量</p>
<p>信号量与管程的条件变量的对比：</p>
<ol>
<li><p>信号量要赋初值，而条件变量不用，它只是一个队首指针</p>
</li>
<li><p>在信号量执行P操作不一定会被阻塞，在条件变量上执行Wait()操作会被挂起</p>
</li>
<li><p>在信号量上执行S操作，信号量的值加1，若加1后的值仍小于0，则会唤醒等待的进程，但唤醒者自身不受影响</p>
<p>但是在条件变量上执行Signal()操作则有两种选择，1、P等待，Q离开或等待另一条件发生，2、Q等待，P离开或等待另一条件发生，P和Q是两个进程</p>
</li>
</ol>
<p><strong>四、如下图所示，有多个PUT操作同时向BUFF1放数据，有一个MOVE操作不断地将BUFF1的数据移到Buff2，有多个GET操作不断地从Buff2中将数据取走。BUFF1的容量为m，BUFF2的容量是n, PUT、 MOVE、 GET每次操作一个数据，在操作的过程中要保证数据不丢失。试用Ｐ、Ｖ原语协调PUT、 MOVE的操作，并说明每个信号量的含义和初值。</strong></p>
<p>多生产者消费者问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/26/b7d318d5bb78a723a5bcec1a50e3fe62.png" alt="image-20201226142330701"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buff1 m</span><br><span class="line">buff2 n</span><br><span class="line">put into buff1</span><br><span class="line">move from buff1 to buff2</span><br><span class="line">get from buff2、</span><br><span class="line">多个PUT</span><br><span class="line">&lt;PUT&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        buff1是否有空间?没有则等待</span><br><span class="line">        buff1是否可操作</span><br><span class="line">        PUT</span><br><span class="line">        设置buff1可操作标志</span><br><span class="line">        设置buff1有数据标志</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">一个MOVE</span><br><span class="line">&lt;MOVE&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        buffer1是否有数据，没有则等待</span><br><span class="line">        buff2是否有空间，没有则等待</span><br><span class="line">        buff1是否可操作</span><br><span class="line">        buff2是否可操作</span><br><span class="line">        MOVE</span><br><span class="line">        设置buff1可操作标志</span><br><span class="line">        设置buff2可操作标志</span><br><span class="line">        设置buff1有空间标志</span><br><span class="line">        设置buff2有数据标志</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">多个GET</span><br><span class="line">&lt;GET&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        buff2是否有数据？没有则等待</span><br><span class="line">        buff2是否可操作</span><br><span class="line">        GET</span><br><span class="line">        设置buff2可操作标志</span><br><span class="line">        设置buff2有空间标志</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、某高校计算机系开设网络课并安排上机实习，假设机房共有2m台机器，有2n名学生选该课，规定：</strong></p>
<p>​        <strong>(1) 每两个学生组成一组，各占一台机器，协同完成上机实习；</strong></p>
<p>​        <strong>(2) 只有凑够两个学生，并且此时机房有空闲机器，门卫才允许该组学生进入机房；</strong></p>
<p>​        <strong>(3) 上机实习由一名教师检查，检查完毕，一组学生才可以离开机房。</strong></p>
<p>​        <strong>试用P、V操作模拟上机实习过程。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;门卫&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        学生<span class="number">1</span>是否到达？没有则等待</span><br><span class="line">        学生<span class="number">2</span>是否到达？没有则等待</span><br><span class="line">        是否有空闲计算机<span class="number">1</span>？没有则等待</span><br><span class="line">        是否有空闲计算机<span class="number">2</span>？没有则等待</span><br><span class="line">        分配计算机</span><br><span class="line">        设置学生<span class="number">1</span>可进入标志</span><br><span class="line">        设置学生<span class="number">2</span>可进入标志</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;学生&gt;&#123;</span><br><span class="line">	   设置有学生到达标志</span><br><span class="line">       学生是否可进入？</span><br><span class="line">       上机实习</span><br><span class="line">       设置实习完成标志 </span><br><span class="line">       老师是否可检查？不能则等待</span><br><span class="line">       离开机房</span><br><span class="line">&#125;</span><br><span class="line">&lt;教师&gt;&#123;</span><br><span class="line">     repeat</span><br><span class="line">         是否有学生<span class="number">1</span>完成实习？没有则等待</span><br><span class="line">         是否有学生<span class="number">2</span>完成实习？没有则等待</span><br><span class="line">         检查实习</span><br><span class="line">         设置学生<span class="number">1</span>完成实习的标志</span><br><span class="line">         设置学生<span class="number">2</span>完成实习的标志</span><br><span class="line">     until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">computer <span class="number">2</span>m	<span class="number">2</span>m</span><br><span class="line">student <span class="number">2</span>n	<span class="number">0</span>  到达的学生	<span class="number">0</span></span><br><span class="line">finish：是否有学生完成实习	<span class="number">0</span></span><br><span class="line">enter：学生是否可以进入	 <span class="number">0</span></span><br><span class="line">test：老师是否检查完一组学生 <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">&lt;门卫&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">		P(student);</span><br><span class="line">    	P(student);</span><br><span class="line">    	P(computer);</span><br><span class="line">    	P(computer);</span><br><span class="line">    	V(enter);</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;学生&gt;&#123;</span><br><span class="line">    V(studnet);</span><br><span class="line">    P(enter);</span><br><span class="line">    上机</span><br><span class="line">    V(finish)</span><br><span class="line">    P(test(i))</span><br><span class="line">    V(computer)</span><br><span class="line">&#125;</span><br><span class="line">&lt;教师&gt;&#123;</span><br><span class="line">    repeat</span><br><span class="line">        P(finish)<span class="comment">/**是否有需要检查的学生，等待实习完成**/</span></span><br><span class="line">        P(finish)<span class="comment">/**是否有需要检查的学生，等待实习完成**/</span></span><br><span class="line">        选出可检查的第i组学生</span><br><span class="line">        检查第i组学生的实习成果</span><br><span class="line">        V(test(i))</span><br><span class="line">        V(test(i))</span><br><span class="line">    until <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章、调度与死锁"><a href="#第四章、调度与死锁" class="headerlink" title="第四章、调度与死锁"></a>第四章、调度与死锁</h2><p><strong>一、有三个作业A（到达时间8:50，执行时间1.5小时）、B（到达时间9:00，执行时间0.4小时）、C（到达时间9:30，执行时间1小时）。当作业全部到达后，单道批处理系统按照响应比高者优先算法进行调度，则作业被选中的次序是？</strong></p>
<p>响应比 = 1+(等待时间/执行长度)</p>
<p>作业全部到达后，操作系统才开始调度</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>开始时间</th>
<th>运行长度</th>
<th>结束时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>8:50</td>
<td>9:54</td>
<td>1.5</td>
<td>11:44</td>
</tr>
<tr>
<td>B</td>
<td>9:00</td>
<td>9:30</td>
<td>0.4</td>
<td>9:54</td>
</tr>
<tr>
<td>C</td>
<td>9:30</td>
<td>11:44</td>
<td>1</td>
<td>12:44</td>
</tr>
</tbody></table>
<p>各个作业的等待时间为：开始调度的时间-到达的时间</p>
<p>A：0.67</p>
<p>B：0.5</p>
<p>C：0</p>
<p>各个进程的响应比为</p>
<p>响应比 = （等待时间+要求服务时间）/ 要求服务时间</p>
<p>当任务全部到达时，系统开始调度，此时A的等待时间</p>
<p>​    A：1+0.67/1.5 =1.44</p>
<p>​    B：1+0.5/0.4 = 2.25</p>
<p>​    C：1+0/1 = 1</p>
<p>​    选择B进行运行</p>
<p>当B完成后，时间为9:54,A的等待时间64min,C的等待时间为24m</p>
<p>​    A=1+64/90=1.71</p>
<p>​    C=1+24/60=1.4</p>
<p>选A运行，最后再运行C</p>
<p><strong>二、 有三个进程P1、P2和P3并发工作。进程P1需要资源S3和S1；进程P2需用资源S1和S2；进程P3需用资源S2和S3，回答：</strong></p>
<p><strong>（1）若对资源分配不加限制，会发生什么情况？为什么？</strong></p>
<p>​        可能发生死锁，P1持有S1,P2持有S2，P3持有S3，的同时，再同时申请其他资源，会形成循环等待</p>
<p><strong>（2）为保证进程正确地工作，应采用怎样的资源分配策略？为什么？</strong></p>
<ol>
<li>采用静态资源分配，在进程运行前分配给其所需的全部资源</li>
<li>资源按序分配，避免出现循环等待的现象</li>
<li>采用银行家算法再分配资源之前进行检测</li>
</ol>
<p><strong>三、有5个任务A，B，C，D，E，它们几乎同时到达，预计它们的运行时间为10，6，2，4，8min。其优先级分别为3，5，2，1和4，这里5为最高优先级。对于下列每一种调度算法，计算其平均进程周转时间（进程切换开销可不考虑）。</strong></p>
<p><strong>(1) 先来先服务（按A，B，C，D，E）算法。</strong></p>
<p>从提交到完成所用的时间</p>
<table>
<thead>
<tr>
<th>执行顺序</th>
<th>运行时间</th>
<th>优先级</th>
<th>等待时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>10</td>
<td>3</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>B</td>
<td>6</td>
<td>5</td>
<td>10</td>
<td>16</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
<td>16</td>
<td>18</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td>18</td>
<td>22</td>
</tr>
<tr>
<td>E</td>
<td>8</td>
<td>4</td>
<td>22</td>
<td>30</td>
</tr>
</tbody></table>
<p>平均周转时间(10+16+18+22+30)/5=19.2min</p>
<p><strong>(2) 优先级调度算法。</strong></p>
<table>
<thead>
<tr>
<th>执行顺序</th>
<th>运行时间</th>
<th>优先级</th>
<th>等待时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>6</td>
<td>5</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>E</td>
<td>8</td>
<td>4</td>
<td>6</td>
<td>14</td>
</tr>
<tr>
<td>A</td>
<td>10</td>
<td>3</td>
<td>14</td>
<td>24</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>2</td>
<td>24</td>
<td>26</td>
</tr>
<tr>
<td>D</td>
<td>4</td>
<td>1</td>
<td>26</td>
<td>30</td>
</tr>
</tbody></table>
<p>平均周转时间(6+14+24+26+30)/5=20</p>
<p><strong>(3) 时间片轮转算法。如果系统采用时间片轮转（RR）算法，令时间片为2分钟，5个任务轮流执行的情况为：</strong></p>
<p>第一轮：A B C D E</p>
<p>第二轮：A  B  D  E</p>
<p>第三轮：A  B   E</p>
<p>第四轮：A  E</p>
<p>第五轮：A</p>
<p>平均周转时间为（15+11+3+8+14）*2/5 = 20.4 min</p>
<p><strong>四、考虑由n个进程共享的具有m个同类资源的系统，证明：如果对i=1，2，…，n进程，有Need&gt;0而且所有最大需求量之和小于m+n,那么该系统是死锁无关的。</strong></p>
<p>设每个进程的最大需求量为x，最差的情况下，每个进程占有（x-1）个资源，各自最多再申请一个资源就能完成运行，进而释放它们所占有的资源</p>
<p>此时系统剩余资源为 m-n(x-1),当m-n(x-1)&gt;=1，即n*x&lt;=(m+n-1),也就是当最大资源需求量之和小于(m+n)，那么该系统是死锁无关的</p>
<p><strong>五、 设系统中有三种类型的资源（A、B、C）和五个进程（P1、P2、P3、P4、P5），A资源的数量为17，B资源的数量为5，C资源的数量为20。在T0时刻系统状态如表1和表2所示。系统采用银行家算法实施死锁避免策略。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/26/ec947109ad461d3b4ea5e46f21f691a9.png" alt="image-20201226194901090"></p>
<p><strong>(1)  T0时刻是否为安全状态？若是，请给出安全序列。</strong></p>
<p>​        P1（3，4，7）</p>
<p>​        P2（1，3，4）</p>
<p>​        P3（0，0，6）</p>
<p>​        P4（2，2，1）</p>
<p>​        P5（1，1，0）</p>
<p>​        在T0时刻，存在一个安全序列（P4，P5，P3，P2，P1），所以系统是安全的</p>
<p><strong>(2)  在T0时刻若进程P2请求资源（0，3，4），是否能实施资源分配？为什么？</strong></p>
<p>​        不能实施分配，因为系统的可用资源不足，所以只能推迟分配</p>
<p><strong>(3)  在②的基础上，若进程P4请求资源（2，0，1），是否能实施资源分配？为什么？</strong></p>
<p>​        可以，此时系统仍能找到一个安全序列（P4，P1，P3，P5，P2）</p>
<p><strong>(4)  在③的基础上，若进程P1请求资源（0，2，0），是否能实施资源分配？为什么？</strong></p>
<p>​        可以实施资源分配</p>
<h2 id="第五章、存储器管理"><a href="#第五章、存储器管理" class="headerlink" title="第五章、存储器管理"></a>第五章、存储器管理</h2><p><strong>一、动态重定位的特点有哪些？</strong></p>
<ol>
<li><p>动态重定位的实现主要依靠硬件地址变换机构，并且存储管理的软件算法比较复杂</p>
</li>
<li><p>程序代码是按照原样装入内存，在重定位过程中不发生变化</p>
</li>
<li><p>相同的逻辑地址，每次执行都要重定位一次</p>
</li>
<li><p>改变基地址，很容易实现代码在内存中的移动</p>
</li>
<li><p>动态重定位可以将程序分配到不连续的存储区中</p>
</li>
<li><p>实现虚拟存储器需要动态重定位技术的支持</p>
</li>
</ol>
<p><strong>二、有一计算机系统，内存容量为512K，辅存容量为2G，逻辑地址形式如下，求其虚拟存储器的实际容量？**</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/12/27/27e22ad5f118fcaead717aebdb4f8c6b.png" alt="image-20201227091459284"></p>
<p>虚拟内存的理论容量：2^10*2^20B=2^30B=1024M</p>
<p>最大段内地址：2^20B =1M，远大于内存容量</p>
<p>段长超过 512K的内存容量，所以，最大实际段长为512K</p>
<p>所以虚拟存储器的实际容量为：2^10*0.5M=0.5G，所以虚拟存储器的实际容量为0.5G</p>
<p><strong>三、解释静态链接、装入时动态链接和执行时动态链接的不同？</strong></p>
<p>1、静态链接本来是编译系统的工作，但是随着程序执行方式的改进，“程序链接”不再是编译系统的事情，它还需要</p>
<p>OS的支持</p>
<p>程序的静态链接，是指在程序装入内存之前，将已经编译好的多个模块链接成可执行程序，其特点为：1、链接好的可执行程序可反复执行 2、被链接好的模块不能再拆分，不便于修改3、不便于多个程序共享某些模块，需要使用同一模块的多个程序需要将该模块链入自己的程序空间</p>
<p>装入时动态链接，是指在程序加载进内存的时候，由OS将磁盘中的模块在内存中链接成一个可执行程序，特点是：</p>
<p>1、可执行程序只在内存中，每次执行需要重新链接</p>
<p> 2、被链接的各个模块在磁盘上是独立存放的</p>
<p>3、多个程序共享某一模块时，只需要在内存中保留该模块的一个副本</p>
<p>执行时动态链接是把程序的链接推迟到程序执行时动态的根据需要进行链接，它除了有装入时动态链接的特点以外，还有一个显著的特点是，只会装入需要的模块，从而减少时空的开销，他增加了链接的复杂性，需要一定的硬件支持。</p>
<p><strong>四、在分页存储管理系统中，存取一次内存的时间是8us，查询一次快表的时间是1us，缺页中断的时间是20us，假设页表的查询与快表的查询同时进行 。当查询页表时，如果该页在内存但快表中没有页表项，系统将自动把该页页表项送入快表。</strong></p>
<p><strong>(1) 求对某一数据进行一次次存取可能需要的时间？</strong></p>
<p>对数据存取有3中情况：</p>
<ol>
<li><p>数据在内存中，并且已经存放到块表：</p>
<p>此时用时：1us+8us=9us</p>
</li>
<li><p>数据在内存中，但是其页表项没有存储到快表</p>
<p>此时的用时为：8us查页表+8us存取内存数据</p>
</li>
<li><p>存取的数据不再内存，发生缺页中断</p>
<p>此时的用时为：查询页表+缺页中断+查询页表+存取内存</p>
<p>8us+20us+8us+8us=44us</p>
</li>
</ol>
<p><strong>(2) 现连续对同一页面上的数据进行4次连续读取，求每次读取数据可能需要的时间?</strong></p>
<p>  第一次存取可能需要的时间为：</p>
<p>1us+8us=9us,8us+8us=16us，8us+20us+8us+8us=44us</p>
<p>第二次，第三次，第四次对应的页表项已经交换到了快表中，所用的存取时间都是一样的1us+8us=9us</p>
<p><strong>五、为什么说分段系统相比于分页系统更容易实现信息的共享和保护？如何实现。</strong></p>
<p>在分页或分段的存储管理中，多个进程并发运行共享同一内存块中的数据是可行的，为了实现共享，在共享者的段表或者页表中，必须有指向共享内存的表目</p>
<p>在分段系统中，被共享的程序或数据可以作为单独的一段，在物理上它是一段，在不同进程中，可以对应不同的逻辑段，相对来说，实现是比较容易的</p>
<p>在分页管理中，这要困难的多，首先必须保证被共享的程序或数据占有整数快，以便和非共享数据分开，其次对于共享数据的访问应该是有限制条件的</p>
<p>因此从共享和保护的实现来看，共享的程序或数据应该作为一个逻辑单位，在分段管理中也就是一段，实现共享和保护就方便的多</p>
<p>实现方式：分段系统中是通过两个或多个进程的段表中的表目指向相同的物理块，并设置共享计数来实现的。</p>
<p>每段设置访问方式，就能实现保护。</p>
<p><strong>六、在虚拟页式的存储管理系统中，为什么要引入缺页中断？缺页中断的实现有那几部构成？各个部分是怎么实现的？</strong></p>
<ol>
<li><p>虚拟页式存储管理系统是在页式管理系统上实现的虚拟存储器，作业在执行时，并不是把所有的页都放在主存中的，当要访问的页面不存在时，需要系统通过缺页中段将所需页面由辅存装入主存</p>
<p>缺页中断由缺页处理和页淘汰完成的</p>
<p>缺页处理实现：</p>
<ol>
<li><p>中断触发</p>
<p>查询页表时发现逻辑页不在内存中，将其修改位置为0，触发缺页中断</p>
</li>
<li><p>页面调入</p>
<p>OS查找对应页面的辅存地址，将页面调入内存，进行页面淘汰</p>
</li>
<li><p>修改页表</p>
<p>将页面的内存地址填入页表，并将状态位修改为1，缺页中断结束，恢复现场，重新执行指令</p>
</li>
</ol>
<p>页淘汰的实现：</p>
<ol>
<li>如果内存有空闲页，直接调入外存的页面，修改页表</li>
<li>如果内存已满，则根据页面置换算法，淘汰页面</li>
<li>如果要淘汰的页面的修改位为0，则从外存调入页面覆盖并修改页表</li>
<li>如果要淘汰的页面修改位为1，则申请一块交换空间，将原页面的内容复制到交换空间中，然后将辅存的页面调入其中，并修改页表</li>
</ol>
</li>
</ol>
<h2 id="第六章、设备管理"><a href="#第六章、设备管理" class="headerlink" title="第六章、设备管理"></a>第六章、设备管理</h2><p><strong>一、IO软件一般分为四个层次，用户层，设备无关软件层，设备驱动程序，中断处理程序，请说明下面各项工作是在哪一层完成的？</strong></p>
<p>设备驱动层：</p>
<p>​    1、将抽象的要求转化为具体的要求，编码转换</p>
<p>   2、发送IO指令，控制设备启动</p>
<p>​    3、检查用户是否有权使用设备</p>
<p>软件层：</p>
<p>负责解释用户的请求，并将请求转化成具体的输入输出，但不检查权限</p>
<p>设备无关的软件层：将逻辑设备名转换为具体的物理设备，实现设备的分配与回收，以及缓冲区管理</p>
<ol>
<li><p>向设备寄存器写命令</p>
<p>属于直接操作设备控制器的操作，属于设备驱动层</p>
</li>
<li><p>检查用户是否有权使用设备</p>
<p>设备驱动层</p>
</li>
<li><p>将二进制整数转换成ASCII码以便打印</p>
<p>这属于将抽象的要求转化为具体的要求</p>
</li>
</ol>
<p><strong>二、在缓冲池中有3个队列，分别为空白缓冲队列em，输入缓冲队列in，以及输出缓冲队列out。过程add_buf（type，numb）和take_buf（type，numb）分别用来把缓冲区numb插入type队列和从type队列中取出缓冲区numb。试描述进程从任一缓冲队列得到一个缓冲区的过程get_buf（type,numb）和将一个缓冲区numb放入缓冲队列的过程put_buf（type,numb）？</strong></p>
<p>设置队列的互斥信号量为S，初值为1，设置资源数目信号量为RS，初值为n</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Semaphore RS=n;</span><br><span class="line"><span class="function">procedure  <span class="title">put_buf</span><span class="params">(type,numb)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">	<span class="title">P</span><span class="params">(S)</span></span>;</span><br><span class="line">	add_buf(type,numb);</span><br><span class="line">	V(mutex);</span><br><span class="line">	V(RS);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="function">procedure <span class="title">get_buf</span><span class="params">(type,numb)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line"><span class="function">    <span class="title">P</span><span class="params">(RS)</span></span>;</span><br><span class="line">	P(mutex);</span><br><span class="line">    buffer(numb)=get_buff(type,numb);</span><br><span class="line">    V(mutex);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p><strong>三、描述操作系统使用公用缓冲池时，数据插入缓冲队列的输入过程？</strong></p>
<p>缓冲池由多个缓冲区构成，每个缓冲区由缓冲池首部和缓冲体构成，系统通过操作缓冲池的首部实现对缓冲区的管理。</p>
<p>通常缓冲池有3个队列，em为空白缓冲区队列，in为装满输入数据的缓冲区队列，out为装满输出数据的缓冲区队列，</p>
<p>另参数type表示缓冲队列类型，参数number表示缓冲区号，缓冲池管理中负责数据输入过程可包括：</p>
<p>1、过程get_buff(type,numb)；以某种规则从type指定的缓冲区队列中摘取一个缓冲区</p>
<p>2、过程put_buff(type,numb)；将numb缓冲区放入相应的缓冲队列</p>
<p>使用上述操作：</p>
<p>输入过程可被描述如下：</p>
<p>1、进程调用get_buff(type,numb),从em队列中获取一个空白缓冲区，返回的编号为numb，获取的缓冲区命名为hin</p>
<p>2、将输入的数据装入到hin中，当hin中装满了数据之后，调用put_buff(in,hin)将该缓冲区插入到输入缓冲队列中</p>
<p><strong>四、试给出两种IO调度算法，并说明为什么IO调度不能使用时间片轮转法？</strong></p>
<p>1、FCFS 先来先服务算法。当多个进程对同一IO设备进行输入输出请求时，按照到达时间排成队列，将IO设备分配给队列的第一个进程</p>
<p>2、优先级高者优先算法。多个进程对同一IO设备进行输入输出请求时，按照进程的优先级排成队列，将IO设备分配给优先级最高的设备</p>
<p>IO设备因其固有属性，只能独占使用，当一个进程使用完的时候其他进程才能使用，在由通道控制的输入输出系统中，通道程序不能被时钟中断所打断，所以IO调度不能使用时间片轮转法。</p>
<p><strong>五、某操作系统中采用单缓冲传送磁盘数据。设从磁盘将数据传送到缓冲区所用时间为T1，将缓冲区数据传送到用户区所用时间为T2，CPU处理数据所用时间为T3。问系统处理该数据所用总时间为多少？</strong></p>
<p>第一个数据块从外存输入到缓冲区并将缓冲区的数据输入到用户区时，第二个数据块将数据输入缓冲区就能和</p>
]]></content>
  </entry>
  <entry>
    <title>最后一天折腾汇总</title>
    <url>//post/14725.html</url>
    <content><![CDATA[<h1 id="Windows10下安装Anaconda3-64位-详细过程"><a href="#Windows10下安装Anaconda3-64位-详细过程" class="headerlink" title="Windows10下安装Anaconda3(64位)详细过程"></a>Windows10下安装Anaconda3(64位)详细过程</h1><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><a id="more"></a>
<p><a href="https://blog.csdn.net/ychgyyn/article/details/82119201" target="_blank" rel="noopener">https://blog.csdn.net/ychgyyn/article/details/82119201</a></p>
<p><a href="https://www.jianshu.com/p/1f94ff0c6e68" target="_blank" rel="noopener">https://www.jianshu.com/p/1f94ff0c6e68</a></p>
<p>conda安装celery</p>
<p><a href="https://blog.csdn.net/weixin_30760895/article/details/101983Ubuntu538" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30760895/article/details/101983Ubuntu538</a></p>
<p>coda指定安装路径3.5.2</p>
<p><a href="https://www.cnblogs.com/lemonbit/p/7068091.html" target="_blank" rel="noopener">https://www.cnblogs.com/lemonbit/p/7068091.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Anaconda创建环境：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面是创建python&#x3D;3.6版本的环境，取名叫py36</span><br><span class="line"></span><br><span class="line">conda create -n py36 python&#x3D;3.6 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">删除环境（不要乱删啊啊啊）</span><br><span class="line"></span><br><span class="line">conda remove -n swzl --all</span><br><span class="line"></span><br><span class="line"> 查看所有的虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"></span><br><span class="line">激活环境</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面这个py36是个环境名</span><br><span class="line"></span><br><span class="line">source activate py36  (conda4的是：conda activate py36)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conda create --help</span><br><span class="line">安装虚拟环境到指定路径的命令如下：</span><br><span class="line">conda create --prefix&#x3D;O:\Python\SWZL\venv -n python&#x3D;3.5.2</span><br><span class="line">激活虚拟环境</span><br><span class="line">conda activate O:\Python\SWZL\venv</span><br><span class="line">退出虚拟环境的命令如下：</span><br><span class="line">deactivate</span><br><span class="line">删除虚拟环境</span><br><span class="line">conda remove --p&#x3D;O:\Python\SWZL\  -n venv --all</span><br></pre></td></tr></table></figure>

<p>查找指定版本的包</p>
<p><a href="https://blog.csdn.net/ksws0292756/article/details/79192268" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/79192268</a></p>
<p>conda安装源更换</p>
<p><a href="https://blog.csdn.net/ffscript/article/details/78447197" target="_blank" rel="noopener">https://blog.csdn.net/ffscript/article/details/78447197</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anaconda search -t conda celery</span><br><span class="line">anaconda show   prometeia&#x2F;celery </span><br><span class="line">conda install</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipenv+anaconda创建虚拟环境</span><br><span class="line">pipenv --python D:\ProgramData\Anaconda3\pkgs\python-3.5.2-0\python.exe</span><br><span class="line">更新 pypi源来提高依赖库安装的速度</span><br><span class="line">在使用pipenv的时候，常常会在安装的时候，一直卡在了 Locking 这里，通过加上 -v 参数，可以看到安装过程中的步骤信息，卡在了下载那里，这时应该可以意识到是因为网络的原因，pipenv创建的 Pipfile 中默认的pypi源是python官方的 https:&#x2F;&#x2F;pypi.python.org&#x2F;simple。我们国内用户访问下载的时候会很慢。</span><br><span class="line">https:&#x2F;&#x2F;vimiix.com&#x2F;post&#x2F;2018&#x2F;03&#x2F;11&#x2F;manage-your-virtualenv-with-pipenv&#x2F;</span><br><span class="line">所以，我一般会在创建好Pipfile以后，修改到文件中 source 块下的 url 字段，设置为国内的 pypi 源就好了，我推荐的是清华的pypi源，具体设置如下：</span><br><span class="line"></span><br><span class="line">备注：我还没有找到如何修改能在创建时就设好的方法，应该修改源码是可以的，但这样不尊重源码，毕竟高墙是我们自己筑起的，如果有好的方法，您不妨在评论中告诉我一下</span><br><span class="line">[[source]]</span><br><span class="line"></span><br><span class="line"> url &#x3D; &quot;https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&quot;</span><br><span class="line"> verify_ssl &#x3D; true</span><br><span class="line"> name &#x3D; &quot;pypi&quot;</span><br><span class="line"> </span><br><span class="line"> 虚拟环境位置</span><br><span class="line"></span><br><span class="line">Pipenv 生成的虚拟环境默认在用户目录, 你可以通过设置环境变量: PIPENV_VENV_IN_PROJECT&#x3D;1 来使生成的虚拟环境位于项目目录.</span><br><span class="line">Windows-x64 10</span><br><span class="line">Celery 3.1.23</span><br><span class="line">Celery-with-redis 3.0</span><br><span class="line">Redis-win32-win64 2.4.5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install celery&#x3D;&#x3D;3.1.15</span><br><span class="line">pip install redis&#x3D;&#x3D;2.10</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:3.5</span><br><span class="line">MAINTAINER iBoy &quot;547142436@qq.com&quot;</span><br><span class="line">COPY requirements.txt &#x2F;root&#x2F;www&#x2F;app&#x2F;</span><br><span class="line">WORKDIR &#x2F;root&#x2F;www&#x2F;app</span><br><span class="line">CMD [&quot;python&quot;]</span><br><span class="line">RUN pip install -r requirements.txt -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">Flask + Docker 无脑部署新手教程</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;78432719</span><br><span class="line"></span><br><span class="line">构建文件</span><br><span class="line">docker build -t flask-sample:latest .</span><br><span class="line"></span><br><span class="line">sudo docker run -it --rm -p 80:80 testflask</span><br><span class="line"></span><br><span class="line"> pip3 install -r requirements.txt  -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">修改默认指向方式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更改Linux Python镜像</span><br><span class="line">cd ~</span><br><span class="line">mkdir .pip</span><br><span class="line">cd .pip</span><br><span class="line">vim pip.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">timeout &#x3D; 6000</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">trusted-host &#x3D; pypi.tuna.tsinghua.edu.cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">生成纯净的依赖</span><br><span class="line">第二种 (推荐) 使用 pipreqs ，github地址为： https:&#x2F;&#x2F;github.com&#x2F;bndr&#x2F;pipreqs</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">pip install pipreqs</span><br><span class="line"># 在当前目录生成</span><br><span class="line">pipreqs . --encoding&#x3D;utf8 --force</span><br><span class="line">注意 --encoding&#x3D;utf8 为使用utf8编码，不然可能会报UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xae in position 406: illegal multibyte sequence 的错误。</span><br><span class="line"></span><br><span class="line">--force 强制执行，当 生成目录下的requirements.txt存在时覆盖。</span><br><span class="line"></span><br><span class="line">当当当，可以看见我依赖的只有这些啦</span><br><span class="line">python3 run.py  --host&#x3D;0.0.0.0 --port&#x3D;8888 --no-reload</span><br><span class="line">celery worker -A run.celery -l  DEBUG -E</span><br><span class="line">celery worker -A app.celery -l  DEBUG -E</span><br><span class="line"></span><br><span class="line">pip3 install gunicorn</span><br><span class="line">python3 run.py  --host&#x3D;0.0.0.0 --port&#x3D;8889 --no-reload</span><br><span class="line">sudo apt-get install gunicorn</span><br><span class="line">gunicorn -b 0.0.0.0:8889 run:app</span><br><span class="line">pip3 install -U git+https:&#x2F;&#x2F;github.com&#x2F;benoitc&#x2F;gunicorn.git</span><br><span class="line"></span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;True&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis允许外部连接 https:&#x2F;&#x2F;www.cnblogs.com&#x2F;sheseido&#x2F;p&#x2F;11239137.html</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu包管理工具更改</span><br><span class="line">解决Ubuntu 无法用 apt-get install 安装任何软件</span><br><span class="line">https:&#x2F;&#x2F;www.codelast.com&#x2F;%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE&#x2F;</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;security.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;a&#x2F;apt&#x2F;apt_1.6.12_amd64.deb</span><br><span class="line">dpkg -i apt_1.6.12_amd64.deb</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装Redishttps:&#x2F;&#x2F;juejin.im&#x2F;entry&#x2F;5bac46dd5188255c960c3d27</span><br><span class="line">sudo apt-get install redis-server</span><br><span class="line">检查进程</span><br><span class="line">ps -agx|grep redis</span><br><span class="line">检查启动</span><br><span class="line">netstat -nlt|grep 6379</span><br><span class="line">检查状态</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;redis-server status</span><br><span class="line">redis-cli</span><br><span class="line">Redis服务器的配置文件redis.conf</span><br><span class="line">sudo vim &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">vim 搜索</span><br><span class="line">命令模式下 &#x2F;127.0.0.1</span><br><span class="line">按下n查找下一个，按下N查找上一个。</span><br><span class="line"></span><br><span class="line">如果是用apt-get或者yum install安装的redis，可以直接通过下面的命令停止&#x2F;启动&#x2F;重启redis</span><br><span class="line"></span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;redis-server stop </span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;redis-server start </span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;redis-server restart</span><br><span class="line"></span><br><span class="line">如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redis</span><br><span class="line"></span><br><span class="line">1.redis关闭 </span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">2.redis启动 </span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line">如果上述方式都没有成功停止redis，则可以使用终极武器 kill -9</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu18.04换源</span><br><span class="line">sudo mv &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sourses.list.backup</span><br><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">#清华源</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">#3 更改完成之后执行以下命令</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade。</span><br><span class="line">mysqlclient无法安装解决</span><br><span class="line">sudo apt-get install python3.6-dev</span><br><span class="line">mysqlclinet安装报错https:&#x2F;&#x2F;blog.ducthinh.net&#x2F;gcc-no-such-file-python-h&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、允许mysql远程访问,可以使用以下三种方式:</span><br><span class="line">a、改表。</span><br><span class="line">mysql -u root –p</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;update user set host &#x3D; &#39;%&#39; where user &#x3D; &#39;root&#39;;</span><br><span class="line">mysql&gt;select host, user from user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ubuntu18.04安装MySQL Server</span><br><span class="line">Ok, I solved in this way:</span><br><span class="line"></span><br><span class="line">I used Software &amp; Updates application to remove mariadb sources</span><br><span class="line">and executed the followings steps (ref https:&#x2F;&#x2F;askubuntu.com&#x2F;a&#x2F;934576):</span><br><span class="line">sudo apt purge mysql-client-5.7 mysql-client-core-5.7 mysql-common mysql-server-5.7 mysql-server-core-5.7 mysql-server</span><br><span class="line">sudo apt update &amp;&amp; sudo apt dist-upgrade &amp;&amp; sudo apt autoremove &amp;&amp; sudo apt -f install</span><br><span class="line">sudo apt install mysql-server</span><br><span class="line"></span><br><span class="line">终端连接MySQL</span><br><span class="line">mysql -h 192.168.19.1 -u  root -p</span><br><span class="line"></span><br><span class="line">安装MYSQL-python</span><br><span class="line">ip install configparser</span><br><span class="line">sudo cp &#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;configparser.py &#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;ConfigParser.py</span><br><span class="line">Then try to install the MYSQL-python again. That Worked for me</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期培训-Redis</title>
    <url>//post/30045.html</url>
    <content><![CDATA[<h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="1、什么是-NoSQL"><a href="#1、什么是-NoSQL" class="headerlink" title="1、什么是 NoSQL"></a>1、什么是 NoSQL</h2><p>NoSQL泛指非关系型的数据库Not Only SQL。</p><h2 id="2、NoSQL-数据库的四大分类"><a href="#2、NoSQL-数据库的四大分类" class="headerlink" title="2、NoSQL 数据库的四大分类"></a>2、NoSQL 数据库的四大分类</h2><a id="more"></a>
<ul>
<li>键值（key-value）存储</li>
<li>列存储</li>
<li>文档数据库</li>
<li>图形数据库</li>
</ul>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>相关产品</strong></th>
<th><strong>典型应用</strong></th>
<th><strong>数据模型</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>键值（key-value)</td>
<td>Tokyo、  Cabinet/Tyrant、<strong>Redis</strong>、Voldemort、Berkeley DB、Memcached</td>
<td>内容缓存，主要用于处理大量数据的高访问负载</td>
<td>一系列键值对</td>
<td>快速查询</td>
<td>存储的数据缺少结构化</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra, HBase, Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td>文档数据库</td>
<td>CouchDB, <strong>MongoDB</strong></td>
<td>Web应用（与Key-Value类似，value是结构化的）</td>
<td>一系列键值对</td>
<td>数据结构要求不严格</td>
<td>查询性能不高，而且缺乏统一的查询语法</td>
</tr>
<tr>
<td>图形（Graph）数据库</td>
<td>Neo4J, InfoGrid, Infinite Graph</td>
<td>社交网络，推荐系统等。专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法</td>
<td>需要对整个图做计算才能得出结果，不容易做分布式集群方案</td>
</tr>
</tbody></table>
<p>MongoDB主要用来解决海量数据的访问效率问题，他是最像关系型数据库的非关系型数据库。</p>
<p>MongoDB 的主要适用场景为：数据不是特别重要（例如通知，推送这些），数据表结构变化较为频繁，数据量特别大，数据的并发性特别高，数据结构比较特别（例如地图的位置坐标），这些情况下用 MongoDB</p>
<p>Memcached主要是用来提高访问关系型数据库的效率问题，只局限于访问。</p>
<p>redis在我看来算是Memcached的升级版，加入了提高数据库写入的功能。</p>
<h2 id="3、NoSQL-的特点"><a href="#3、NoSQL-的特点" class="headerlink" title="3、NoSQL 的特点"></a>3、NoSQL 的特点</h2><ul>
<li><p>易扩展</p>
</li>
<li><p>灵活的数据模型</p>
</li>
<li><p>大数据量，高性能</p>
</li>
<li><p>高可用</p>
</li>
</ul>
<h2 id="4、为什么需要-NoSQL"><a href="#4、为什么需要-NoSQL" class="headerlink" title="4、为什么需要 NoSQL"></a>4、为什么需要 NoSQL</h2><p>随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其<br>是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅<br>速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！<br>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！<br>不需要多月的操作就可以横向扩展的 ！ Map&lt;String,Object&gt; 使用键值对来控制！</p>
<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p><img src="../static/img/%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD-Redis/image-20200726194039683.png" alt="image-20200726194039683"></p>
<ul>
<li><p>Redis（Remote Dictionary Server )，即远程字典服务</p>
</li>
<li><p>使用C语言编写的开源NoSQL数据库</p>
</li>
<li><p>高性能Key-Value内存数据库</p>
</li>
<li><p>支持将内存数据持久化到磁盘和即master-slave模式的数据备份（RDB和AOF）</p>
</li>
</ul>
<h1 id="5大基本数据类型"><a href="#5大基本数据类型" class="headerlink" title="5大基本数据类型"></a>5大基本数据类型</h1><ul>
<li><p>string（字符串）最基本的数据类型一个redis中字符串value最多可以是512M nx      set if    not exists</p>
</li>
<li><p>hash（Hash表）</p>
</li>
<li><p>list（列表）</p>
</li>
<li><p>set（无序集合）</p>
</li>
<li><p>zset(sorted set) （有序集合）</p>
<p>下面来对这5种数据结构类型作简单的介绍：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>结构类型</th>
<th align="left">结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td align="left">可以是字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)</td>
</tr>
<tr>
<td>List</td>
<td align="left">一个链表，链表上的每个节点都包含了一个字符串</td>
<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素</td>
</tr>
<tr>
<td>Set</td>
<td align="left">包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素</td>
</tr>
<tr>
<td>Hash</td>
<td align="left">包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所有键值对</td>
</tr>
<tr>
<td>Zset</td>
<td align="left">字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td>
</tr>
</tbody></table>
<h1 id="3种特殊数据类型"><a href="#3种特殊数据类型" class="headerlink" title="3种特殊数据类型"></a>3种特殊数据类型</h1><ul>
<li><p>Geospatial 地理位置</p>
<p>推算地理位置的信息，两地之间的距离，方圆几里的人</p>
</li>
<li><p>Hyperloglog</p>
<p>使用基数估计统计网站访客数</p>
</li>
<li><p>Bitmap</p>
<p>统计用户信息，活跃，不活跃！ 登录 、 未登录！签到打卡 两个状态的，都可以使用</p>
</li>
</ul>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li><p>set / get / del /getset</p>
</li>
<li><p>expire</p>
<p>​       Redis对于过期键有三种清除策略：</p>
<ul>
<li><p>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</p>
</li>
<li><p>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</p>
</li>
<li><p>当前已用内存超过maxmemory限定时，触发主动清理策略</p>
<p>maxmemory 当前已用内存超过maxmemory限定时，触发主动清理策略</p>
<ul>
<li>volatile-lru：只对设置了过期时间的key进行LRU（默认值）</li>
<li>allkeys-lru ： 删除lru算法的key</li>
<li>volatile-random：随机删除即将过期key</li>
<li>allkeys-random：随机删除</li>
<li>volatile-ttl ： 删除即将过期的</li>
<li>noeviction ： 永不过期，返回错误</li>
</ul>
</li>
</ul>
</li>
<li><p>exists</p>
</li>
<li><p>incr</p>
</li>
<li><p>setrange</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>缓存</li>
<li>限时业务的运用</li>
<li>计数器相关问题(网站访问统计)    </li>
<li>排行榜相关问题        </li>
<li>任务队列</li>
<li>分布式集群架构中的 session 分离</li>
</ul>
<h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## Redis 配置</span><br><span class="line">## Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">## Redis服务器地址</span><br><span class="line">spring.redis.host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">## Redis服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line"></span><br><span class="line">## Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"></span><br><span class="line">## 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">5000</span></span><br></pre></td></tr></table></figure>

<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>下面给出一些常用的时间格式</p>
<blockquote>
<p>“”0 30 1 ? * * “每天凌晨1:30执行</p>
<p>“0 0 12 * * ?” 每天中午十二点触发</p>
<p>“0 15 10 ? * *” 每天早上10：15触发</p>
<p>“0 15 10 * * ?” 每天早上10：15触发</p>
<p>“0 15 10 * * ? *” 每天早上10：15触发</p>
<p>“0 15 10 * * ? 2005” 2005年的每天早上10：15触发</p>
<p>“0 * 14 * * ?” 每天从下午2点开始到2点59分每分钟一次触发</p>
<p>“0 0/5 14 * * ?” 每天从下午2点开始到2：55分结束每5分钟一次触发</p>
<p>“0 0/5 14,18 * * ?” 每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发</p>
<p>“0 0-5 14 * * ?” 每天14:00至14:05每分钟一次触发</p>
<p>“0 10,44 14 ? 3 WED” 三月的每周三的14：10和14：44触发</p>
<p>“0 15 10 ? * MON-FRI” 每个周一、周二、周三、周四、周五的10：15触发</p>
</blockquote>
<h2 id="Session共享配置"><a href="#Session共享配置" class="headerlink" title="Session共享配置"></a>Session共享配置</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--session-redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Session存储设置"><a href="#Session存储设置" class="headerlink" title="Session存储设置"></a>Session存储设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">配置</span><br><span class="line">spring.session.store-type=redis</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Redis操作复杂数据类型"><a href="#Redis操作复杂数据类型" class="headerlink" title="Redis操作复杂数据类型"></a>Redis操作复杂数据类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ctgu.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"RediscaozSet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SetOperations operations=redisTemplate.opsForSet();</span><br><span class="line">        operations.add(<span class="string">"s1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">        operations.add(<span class="string">"s1"</span>,<span class="string">"v2"</span>);</span><br><span class="line">        Cursor&lt;String&gt;cursor=operations.scan(<span class="string">"s1"</span>, ScanOptions.NONE);</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext())&#123;</span><br><span class="line">            System.out.println(cursor.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"测试Hash"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String,String,String&gt; operations=redisTemplate.opsForHash();</span><br><span class="line">        HashMap map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"t1"</span>,<span class="string">"tv1"</span>);</span><br><span class="line">        operations.putAll(<span class="string">"h1"</span>,map);</span><br><span class="line">        operations.put(<span class="string">"h1"</span>,<span class="string">"k1"</span>,<span class="string">"v1"</span>);</span><br><span class="line">        operations.put(<span class="string">"h1"</span>,<span class="string">"k2"</span>,<span class="string">"v2"</span>);</span><br><span class="line">        operations.put(<span class="string">"h1"</span>,<span class="string">"k3"</span>,<span class="string">"m2"</span>);</span><br><span class="line">        Cursor&lt;Map.Entry&lt;String, String&gt;&gt; cursor=operations.scan(<span class="string">"h1"</span>, <span class="keyword">new</span> ScanOptions.ScanOptionsBuilder().match(<span class="string">"*k*"</span>).build());</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,String&gt; entry = cursor.next();</span><br><span class="line">            System.out.println(entry.getKey());;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(redisTemplate.opsForHash().entries("h1"));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="项目代码："><a href="#项目代码：" class="headerlink" title="项目代码："></a>项目代码：</h1><blockquote>
<p>GitHub：<a href="https://github.com/iboy-tech/2020-7-29-redis" target="_blank" rel="noopener">https://github.com/iboy-tech/2020-7-29-redis</a></p>
</blockquote>
<h1 id="关于Redis的参考"><a href="#关于Redis的参考" class="headerlink" title="关于Redis的参考"></a>关于Redis的参考</h1><blockquote>
<p>👉 Redis命令手册   <a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener">https://www.redis.net.cn/order/</a></p>
<p>👉 Redis练习平台  <a href="https://try.redis.io/" target="_blank" rel="noopener">https://try.redis.io/</a></p>
<p>👉 菜鸟教程    <a href="https://www.runoob.com/redis/redis-keys.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-keys.html</a>     </p>
<p> 👉 SpringBoot整合Redis    <a href="https://segmentfault.com/a/1190000017057950" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017057950</a>    </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>计图笔记</title>
    <url>//post/54196.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计网上课笔记</title>
    <url>//post/26893.html</url>
    <content><![CDATA[<p>一、路由器延时产生的原理</p><ol>
<li>F</li>
<li>T</li>
<li>F</li>
<li>T</li>
<li>F</li>
</ol><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311141649814.png" alt="image-20200311141649814"></p><p>!(C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318163503981.png)</p><a id="more"></a>



<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325150217014.png" alt="image-20200325150217014"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325151129632.png" alt="image-20200325151129632"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325151636163.png" alt="image-20200325151636163"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325153942603.png" alt="image-20200325153942603"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200401150950736.png" alt="image-20200401150950736"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200401153323093.png" alt="image-20200401153323093"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200406094331718.png" alt="image-20200406094331718"></p>
<h5 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520143943239.png" alt="image-20200520143943239" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520144031794.png" alt="image-20200520144031794" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520152927968.png" alt="image-20200520152927968" style="zoom: 50%;">

<h3 id="网络层是重点-2020-5-25"><a href="#网络层是重点-2020-5-25" class="headerlink" title="*****网络层是重点 2020-5-25"></a>*****网络层是重点 2020-5-25</h3><h2 id="课后习题-重点中的重点"><a href="#课后习题-重点中的重点" class="headerlink" title="课后习题-重点中的重点"></a>课后习题-重点中的重点</h2><p>重点</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200608091344784.png" alt="image-20200608091344784"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200608091532911.png" alt="image-20200608091532911"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200608091632710.png" alt="image-20200608091632710"></p>
<p>第6章除第6.1节外不会考。第8章不考。第9章除第9.1节外不考</p>
]]></content>
  </entry>
  <entry>
    <title>计网多选题</title>
    <url>//post/45275.html</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/01632f5ee1d9a79c8d3e55b48d34094b.png" alt="image-20200925093305196"></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/ff6d1a5b4fd27099bc4ef7dcd77c24f7.png" alt="image-20200925093412240"></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/048b29ada72b2a316ac9d4fa84f193bd.png" alt="image-20200925093802353"></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/6ce4fe65c881c0075492d63822061521.png" alt="image-20200925130413624"></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/cde1273413e872f651c369e0e9855816.png" alt="image-20200925131707840"></p><p><img src="C:/Users/Admin/AppData/Roaming/Typora/typora-user-images/image-20200925131816348.png" alt="image-20200925131816348"></p><p><img src="https://cdn.jsdelivr.net/gh/iboy-tech/static/images/2020/09/25/b3d81b127d6471b27ce4f40d6b693aa5.png" alt="image-20200925131944457"></p>]]></content>
  </entry>
  <entry>
    <title>验证码接码平台</title>
    <url>//post/26203.html</url>
    <content><![CDATA[<p>国外免费接码平台</p><p><a href="https://ch.freephonenum.com" target="_blank" rel="noopener">https://ch.freephonenum.com</a><br><a href="https://smsreceivefree.com" target="_blank" rel="noopener">https://smsreceivefree.com</a><br><a href="https://zh.mytrashmobile.com" target="_blank" rel="noopener">https://zh.mytrashmobile.com</a><br><a href="https://www.receive-sms-online.info" target="_blank" rel="noopener">https://www.receive-sms-online.info</a><br><a href="https://receiveasms.com" target="_blank" rel="noopener">https://receiveasms.com</a><br><a href="https://sms-online.co/receive-free-sms" target="_blank" rel="noopener">https://sms-online.co/receive-free-sms</a><br><a href="https://receive-sms.com" target="_blank" rel="noopener">https://receive-sms.com</a><br><a href="http://receivefreesms.com/" target="_blank" rel="noopener">http://receivefreesms.com/</a><br><a href="https://www.receivesmsonline.net/" target="_blank" rel="noopener">https://www.receivesmsonline.net/</a><br><a href="https://www.freeonlinephone.org/" target="_blank" rel="noopener">https://www.freeonlinephone.org/</a><br><a href="https://us-phone-number.com" target="_blank" rel="noopener">https://us-phone-number.com</a><br><a href="https://temporary-phone-number.com" target="_blank" rel="noopener">https://temporary-phone-number.com</a><br><a href="https://www.receivesms.co/" target="_blank" rel="noopener">https://www.receivesms.co/</a><br><a href="https://www.smstibo.com/" target="_blank" rel="noopener">https://www.smstibo.com/</a><br>PingMe 免费接码平台： <a href="https://pingme.tel/receive-sms-online-cn/" target="_blank" rel="noopener">https://pingme.tel/receive-sms-online-cn/</a><br><a href="http://receivefreesms.net/" target="_blank" rel="noopener">http://receivefreesms.net/</a><br><a href="http://receivesmsonline.in/" target="_blank" rel="noopener">http://receivesmsonline.in/</a><br><a href="https://sms-receive.net/" target="_blank" rel="noopener">https://sms-receive.net/</a><br><a href="https://www.receivesms.net/" target="_blank" rel="noopener">https://www.receivesms.net/</a><br><a href="https://www.yaysms.com/" target="_blank" rel="noopener">https://www.yaysms.com/</a><br>国内免费接码平台<br>超级云短信： <a href="http://www.bfkdim.com/" target="_blank" rel="noopener">http://www.bfkdim.com/</a><br>隐私短信：<a href="https://www.yinsiduanxin.com" target="_blank" rel="noopener">https://www.yinsiduanxin.com</a><br>云短信： <a href="https://www.materialtools.com/" target="_blank" rel="noopener">https://www.materialtools.com/</a><br>在线短信：<a href="http://www.smszk.com/" target="_blank" rel="noopener">http://www.smszk.com/</a><br>游客短信：<a href="https://www.visitorsms.com/cn" target="_blank" rel="noopener">https://www.visitorsms.com/cn</a><br>免费接码：<a href="https://www.becmd.com/" target="_blank" rel="noopener">https://www.becmd.com/</a><br>接码平台：<a href="http://www.114sim.com/" target="_blank" rel="noopener">http://www.114sim.com/</a> <a href="http://zg.114sim.com/" target="_blank" rel="noopener">http://zg.114sim.com/</a><br>云短信：<a href="https://yunduanxin.net/" target="_blank" rel="noopener">https://yunduanxin.net/</a><br>免费接码：<a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com/</a><br>掠影网络：<a href="https://zusms.com/receiving-sms" target="_blank" rel="noopener">https://zusms.com/receiving-sms</a><br>免费接码：<a href="https://www.shejiinn.com/" target="_blank" rel="noopener">https://www.shejiinn.com/</a><br>云接码：<a href="https://yunjiema.net" target="_blank" rel="noopener">https://yunjiema.net</a><br>云验证码：<a href="https://www.cnwml.com" target="_blank" rel="noopener">https://www.cnwml.com</a><br>免费接码：<a href="https://www.mffac.com" target="_blank" rel="noopener">https://www.mffac.com</a><br>接码科技免费平台：<a href="http://jiema.tech/sms/" target="_blank" rel="noopener">http://jiema.tech/sms/</a><br>接码号：<a href="https://jiemahao.com" target="_blank" rel="noopener">https://jiemahao.com</a><br>免费接码： <a href="https://mianfeijiema.com/" target="_blank" rel="noopener">https://mianfeijiema.com/</a><br>小鸟接码平台： <a href="http://www.xnsms.com/" target="_blank" rel="noopener">http://www.xnsms.com/</a><br>zero接码平台： <a href="https://xinghai.party/" target="_blank" rel="noopener">https://xinghai.party/</a><br>LotHelper： <a href="https://www.lothelper.com/cn" target="_blank" rel="noopener">https://www.lothelper.com/cn</a><br>免费接码平台： <a href="http://www.zsrq.net/" target="_blank" rel="noopener">http://www.zsrq.net/</a><br>国外收费接码平台<br><a href="https://sms-activate.ru/cn/" target="_blank" rel="noopener">https://sms-activate.ru/cn/</a> 1$起充，有中文页面<br><a href="https://5sim.net" target="_blank" rel="noopener">https://5sim.net</a><br>便宜国家：俄罗斯（ Russia ）罗马尼亚（ Romania ）菲律宾（ Philippines ）蒙古（ Mongolia ）拉脱维亚（ Latvia ）哈萨克斯坦（ Kazakhstan ）以色列（ Israel ）哥伦比亚（ Colombia ）<br><a href="http://smspva.com" target="_blank" rel="noopener">http://smspva.com</a> 这家起步就是0.1$，也就是最便宜7毛起步<br><a href="https://onlinesim.ru/zh" target="_blank" rel="noopener">https://onlinesim.ru/zh</a> 就俄罗斯的码便宜，起步0.1卢布<br><a href="https://www.jindousms.com/" target="_blank" rel="noopener">https://www.jindousms.com/</a> 国人开的国外号码接码平台，不做国内业务<br>TG群<br><a href="https://meiguojiema.com" target="_blank" rel="noopener">https://meiguojiema.com</a> 又一个国人开的国外接码，主要美国和加拿大号码<br><a href="https://www.smsjiema.com/" target="_blank" rel="noopener">https://www.smsjiema.com/</a> 美国实体卡号码，可以注册GV<br><a href="https://www.textverified.com/" target="_blank" rel="noopener">https://www.textverified.com/</a> 2刀起充，接码也挺贵的<br><a href="https://autofications.com/" target="_blank" rel="noopener">https://autofications.com/</a> 不算贵也不算便宜，最低$0.5一个码<br>国内收费接码平台<br>不确定什么时候会跑路，用多少充多少</p><a id="more"></a>

<p>米粒接码：<a href="http://www.yyyung.cn:9000/" target="_blank" rel="noopener">http://www.yyyung.cn:9000/</a> 【2元起充】<br>小米平台： <a href="http://mili02.com:9000/" target="_blank" rel="noopener">http://mili02.com:9000/</a> 两个是一样的，账号通用<br>可可码 ： <a href="http://www.hfsxf.com/" target="_blank" rel="noopener">http://www.hfsxf.com/</a><br>666验证码平台： <a href="http://www.666yzm.com/" target="_blank" rel="noopener">http://www.666yzm.com/</a><br>梦码平台：<a href="https://www.5151mma.com/" target="_blank" rel="noopener">https://www.5151mma.com/</a> 【1元起充】<br>接码科技：<a href="http://sim.vividly.cn/app/login.php?q=" target="_blank" rel="noopener">http://sim.vividly.cn/app/login.php?q=</a> 【1元起充，但要求账号余额大于10元才能使用接码】<br>路虎接码平台： <a href="http://www.luhujiema.com/" target="_blank" rel="noopener">http://www.luhujiema.com/</a><br>短信验证码接码平台 ：<a href="http://www.zhbmz.com" target="_blank" rel="noopener">http://www.zhbmz.com</a> 【起充不限】<br>飞享平台：<a href="http://feixiang.taixingwds.com/" target="_blank" rel="noopener">http://feixiang.taixingwds.com/</a><br>可可验证：<a href="http://www.hfsxf.com/oszc.html" target="_blank" rel="noopener">http://www.hfsxf.com/oszc.html</a><br>乌龟码短信验证码平台： <a href="http://wuguima.cn/" target="_blank" rel="noopener">http://wuguima.cn/</a><br>致敬先烈：<a href="http://www.myzjxl.com/" target="_blank" rel="noopener">http://www.myzjxl.com/</a><br>新码： <a href="http://www.xinma1.com:10001/zc.html" target="_blank" rel="noopener">http://www.xinma1.com:10001/zc.html</a><br>信鸽： <a href="http://html.reyne.cn/" target="_blank" rel="noopener">http://html.reyne.cn/</a><br>考拉云： <a href="http://www.kaolama.com/" target="_blank" rel="noopener">http://www.kaolama.com/</a><br>斑码： <a href="http://www.banma1024.net/reg/?wafcloud=1" target="_blank" rel="noopener">http://www.banma1024.net/reg/?wafcloud=1</a> 【10元起充】<br>魔卡接码平台： <a href="http://92moka.com/" target="_blank" rel="noopener">http://92moka.com/</a><br>爱码接码平台： <a href="http://www.aimajiema.com/" target="_blank" rel="noopener">http://www.aimajiema.com/</a><br>乐可可接码平台： <a href="http://lekeke.92zyb.com/" target="_blank" rel="noopener">http://lekeke.92zyb.com/</a><br>番茄接码： <a href="http://ifanqie.cc/" target="_blank" rel="noopener">http://ifanqie.cc/</a><br>迅捷验证码平台： <a href="http://xunjie.taixingwds.com/" target="_blank" rel="noopener">http://xunjie.taixingwds.com/</a><br>蓝狐数据共享平台： <a href="http://xiangjiuer.cn/" target="_blank" rel="noopener">http://xiangjiuer.cn/</a><br>码大师： <a href="http://mds.js.sdmpay.com/" target="_blank" rel="noopener">http://mds.js.sdmpay.com/</a><br>赵云接码平台： <a href="http://www.17lift.com/" target="_blank" rel="noopener">http://www.17lift.com/</a><br>神码： <a href="http://202.79.167.29/" target="_blank" rel="noopener">http://202.79.167.29/</a><br>新爱码：<a href="http://aima.taixingwds.com/" target="_blank" rel="noopener">http://aima.taixingwds.com/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>接码平台</tag>
      </tags>
  </entry>
  <entry>
    <title>钉钉网课批量下载脚本</title>
    <url>//post/49280.html</url>
    <content><![CDATA[<p>能够转化格式的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : dingtalk.py</span></span><br><span class="line"><span class="string">@Time    : 2020/4/25 16:40</span></span><br><span class="line"><span class="string">@Author  : iBoy</span></span><br><span class="line"><span class="string">@Email   : iboy@iboy.tech</span></span><br><span class="line"><span class="string">@Description : 钉钉中那些无法下载的网课，可以通过Python协程下载，不想在线观看，突破2倍速限制</span></span><br><span class="line"><span class="string">@Software: PyCharm</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">download_dir = <span class="string">"download"</span>  <span class="comment"># 存放的相对位置</span></span><br><span class="line">course_id = <span class="string">"##########"</span>  <span class="comment"># 课程代码</span></span><br><span class="line">auth_key = <span class="string">"################"</span>  <span class="comment"># 用户的唯一标示符</span></span><br><span class="line">total_time = <span class="string">"97:17"</span>  <span class="comment"># 网课的时长，这里是97分17秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_video</span><span class="params">(k)</span>:</span></span><br><span class="line">    base_url = <span class="string">"http://dtliving-pre.alicdn.com/live_hp/&#123;&#125;/&#123;&#125;.ts?auth_key=&#123;&#125;"</span>.format(course_id, k, auth_key)</span><br><span class="line">    print(base_url)</span><br><span class="line">    resp = requests.get(base_url)</span><br><span class="line">    <span class="keyword">with</span> open(download_dir + <span class="string">"/&#123;&#125;.ts"</span>.format(k), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(resp.content)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_video_num</span><span class="params">(play_time)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        play_time = play_time.split(<span class="string">":"</span>)</span><br><span class="line">        total_seconds = int(play_time[<span class="number">0</span>]) * <span class="number">60</span> + int(play_time[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"获取视频最大数量出现异常"</span>, str(e))</span><br><span class="line">    max_value = total_seconds // <span class="number">30</span></span><br><span class="line">    <span class="comment"># print(max_value)</span></span><br><span class="line">    <span class="keyword">while</span> max_value != <span class="number">0</span>:</span><br><span class="line">        base_url = <span class="string">"http://dtliving-pre.alicdn.com/live_hp/&#123;&#125;/&#123;&#125;.ts?auth_key=&#123;&#125;"</span>.format(course_id, max_value, auth_key)</span><br><span class="line">        resp = requests.get(base_url)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == <span class="number">404</span>:</span><br><span class="line">            max_value = max_value - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"共有"</span>, max_value, <span class="string">"个视频"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_videos</span><span class="params">(filename)</span>:</span></span><br><span class="line">    ts_list = os.listdir(download_dir)</span><br><span class="line">    ts_list.sort(key=<span class="keyword">lambda</span> x: int(x[:<span class="number">-3</span>]))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"video.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> ts_list:</span><br><span class="line">            f.write((<span class="string">"file "</span> + os.getcwd() + <span class="string">r'/&#123;&#125;/&#123;&#125;'</span>.format(download_dir, name) + <span class="string">"\n"</span>).replace(<span class="string">'\\'</span>, <span class="string">"/"</span>))</span><br><span class="line">    f.close()</span><br><span class="line">    cmd = <span class="string">"ffmpeg -f concat -safe 0 -i  video.txt -c copy &#123;&#125;/&#123;&#125;.mp4"</span>.format(download_dir, filename)</span><br><span class="line">    os.system(cmd)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> ts_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            os.remove(download_dir + <span class="string">"/"</span> + f)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(str(e))</span><br><span class="line">    os.remove(<span class="string">"video.txt"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(download_dir):</span><br><span class="line">        print(<span class="string">"文件夹不存在，新建文件夹download"</span>)</span><br><span class="line">        os.mkdir(download_dir)</span><br><span class="line">    max_video_num = get_max_video_num(total_time)</span><br><span class="line">    <span class="comment"># 定义协程方法</span></span><br><span class="line">    time_start = time.time()</span><br><span class="line">    download_queue = [gevent.spawn(download_video, k) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, max_video_num + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 添加协程任务，并且启动运行</span></span><br><span class="line">    gevent.joinall(download_queue)</span><br><span class="line">    time_end = time.time()</span><br><span class="line">    print(<span class="string">"下载用时："</span>, time_end - time_start, <span class="string">"s"</span>)</span><br><span class="line">    print(<span class="string">"下载完成正在合并..."</span>)</span><br><span class="line">    merge_videos(<span class="string">"计算机网络"</span>)</span><br><span class="line">    print(<span class="string">"合并完成！"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>requests+协程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="comment"># !/usr/bin/python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@File    : dingtalk.py</span></span><br><span class="line"><span class="string">@Time    : 2020/4/25 16:40</span></span><br><span class="line"><span class="string">@Author  : iBoy</span></span><br><span class="line"><span class="string">@Email   : iboy@iboy.tech</span></span><br><span class="line"><span class="string">@Description : 钉钉中那些无法下载的网课，可以通过Python协程下载，不想在线观看，突破2倍速限制</span></span><br><span class="line"><span class="string">@Software: PyCharm</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">download_dir = <span class="string">"download"</span>  <span class="comment"># 存放的相对位置</span></span><br><span class="line">course_id = <span class="string">"1111111111"</span>  <span class="comment"># 课程代码</span></span><br><span class="line"><span class="comment"># auth_key = "1111111111111111"  # 用户的唯一标示符</span></span><br><span class="line">total_time = <span class="string">"101:3"</span>  <span class="comment"># 网课的时长，这里是97分17秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_video</span><span class="params">(k)</span>:</span></span><br><span class="line">    base_url = <span class="string">"http://dtliving-pre.alicdn.com/live_hp/&#123;&#125;/&#123;&#125;.ts"</span>.format(course_id, k)</span><br><span class="line">    print(base_url)</span><br><span class="line">    resp = requests.get(base_url)</span><br><span class="line">    <span class="keyword">with</span> open(download_dir + <span class="string">"/%05d.ts"</span> % int(k), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(resp.content)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_video_num</span><span class="params">(play_time)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        play_time = play_time.split(<span class="string">":"</span>)</span><br><span class="line">        total_seconds = int(play_time[<span class="number">0</span>]) * <span class="number">60</span> + int(play_time[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"获取视频最大数量出现异常"</span>, str(e))</span><br><span class="line">    max_value = total_seconds // <span class="number">30</span></span><br><span class="line">    <span class="comment"># print(max_value)</span></span><br><span class="line">    <span class="keyword">while</span> max_value != <span class="number">0</span>:</span><br><span class="line">        base_url = <span class="string">"http://dtliving-pre.alicdn.com/live_hp/&#123;&#125;/&#123;&#125;.ts"</span>.format(course_id, max_value)</span><br><span class="line">        resp = requests.get(base_url)</span><br><span class="line">        <span class="keyword">if</span> resp.status_code == <span class="number">404</span>:</span><br><span class="line">            max_value = max_value - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"共有"</span>, max_value, <span class="string">"个视频"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_videos</span><span class="params">(filename)</span>:</span></span><br><span class="line">    ts_list = os.listdir(download_dir)</span><br><span class="line">    cmd=<span class="string">r"copy /b download\*.ts  download\&#123;&#125;.ts"</span>.format(filename)</span><br><span class="line">    os.system(cmd)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> ts_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            os.remove(download_dir + <span class="string">"/"</span> + f)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(str(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(download_dir):</span><br><span class="line">        print(<span class="string">"文件夹不存在，新建文件夹download"</span>)</span><br><span class="line">        os.mkdir(download_dir)</span><br><span class="line">    max_video_num = get_max_video_num(total_time)</span><br><span class="line">    <span class="comment"># 定义协程方法</span></span><br><span class="line">    time_start = time.time()</span><br><span class="line">    download_queue = [gevent.spawn(download_video, k) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, max_video_num + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 添加协程任务，并且启动运行</span></span><br><span class="line">    gevent.joinall(download_queue)</span><br><span class="line">    time_end = time.time()</span><br><span class="line">    print(<span class="string">"下载用时："</span>, time_end - time_start, <span class="string">"s"</span>)</span><br><span class="line">    print(<span class="string">"下载完成正在合并..."</span>)</span><br><span class="line">    merge_videos(<span class="string">"计算机网络"</span>)</span><br><span class="line">    print(<span class="string">"合并完成！"</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>设置npm安装的默认位置</title>
    <url>//post/18803.html</url>
    <content><![CDATA[<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix "C:\\Users\\Admin\\.nodejs\\node_global"</span><br><span class="line">npm config <span class="built_in">set</span> cache "C:\\Users\\Admin\\.nodejs\\node_cache"</span><br></pre></td></tr></table></figure><a id="more"></a>

<p><a href="https://blog.csdn.net/runonway/article/details/79501510" target="_blank" rel="noopener">https://blog.csdn.net/runonway/article/details/79501510</a></p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>计组上课笔记</title>
    <url>//post/64057.html</url>
    <content><![CDATA[<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311172912742.png" alt="image-20200311172912742"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311173153285.png" alt="image-20200311173153285"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311173109754.png" alt="image-20200311173109754"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311173328770.png" alt="image-20200311173328770"></p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200311173444648.png" alt="image-20200311173444648"></p><h4 id="6-1所讲的内容"><a href="#6-1所讲的内容" class="headerlink" title="6.1所讲的内容"></a>6.1所讲的内容</h4><p>1）计算机中数的表示<br>2）计算机的运算方法<br>3）运算器的设计</p><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200316161853030.png" alt="image-20200316161853030"></p><p>第6章计算机的运算方法<br>6.1无符号数和有符号数<br>6.2数的定点表示和浮点表示<br>6.3定点运算<br>6.4浮点四则运算<br>6.5算术逻辑单元</p><a id="more"></a>







<p>一、无符号数<br>二、有符号数<br>-1、机器数与真值<br>-2、原码表示法<br>-3、补码表示法<br>-4、反码表示法<br>-5、移码表示法<br>V定义<br>V特点<br>（举例</p>
<blockquote>
<p>机器数与真值的转抄</p>
</blockquote>
<p>6.1 -a3:</p>
<p>真值变为原码</p>
<p>65 补码表示</p>
<p>负数的补数</p>
<p>4位计数器模16</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200316163931075.png" alt="image-20200316163931075"></p>
<p>（1）减法运算可用补数替换成加法</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200316164144161.png" alt="image-20200316164144161"></p>
<p>（2）正数补数是本身</p>
<p>区分正数与负数的补数</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200316164437143.png" alt="image-20200316164437143"></p>
<p>（3）补码的定义</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200316171051915.png" alt="image-20200316171051915"></p>
<p>（4）求补码的快捷方式</p>
<p>68 </p>
<p>小数，整数的反码表示</p>
<p>反码和原码互求</p>
<p>原码，补码，反码三种机器码的小结</p>
<p>70</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318160854499.png" alt="image-20200318160854499"></p>
<p>数的定点表示和浮点表示</p>
<p>定点机<br>小数定点机<br>整数定点机</p>
<p>三种机器码的表示范围</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318161403949.png" alt="image-20200318161403949"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318162555213.png" alt="image-20200318162555213"></p>
<h1 id="74"><a href="#74" class="headerlink" title="74"></a>74</h1><h5 id="一、移位运算"><a href="#一、移位运算" class="headerlink" title="一、移位运算"></a>一、移位运算</h5><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318163141675.png" alt="image-20200318163141675"></p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318163529763.png" alt="image-20200318163529763"></p>
<h4 id="6-4浮点四则运算"><a href="#6-4浮点四则运算" class="headerlink" title="6.4浮点四则运算"></a>6.4浮点四则运算</h4><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200318170942736.png" alt="image-20200318170942736"></p>
<h2 id="3-23号（周一下午）"><a href="#3-23号（周一下午）" class="headerlink" title="3-23号（周一下午）"></a>3-23号（周一下午）</h2><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323160733856.png" alt="image-20200323160733856"></p>
<h4 id="1-ALU的外特性"><a href="#1-ALU的外特性" class="headerlink" title="1.ALU的外特性"></a>1.ALU的外特性</h4><p>ALU电路组合逻辑电路，没有记忆功能（四位ALU 74181）</p>
<p>算数运算和逻辑运算的硬件电路优化问题</p>
<p>快速进位链中的（并行加法器，串行进位链，并行进位链）</p>
<p>并行加法器通过逻辑表达式分析了进位的速度影响因素</p>
<p>串行进位链 （传送进位的电路，进位串行传送）</p>
<p>单重分组跳跃进位链</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323171802818.png" alt="image-20200323171802818"></p>
<h4 id="90"><a href="#90" class="headerlink" title="90"></a>90</h4><p>指令集-计算结软件和硬件的交接点</p>
<h4 id="7-1机器指令7-1-b"><a href="#7-1机器指令7-1-b" class="headerlink" title="7.1机器指令7.1-b"></a>7.1机器指令7.1-b</h4><p>扩展操作码技术</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323172219456.png" alt="image-20200323172219456"></p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323173009550.png" alt="image-20200323173009550" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323173025697.png" alt="image-20200323173025697" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323173209727.png" alt="image-20200323173209727" style="zoom:33%;">



<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200323173949933.png" alt="image-20200323173949933"></p>
<p>减少地址码长度可以增加寻址范围</p>
<h3 id="3-25周三下午"><a href="#3-25周三下午" class="headerlink" title="3-25周三下午"></a>3-25周三下午</h3><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325160236549.png" alt="image-20200325160236549"></p>
<p>操作数（指令要进行处理的那些数据）</p>
<p>一、操作数类型<br>地址 无符号整数<br>数字 定点数、浮点数、十进制数<br>字符 ASCII<br>逻辑数  逻辑运算 </p>
<p>二、数据在存储器中的存放方式</p>
<p>高字节放在低地址，低字节放在高地址</p>
<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200325160934885.png" alt="image-20200325160934885"></p>
<p>-字节编址，数据在存储器中的存放方式（存储字长64位，机器字长32位）</p>
<h5 id="a-从任意位置开始存储"><a href="#a-从任意位置开始存储" class="headerlink" title="a.从任意位置开始存储"></a>a.从任意位置开始存储</h5><p>​        从任意位置开始访问</p>
<p>​        优点：不浪费存储资源</p>
<p>​        缺点：读写控制比较复杂</p>
<h5 id="b-从一个存储字的起始位置开始访问"><a href="#b-从一个存储字的起始位置开始访问" class="headerlink" title="b.从一个存储字的起始位置开始访问"></a>b.从一个存储字的起始位置开始访问</h5><h5 id="c-边界对准方式–从地址的整数倍位置开始访问"><a href="#c-边界对准方式–从地址的整数倍位置开始访问" class="headerlink" title="c.边界对准方式–从地址的整数倍位置开始访问"></a>c.边界对准方式–从地址的整数倍位置开始访问</h5><p>​        边界对准方式一按地址的整数倍存储（前两种方法的折中）既可以完成访问也避免了存贮空间的浪费</p>
<h4 id="三、操作类型"><a href="#三、操作类型" class="headerlink" title="三、操作类型"></a>三、操作类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.数据传送</span><br><span class="line">源寄存器 寄存器</span><br><span class="line">目的寄存器 存储器</span><br><span class="line">例如 MOVE STORE</span><br><span class="line">2.算术逻辑操作</span><br><span class="line">加、减、乘、除、增1、减1、求补、浮点运算、</span><br><span class="line">与、或、非、异或、位操作、位测试、位清除</span><br><span class="line">3.移位操作</span><br><span class="line">算术移位 逻辑移位</span><br><span class="line">循环移位（带进位和不带进位）</span><br><span class="line">4.转移</span><br><span class="line">（1）无条件转移JMP</span><br><span class="line">（2）条件转移</span><br><span class="line">结果为零转（Z&#x3D;1）JZ 如</span><br><span class="line">结果溢出转（0&#x3D;1）J0</span><br><span class="line">结果有进位转（C&#x3D;1）JC</span><br><span class="line">跳过一条指令SKP</span><br><span class="line">（3）调用和返回</span><br><span class="line">（4）陷阱（Trap）与陷阱指令意外事故的中断</span><br><span class="line">一般不提供给用户直接使用在出现事故时，由CPU自动产生并执行（隐指令）</span><br><span class="line">（5）输入输出</span><br></pre></td></tr></table></figure>

<h4 id="7-3寻址方式（如何找到指令或者数据的地址）"><a href="#7-3寻址方式（如何找到指令或者数据的地址）" class="headerlink" title="7.3寻址方式（如何找到指令或者数据的地址）"></a>7.3寻址方式（如何找到指令或者数据的地址）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">寻址方式：</span><br><span class="line">	指令寻址</span><br><span class="line">	数据寻址</span><br></pre></td></tr></table></figure>

<h1 id="2020-3-30复习课"><a href="#2020-3-30复习课" class="headerlink" title="2020-3-30复习课"></a>2020-3-30复习课</h1><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200330172802435.png" alt="image-20200330172802435"></p>
<p>数据存储采用字节，数据传输采用比特</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视频1：哈夫曼编码</span><br><span class="line">视频2：创建哈夫曼树的过程</span><br><span class="line">https:&#x2F;&#x2F;v.youku.com&#x2F;v_show&#x2F;id_XMzUyMjQwNjM4OA&#x3D;&#x3D;.html</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;v.youku.com&#x2F;v_show&#x2F;id_XMzUyMjM5Njc4MA&#x3D;&#x3D;.html?spm&#x3D;a2hbt.13141534.app.5~5!2~5!2~5~5~5!2~5~5!2~5!2~5!2~5~5!10~A</span><br></pre></td></tr></table></figure>

<p>97</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">间接寻址</span><br><span class="line">有效地址由形式地址间接给出</span><br><span class="line">执行阶段2次访存</span><br><span class="line">可扩大寻址范围</span><br></pre></td></tr></table></figure>

<p>98堆栈寻址</p>
<p>99</p>
<p>主流CPU（IBM360,Inter8086）的指令集</p>
<p>一、设计指令格式时应考虑的各种因素</p>
<p>指令系统的兼容性和其他因素</p>
<p>100</p>
<p>RISC（精简指令集计算机）的产生和发展</p>
<p>80-20规律（执行频度高的简单指令，因复杂指令的存在，执行速度无法提高）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合指令长度固定、指令格式种类少、寻址方式少</span><br></pre></td></tr></table></figure>

<p>CISC（复杂指令集计算机）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">采用微程序控制器</span><br></pre></td></tr></table></figure>

<p>二者比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通用寄存器多，采用组合逻辑，便于实现指令流水</span><br><span class="line">RISC便于设计，可降低成本，提高可靠性</span><br><span class="line">RISC不易实现指令系统兼容</span><br></pre></td></tr></table></figure>



<p>CPU<code>的结构和功能</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU功能</span><br><span class="line">控制器的功能</span><br><span class="line">    取指令</span><br><span class="line">    分析指令</span><br><span class="line">    执行指令，发出各种操作命令</span><br><span class="line">    控制程序输入及结果的输出</span><br><span class="line">    总线管理</span><br><span class="line">    处理异常情况和特殊请求</span><br><span class="line">运算器功能</span><br><span class="line">	实现算术运算和逻辑运算</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU与系统总线</span><br><span class="line">    指令控制</span><br><span class="line">    操作控制</span><br><span class="line">    时间控制</span><br><span class="line">    数据加工</span><br><span class="line">    处理中断</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200406173443088.png" alt="image-20200406173443088"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.1 CPU的结构</span><br><span class="line">8.2指令周期</span><br><span class="line">8.3指令流水</span><br><span class="line">8.4中断系统</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU：Central Processing Unit，***处理机（器），是计算机硬件的核心部件，主要由运算器和控制器组成。</span><br><span class="line"></span><br><span class="line">PC：Program Counter，程序计数器，其功能是存放当前欲执行指令的地址，并可自动计数形成下一条指令地址。</span><br><span class="line"></span><br><span class="line">IR：Instruction Register，指令寄存器，其功能是存放当前正在执行的指令。</span><br><span class="line"></span><br><span class="line">CU：Control Unit，控制单元（部件），为控制器的核心部件，其功能是产生微操作命令序列。</span><br><span class="line"></span><br><span class="line">ALU：Arithmetic Logic Unit，算术逻辑运算单元，为运算器的核心部件，其功能是进行算术、逻辑运算。</span><br><span class="line"></span><br><span class="line">ACC：Accumulator，累加器，是运算器中既能存放运算前的操作数，又能存放运算结果的寄存器。</span><br><span class="line"></span><br><span class="line">MQ：Multiplier-Quotient Register，乘商寄存器，乘法运算时存放乘数、除法时存放商的寄存器。</span><br><span class="line"></span><br><span class="line">X：此字母没有专指的缩写含义，可以用作任一部件名，在此表示操作数寄存器，即运算器中工作寄存器之一，用来存放操作数；</span><br><span class="line"></span><br><span class="line">MAR：Memory Address Register，存储器地址寄存器，在主存中用来存放欲访问的存储单元的地址。</span><br><span class="line"></span><br><span class="line">MDR：Memory Data Register，存储器数据缓冲寄存器，在主存中用来存放从某单元读出、或要写入某存储单元的数据。</span><br><span class="line"></span><br><span class="line">I&#x2F;O：Input&#x2F;Output equipment，输入&#x2F;输出设备，为输入设备和输出设备的总称，用于计算机内部和外界信息的转换与传送。</span><br><span class="line"></span><br><span class="line">MIPS：Million Instruction Per Second，每秒执行百万条指令数，为计算机运算速度指标的一种计量单位。</span><br><span class="line">ABUS地址总线</span><br><span class="line">RD读信号引脚</span><br></pre></td></tr></table></figure>



<h4 id="4-8号周三下午"><a href="#4-8号周三下午" class="headerlink" title="4-8号周三下午"></a>4-8号周三下午</h4><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408160418596.png" alt="image-20200408160418596"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.指令周期的概念：</span><br><span class="line">	取出并执行一条指令所需的全部时间</span><br><span class="line">2.每条指令的执行周期的长度不同，NOP、ADD、MUL三种运算的周期不同</span><br><span class="line">3.具有间接寻址的指令周期</span><br><span class="line">4.带有中断中断周期的指令周期</span><br><span class="line">5.指令周期的流程</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408161254216.png" alt="image-20200408161254216" style="zoom: 33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6.CPU工作周期的标志</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408161549698.png" alt="image-20200408161549698" style="zoom:33%;">

<p>间址周期数据流</p>
<p>执行周期数据流</p>
<p>中断周期数据流</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408162735004.png" alt="image-20200408162735004" style="zoom:33%;">

<p>P104</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408163213048.png" alt="image-20200408163213048" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408163456311.png" alt="image-20200408163456311" style="zoom:33%;">

<p>P114</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408164017947.png" alt="image-20200408164017947" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408164225865.png" alt="image-20200408164225865" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408164516531.png" alt="image-20200408164516531" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408165442965.png" alt="image-20200408165442965" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200408170506480.png" alt="image-20200408170506480" style="zoom: 50%;">

<h3 id="4-13-周一下午"><a href="#4-13-周一下午" class="headerlink" title="4-13 周一下午"></a>4-13 周一下午</h3><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413160312832.png" alt="image-20200413160312832" style="zoom: 80%;">

<p>P106</p>
<p>一、流水线技术提高机器速度</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413160733969.png" alt="image-20200413160733969" style="zoom:33%;">

<p>二、系统的并发性</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413160959071.png" alt="image-20200413160959071" style="zoom:50%;">

<p>三、指令流水原理</p>
<p>1、指令串行执行</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413161231772.png" alt="image-20200413161231772" style="zoom:33%;">

<p>2、指令的二级流水</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413161311497.png" alt="image-20200413161311497" style="zoom:50%;">

<p>3.影响指令流水效率加倍的因素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）执行时间&gt;取指时间</span><br><span class="line">（2）条件转移指令必须等上条指令执行结束，才能确定下条指令的地址</span><br></pre></td></tr></table></figure>

<p>4.指令的六级流水</p>
<h4 id="P106"><a href="#P106" class="headerlink" title="P106"></a>P106</h4><p>三、影响指令流水线新能的因素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、结构相关不同指令争用同一功能部件产生资源冲突</span><br><span class="line">	解决办法：</span><br><span class="line">		.停顿</span><br><span class="line">        .指令存储器和数据存储器分开</span><br><span class="line">        .指令预取技术（适用于访存周期短的情况）</span><br><span class="line">2、数据相关</span><br><span class="line">	不同指令因重叠操作，可能改变操作数的读&#x2F;写访问顺序</span><br><span class="line">    .写后读相关（RAW）</span><br><span class="line">    .读后写相关（WAR）</span><br><span class="line">    .写后写相关（WAW）</span><br><span class="line">    解决办法</span><br><span class="line">    	.后推法</span><br><span class="line">    	.采用旁路技术</span><br><span class="line">3、控制相关</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200413171725944.png" alt="image-20200413171725944"></p>
<p>4-15周三下午</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流水线的性能</span><br><span class="line"></span><br><span class="line">	1、吞吐率：</span><br><span class="line">		最大吞吐率（Tpmax&#x3D;1&#x2F;Δt），实际吞吐率</span><br><span class="line">		</span><br><span class="line">	2、加速比(Sp)：</span><br><span class="line">		Sp&#x3D;没有采用流水线的时间&#x2F;采用流水线的时间</span><br><span class="line">		m条指令在流水线上执行所用时间</span><br><span class="line">		T&#x3D;m.Δt+(n-1)Δt</span><br><span class="line">	3、效率</span><br><span class="line">		流水线有建立时间和排空时间，无法之一工作</span><br><span class="line">		效率&#x3D;流水线处于工作时间的时空区&#x2F;流水线总的时空区</span><br><span class="line">		&#x3D;mnΔt&#x2F;m(m+n-1)Δt</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流水线的多发技术</span><br><span class="line">     1、超标量技术</span><br><span class="line">        每个时钟周期有多条指令</span><br><span class="line">     2、超流水线技术</span><br><span class="line">        在同一个时钟周期内再分段</span><br><span class="line">            不同的指令在同一个流水线中的信号不能叠加</span><br><span class="line">        不能调整指令的执行顺序</span><br><span class="line">            靠编译程序解决优化问题</span><br><span class="line">     3、超长指令字技术</span><br><span class="line">流水线的结构</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P120</span><br><span class="line">	10.1组合逻辑设计</span><br><span class="line">		组合逻辑控制单元框图</span><br><span class="line">			1、CPU的外特性</span><br><span class="line">			2、节拍信号</span><br><span class="line">		微操作节拍安排</span><br><span class="line">		间指周期微操作的节拍安排</span><br></pre></td></tr></table></figure>

<h2 id="4-20-周一下午"><a href="#4-20-周一下午" class="headerlink" title="4-20 周一下午"></a>4-20 周一下午</h2><p><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420160510548.png" alt="image-20200420160510548"></p>
<p>P121 组合逻辑设计10.1-b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.执行周期微操作的节拍安排</span><br><span class="line">5.中断周期微操作的节拍安排</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420161634842.png" alt="image-20200420161634842" style="zoom: 25%;">

<p>P122 组合逻辑设计10.1-c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三、组合逻辑设计步骤</span><br><span class="line">	1.列出操作时间表</span><br><span class="line">	2.写出微操作命令的最简表达式</span><br><span class="line">	3.画出逻辑图</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420162828772.png" alt="image-20200420162828772" style="zoom: 25%;">

<p>P123  微程序设计 10.2.1-а</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一、微程序设计思想的产生</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420163415695.png" alt="image-20200420163415695" style="zoom:25%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2·微程序控制单元的基本框图</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420163948575.png" alt="image-20200420163948575" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420164425092.png" alt="image-20200420164425092" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420170414492.png" alt="image-20200420170414492" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420170718399.png" alt="image-20200420170718399" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420171023120.png" alt="image-20200420171023120" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三、微指令的编码方式（控制方式）</span><br><span class="line">	1，直接编码（直接控制）方式</span><br><span class="line">	在微指令的操作控制字段中，</span><br><span class="line">	每一位代表一个微操作命令</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420171305770.png" alt="image-20200420171305770" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420171542522.png" alt="image-20200420171542522" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420171658947.png" alt="image-20200420171658947" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420171921617.png" alt="image-20200420171921617" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420172024740.png" alt="image-20200420172024740" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420172306249.png" alt="image-20200420172306249" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">五、微指令格式</span><br><span class="line">	1·水平型微指令</span><br><span class="line">		一次能定义并执行多个并行操作</span><br><span class="line">		如 直接编码、字段直接编码、字段间接编码、</span><br><span class="line">		直接和字段混合编码</span><br><span class="line">	2·垂直型微指令</span><br><span class="line">		类似机器指令操作码的方式</span><br><span class="line">		由微操作码字段规定微指令的功能</span><br><span class="line">	3，两种微指令格式的比较</span><br><span class="line">        （1）水平型微指令比垂直型微指令并行操作能力强灵活性强</span><br><span class="line">        （2）水平型微指令执行一条机器指令所要的微指令数目少，速度快</span><br><span class="line">        （3）水平型微指令用较短的微程序结构 取较长微指令结构</span><br></pre></td></tr></table></figure>

<h4 id="P126-10-2-微序设计-10-2-2-a"><a href="#P126-10-2-微序设计-10-2-2-a" class="headerlink" title="P126 10.2 微序设计 10.2.2-a"></a>P126 10.2 微序设计 10.2.2-a</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">六、静态微程序设计和动态微程序设计静态 </span><br><span class="line">	静态 微程序无须改变，采用ROM</span><br><span class="line">	动态 通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM</span><br><span class="line">	七、毫微程序设计</span><br><span class="line">		微程序设计 用微程序解释机器指令</span><br><span class="line">		毫微程序设计用毫微程序解释微指令</span><br><span class="line">		毫微指令与微指令的关系好比微指令与机器指令</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420173241208.png" alt="image-20200420173241208" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200420173402934.png" alt="image-20200420173402934" style="zoom:33%;">

<h3 id="4-22周三下午"><a href="#4-22周三下午" class="headerlink" title="4-22周三下午"></a>4-22周三下午</h3><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422160346271.png" alt="image-20200422160346271" style="zoom: 67%;">

<h5 id="P22"><a href="#P22" class="headerlink" title="P22"></a>P22</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.1概述</span><br><span class="line">一、存储器分类</span><br><span class="line">    1·按存储介质分类</span><br><span class="line">         （1）半导体存储器 TTL、MOS</span><br><span class="line">         ----------------------------</span><br><span class="line">         下面3个断电之后数据还在</span><br><span class="line">         （2）磁表面存储器 磁头、载磁体</span><br><span class="line">         （3）磁芯存储器 硬磁材料、环状元化</span><br><span class="line">         （4）光盘存储器 激光、磁光材料</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422161352767.png" alt="image-20200422161352767" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3个故事</span><br><span class="line">2·按存取方式分类</span><br><span class="line">（1）存取时间与物理地址无关（随机访问）</span><br><span class="line">    随机存储器 在程序的执行过程中可读可写</span><br><span class="line">    只读存储器 在程序的执行过程中只读</span><br><span class="line">（2）存取时间与物理地址有关（串行访问）</span><br><span class="line">    ·顺序存取存储器 磁带</span><br><span class="line">    直接存取存储器磁盘</span><br></pre></td></tr></table></figure>



<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422162434624.png" alt="image-20200422162434624" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422162758987.png" alt="image-20200422162758987" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422164207624.png" alt="image-20200422164207624" style="zoom:33%;">

<h5 id="P24主存（重点）"><a href="#P24主存（重点）" class="headerlink" title="P24主存（重点）"></a>P24主存（重点）</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422164441492.png" alt="image-20200422164441492" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422164726137.png" alt="image-20200422164726137" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422165119741.png" alt="image-20200422165119741" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200422165342812.png" alt="image-20200422165342812" style="zoom:33%;">

<h3 id="4-27-周一下午"><a href="#4-27-周一下午" class="headerlink" title="4-27 周一下午"></a>4-27 周一下午</h3><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427160807523.png" alt="image-20200427160807523" style="zoom: 50%;">

<p>P41</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427161115167.png" alt="image-20200427161115167" style="zoom: 33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间的局部性</span><br><span class="line">空间的局部性</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427161504937.png" alt="image-20200427161504937" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（2）命中与不命中</span><br><span class="line">    缓存共有C块</span><br><span class="line">    主存共有M块M&gt;&gt;C</span><br><span class="line">	命中 </span><br><span class="line">        主存块调入缓存</span><br><span class="line">        主存块与缓存块建立了对应关系</span><br><span class="line">用标记记录与某缓存块建立了对应关系的主存块</span><br><span class="line">    未命中 </span><br><span class="line">        主存块未调入缓存</span><br><span class="line">        主存块与缓存块未建立对应关系</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427161925996.png" alt="image-20200427161925996" style="zoom: 33%;">

<h4 id="P42"><a href="#P42" class="headerlink" title="P42"></a>P42</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427162058157.png" alt="image-20200427162058157" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427162558304.png" alt="image-20200427162558304" style="zoom:33%;">



<h4 id="P43"><a href="#P43" class="headerlink" title="P43"></a>P43</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427162823782.png" alt="image-20200427162823782" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200427163207877.png" alt="image-20200427163207877" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.Cache的改进</span><br><span class="line">（1）增加Cache的级数</span><br><span class="line">    片载（片内）Cache</span><br><span class="line">    片外Cache</span><br><span class="line">（2）统一缓存和分立缓存</span><br><span class="line">    指令Cache 数据Cache</span><br><span class="line">    与指令执行的控制方式有关 是否流水</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>处理器型号</th>
<th>指令</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>Pentium</td>
<td>8K指令Cache</td>
<td>8K数据Cache</td>
</tr>
<tr>
<td>PowerPC620</td>
<td>32K指令Cache</td>
<td>32K数据Cache</td>
</tr>
</tbody></table>
<h4 id="4-29"><a href="#4-29" class="headerlink" title="4-29"></a>4-29</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429160240698.png" alt="image-20200429160240698" style="zoom: 67%;">

<h5 id="4-3高速缓冲存储器"><a href="#4-3高速缓冲存储器" class="headerlink" title="4.3高速缓冲存储器"></a>4.3高速缓冲存储器</h5><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="二、Cache-主存的地址映射"><a href="#二、Cache-主存的地址映射" class="headerlink" title="二、Cache-主存的地址映射"></a>二、Cache-主存的地址映射</h5><p>​     .1、直接映射<br>​    .2、全相联映射<br>​    .3、组相联映射</p>
<h5 id="三、替换算法"><a href="#三、替换算法" class="headerlink" title="三、替换算法"></a>三、替换算法</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429161208503.png" alt="image-20200429161208503" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429161622846.png" alt="image-20200429161622846" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429162429454.png" alt="image-20200429162429454" style="zoom:33%;">

<h5 id="三、替换算法-1"><a href="#三、替换算法-1" class="headerlink" title="三、替换算法"></a>三、替换算法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1，先进先出（FIFO）算法</span><br><span class="line">2，近期最少使用（LRU）</span><br></pre></td></tr></table></figure>

<p>算法小结</p>
<blockquote>
<p>直接      某一主存块只能固定映射到某一缓存块</p>
<p>全相联     某一主存块能映射到任一缓存块</p>
<p>组相联     某一主存块只能映射到某一缓存组中的</p>
</blockquote>
<h4 id="P46"><a href="#P46" class="headerlink" title="P46"></a>P46</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163249867.png" alt="image-20200429163249867" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163412290.png" alt="image-20200429163412290" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163501723.png" alt="image-20200429163501723" style="zoom: 25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163632188.png" alt="image-20200429163632188" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163735566.png" alt="image-20200429163735566" style="zoom: 25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429163839754.png" alt="image-20200429163839754" style="zoom: 25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429164003377.png" alt="image-20200429164003377" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429164205356.png" alt="image-20200429164205356" style="zoom:25%;">

<h4 id="5月4日周一下午"><a href="#5月4日周一下午" class="headerlink" title="5月4日周一下午"></a>5月4日周一下午</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504160251531.png" alt="image-20200504160251531" style="zoom: 67%;">

<p>P25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2主存储器--半导体芯片简介</span><br><span class="line">    1，半导体存储芯片的基本结构</span><br><span class="line">    2，半导体存储芯片的译码驱动方式</span><br><span class="line">    	线选法</span><br><span class="line">    	重合法</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504161529571.png" alt="image-20200504161529571" style="zoom: 25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504161645361.png" alt="image-20200504161645361" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504161854111.png" alt="image-20200504161854111" style="zoom:25%;">

<h6 id="P26"><a href="#P26" class="headerlink" title="P26"></a>P26</h6><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504162600595.png" alt="image-20200504162600595" style="zoom: 33%;">



<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504162723706.png" alt="image-20200504162723706" style="zoom:25%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2主存储器</span><br><span class="line">一、概述</span><br><span class="line">二、半导体存储芯片简介</span><br><span class="line">三、随机存取存储器（RAM）</span><br><span class="line">四、只读存储器（ROM）</span><br><span class="line">五、存储器与CPU的连接</span><br><span class="line">六、存储器的校验</span><br><span class="line">七、提高访存速度的措施</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2主存储器-随机存取存储器</span><br><span class="line">1·静态RAM（SRAM）</span><br><span class="line">    保存0和1的原理是什么？</span><br><span class="line">    基本单元电路的构成是什么？</span><br><span class="line">    对单元电路如何读出和写入？</span><br><span class="line">    对单元电路如何读出和写入？</span><br><span class="line">    典型芯片的结构是很么样子的？</span><br><span class="line">    静态RAM芯片的如何进行读出和写入操作？</span><br><span class="line">.2.动态RAM（DRAM）</span><br><span class="line">.3·动态RAM和静态RAM的比较</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504163326122.png" alt="image-20200504163326122" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504163359955.png" alt="image-20200504163359955" style="zoom:25%;">

<h4 id="P27"><a href="#P27" class="headerlink" title="P27"></a>P27</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504163752336.png" alt="image-20200504163752336" style="zoom:25%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504164150027.png" alt="image-20200504164150027" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504164348739.png" alt="image-20200504164348739" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504170205694.png" alt="image-20200504170205694" style="zoom:33%;">

<h4 id="P28"><a href="#P28" class="headerlink" title="P28"></a>P28</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504170906046.png" alt="image-20200504170906046" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504171157128.png" alt="image-20200504171157128" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504171628459.png" alt="image-20200504171628459" style="zoom:33%;">

<h4 id="P29"><a href="#P29" class="headerlink" title="P29"></a>P29</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173040191.png" alt="image-20200504173040191" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173159964.png" alt="image-20200504173159964" style="zoom:33%;">

<h4 id="P30"><a href="#P30" class="headerlink" title="P30"></a>P30</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173401240.png" alt="image-20200504173401240" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173449286.png" alt="image-20200504173449286" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173532653.png" alt="image-20200504173532653" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200504173728639.png" alt="image-20200504173728639" style="zoom:33%;">

<h4 id="5-6周三下午"><a href="#5-6周三下午" class="headerlink" title="5-6周三下午"></a>5-6周三下午</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506160526054.png" alt="image-20200506160526054" style="zoom: 50%;">

<p>P31</p>
<p>重点：CPU和主存的连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.2主存储器--存储器与CPU的连接</span><br><span class="line">1，存储器容量的扩展v</span><br><span class="line">    位扩展</span><br><span class="line">    字扩展</span><br><span class="line">    同时扩展</span><br><span class="line">2，存储器与CPU的连接哈桶以</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506161249374.png" alt="image-20200506161249374" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506161538708.png" alt="image-20200506161538708" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506161945582.png" alt="image-20200506161945582" style="zoom:33%;">

<h3 id="P32"><a href="#P32" class="headerlink" title="P32"></a>P32</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU数据线条数多余存储器数据线条数的时候需要做为扩展</span><br></pre></td></tr></table></figure>



<p>2·存储器与CPU的连接</p>
<ul>
<li>（1）地址线的连接</li>
<li>（2）数据线的连接</li>
<li>（3）读/写命令线的连接</li>
<li>（4）片选线的连接</li>
<li>（5）合理选择存储芯片</li>
<li>（6）其他 时序、负载</li>
</ul>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506163503547.png" alt="image-20200506163503547" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506163814765.png" alt="image-20200506163814765" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506164059600.png" alt="image-20200506164059600" style="zoom:33%;">

<h3 id="P34"><a href="#P34" class="headerlink" title="P34"></a>P34</h3><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506164309744.png" alt="image-20200506164309744" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506165120127.png" alt="image-20200506165120127" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506165259750.png" alt="image-20200506165259750" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200506165501369.png" alt="image-20200506165501369" style="zoom:33%;">

<h3 id="5-11周一下午"><a href="#5-11周一下午" class="headerlink" title="5-11周一下午"></a>5-11周一下午</h3><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511160229601.png" alt="image-20200511160229601" style="zoom: 67%;">

<h5 id="P35"><a href="#P35" class="headerlink" title="P35"></a>P35</h5><p>4.2主存储器–存储器的校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">·1、为什么要对存储器的信息进行校验？</span><br><span class="line">.2、为了能够校验出信息是否正确，如何进行编码？</span><br><span class="line">.3、纠错或检错能力与什么因素有关？</span><br><span class="line">.4、校验出信息出错后是如何进行纠错？</span><br><span class="line">·5、除了我们教材上讲的校验码，你还知道哪些容错编码？，原理是什么？</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511161318503.png" alt="image-20200511161318503" style="zoom: 50%;">

<h5 id="P36"><a href="#P36" class="headerlink" title="P36"></a>P36</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511161632188.png" alt="image-20200511161632188" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511162642462.png" alt="image-20200511162642462" style="zoom:33%;">

<h5 id="P37"><a href="#P37" class="headerlink" title="P37"></a>P37</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511163420928.png" alt="image-20200511163420928" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511163639717.png" alt="image-20200511163639717" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511163744783.png" alt="image-20200511163744783" style="zoom:33%;">

<h5 id="P38"><a href="#P38" class="headerlink" title="P38"></a>P38</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511164105305.png" alt="image-20200511164105305" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511164944741.png" alt="image-20200511164944741" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511165326117.png" alt="image-20200511165326117" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511165709607.png" alt="image-20200511165709607" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511170034222.png" alt="image-20200511170034222" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511170420673.png" alt="image-20200511170420673" style="zoom:33%;">

<h5 id="P39"><a href="#P39" class="headerlink" title="P39"></a>P39</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511170958506.png" alt="image-20200511170958506" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511171319967.png" alt="image-20200511171319967" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511171405360.png" alt="image-20200511171405360" style="zoom:33%;">

<h5 id="P40"><a href="#P40" class="headerlink" title="P40"></a>P40</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511171749224.png" alt="image-20200511171749224" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511171917604.png" alt="image-20200511171917604" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511172129730.png" alt="image-20200511172129730" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200511172439315.png" alt="image-20200511172439315" style="zoom:33%;">

<h4 id="5-13-周三下午"><a href="#5-13-周三下午" class="headerlink" title="5-13 周三下午"></a>5-13 周三下午</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513160442752.png" alt="image-20200513160442752" style="zoom: 67%;">

<h5 id="P58"><a href="#P58" class="headerlink" title="P58"></a>P58</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.1.DMA和程序中断两种方式的数据通路</span><br><span class="line">.2.DMA与主存交换数据的三种方式</span><br><span class="line">（1）停止CPU访问主存</span><br><span class="line">（2）周期挪用（或周期窃取）</span><br><span class="line">（3）DMA与CPU交替访问</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513161311663.png" alt="image-20200513161311663" style="zoom:50%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513161428216.png" alt="image-20200513161428216" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（2）周期挪用（或周期窃取）</span><br><span class="line">DMA访问主存有三种可能</span><br><span class="line">    .CPU此时不访存</span><br><span class="line">    .CPU正在访存</span><br><span class="line">    .CPU与DMA同时请求访存</span><br><span class="line">此时CPU将总线控制权让给DMA</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513161726072.png" alt="image-20200513161726072" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513161858534.png" alt="image-20200513161858534" style="zoom:33%;">

<h5 id="P59"><a href="#P59" class="headerlink" title="P59"></a>P59</h5><p>二、DMA接口的功能和组成<br>1.DMA接口功能<br>（1）向CPU申请DMA传送<br>（2）处理总线控制权的转交</p>
<p>（3）管理系统总线、控制数据传送</p>
<p>   (4）确定数据传送的首地址和长度修正传送过程中的数据地址和长度</p>
<p>   (5）DMA传送结束时，给出操作完成信号</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513162529769.png" alt="image-20200513162529769" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513162743378.png" alt="image-20200513162743378" style="zoom:33%;">

<h5 id="P60"><a href="#P60" class="headerlink" title="P60"></a>P60</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.DMA传送过程</span><br><span class="line">预处理、数据传送、后处理</span><br><span class="line">（1）预处理</span><br><span class="line">    通过几条输入输出指令预置如下信息</span><br><span class="line">    通知DMA控制逻辑传送方向（入&#x2F;出）</span><br><span class="line">    设备地址-DMA的DAR</span><br><span class="line">    主存地址-DMA的AR</span><br><span class="line">    传送字数-DMA的WC</span><br></pre></td></tr></table></figure>



<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513164333083.png" alt="image-20200513164333083" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513165502106.png" alt="image-20200513165502106" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513165532270.png" alt="image-20200513165532270" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513165636727.png" alt="image-20200513165636727" style="zoom:33%;">



<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513170010055.png" alt="image-20200513170010055" style="zoom:33%;">



<h5 id="P61"><a href="#P61" class="headerlink" title="P61"></a>P61</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513170717939.png" alt="image-20200513170717939" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513170818184.png" alt="image-20200513170818184" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513171012122.png" alt="image-20200513171012122" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513171146499.png" alt="image-20200513171146499" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513171347695.png" alt="image-20200513171347695" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513171906636.png" alt="image-20200513171906636" style="zoom:33%;">

<h4 id="5-18周一下午"><a href="#5-18周一下午" class="headerlink" title="5-18周一下午"></a>5-18周一下午</h4><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518155608361.png" alt="image-20200518155608361" style="zoom: 80%;">

<h5 id="P47"><a href="#P47" class="headerlink" title="P47"></a>P47</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.1概述</span><br><span class="line">    一、输入输出系统的发展概况</span><br><span class="line">    二、输入输出系统的组成</span><br><span class="line">    三、1&#x2F;0设备与主机的联系方式</span><br><span class="line">    四、10设备与主机信息传送的控制</span><br><span class="line">    方式</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518163714667.png" alt="image-20200518163714667" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518164128130.png" alt="image-20200518164128130" style="zoom:33%;">

<h5 id="P48"><a href="#P48" class="headerlink" title="P48"></a>P48</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518162211530.png" alt="image-20200518162211530" style="zoom:33%;">



<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518162648732.png" alt="image-20200518162648732" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518162936937.png" alt="image-20200518162936937" style="zoom: 33%;">

<h5 id="P49"><a href="#P49" class="headerlink" title="P49"></a>P49</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">四、10设备与主机信息传送的控制方式</span><br><span class="line">    1.程序查询方式</span><br><span class="line">    2.程序中断方式</span><br><span class="line">    3.DMA方式</span><br></pre></td></tr></table></figure>

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518160753396.png" alt="image-20200518160753396" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518161420280.png" alt="image-20200518161420280" style="zoom: 33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518161710761.png" alt="image-20200518161710761" style="zoom: 33%;">

<h5 id="P50"><a href="#P50" class="headerlink" title="P50"></a>P50</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518164531139.png" alt="image-20200518164531139" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200518164827078.png" alt="image-20200518164827078" style="zoom:33%;">







<h5 id="5-20周三下午"><a href="#5-20周三下午" class="headerlink" title="5-20周三下午"></a>5-20周三下午</h5><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520160252230.png" alt="image-20200520160252230" style="zoom: 67%;">

<h6 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h6><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520160621218.png" alt="image-20200520160621218" style="zoom:33%;">

<p>总线的定义：</p>
<p>总线是公共的传输设备，英文名Bus</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520161047141.png" alt="image-20200520161047141" style="zoom:33%;">

<p>并行传输距离较短，在机箱内部</p>
<p>串行传输距离较长</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520161315569.png" alt="image-20200520161315569" style="zoom:33%;">

<p>会出现总线争用</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520161530547.png" alt="image-20200520161530547" style="zoom:50%;">

<p>外设和主存传输数据，会使CPU产生巨大的计算任务</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520161712513.png" alt="image-20200520161712513" style="zoom:33%;">

<h6 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h6><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520162054314.png" alt="image-20200520162054314" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520162120589.png" alt="image-20200520162120589" style="zoom:33%;">

<h6 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h6><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520162258684.png" alt="image-20200520162258684" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520162541566.png" alt="image-20200520162541566" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520162911481.png" alt="image-20200520162911481" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520163219175.png" alt="image-20200520163219175" style="zoom:33%;">



<h6 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h6><img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520163457895.png" alt="image-20200520163457895" style="zoom: 33%;">

<p>可以增加DMA直接存储总线</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520163610299.png" alt="image-20200520163610299" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520163709708.png" alt="image-20200520163709708" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520163843700.png" alt="image-20200520163843700" style="zoom:33%;">

<p>局部总线，系统总线CPU和主存可以进行数据交互，高速总线和低速总线对设备进行分类组织</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520164011697.png" alt="image-20200520164011697" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520164123324.png" alt="image-20200520164123324" style="zoom:33%;">

<p>高速总线和低速总线对设备进行分类组织</p>
<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520164221029.png" alt="image-20200520164221029" style="zoom:33%;">

<img src="C:%5CUsers%5CDefault%20Account%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200520164341413.png" alt="image-20200520164341413" style="zoom:33%;">

<p>PCI总线连接设备过多导致驱动能力不足的时候通过PCI桥进行扩展</p>
]]></content>
  </entry>
  <entry>
    <title>Linux调度算法</title>
    <url>//post/2783.html</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  kernel/sched/core.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Core kernel scheduler code and related syscalls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 1991-2002  Linus Torvalds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sched.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/nospec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kcov.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/scs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/switch_to.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/tlb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../workqueue_internal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../../fs/io-wq.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../smpboot.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pelt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"smp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_TRACE_POINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;trace/events/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Export tracepoints that act as a bare tracehook (ie: have no trace event</span></span><br><span class="line"><span class="comment"> * associated with them) to allow external modules to probe them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_cfs_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_rt_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_dl_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_irq_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(pelt_se_tp);</span><br><span class="line">EXPORT_TRACEPOINT_SYMBOL_GPL(sched_overutilized_tp);</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SCHED_DEBUG) &amp;&amp; defined(CONFIG_JUMP_LABEL)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Debugging: various feature bits</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If SCHED_DEBUG is disabled, each compilation unit has its own copy of</span></span><br><span class="line"><span class="comment"> * sysctl_sched_features, defined in sched.h, to allow constants propagation</span></span><br><span class="line"><span class="comment"> * at compile time and compiler optimization based on features default.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FEAT(name, enabled)	\</span></span><br><span class="line">	(<span class="number">1U</span>L &lt;&lt; __SCHED_FEAT_##name) * enabled |</span><br><span class="line">const_debug <span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_features =</span><br><span class="line">#include <span class="string">"features.h"</span></span><br><span class="line">	<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> SCHED_FEAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of tasks to iterate in a single balance run.</span></span><br><span class="line"><span class="comment"> * Limited because this is done with IRQs disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">const_debug <span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_nr_migrate = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * period over which we measure -rt task CPU usage in us.</span></span><br><span class="line"><span class="comment"> * default: 1s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_rt_period = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">__read_mostly <span class="keyword">int</span> scheduler_running;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * part of the period that we allow rt tasks to run in us.</span></span><br><span class="line"><span class="comment"> * default: 0.95s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> sysctl_sched_rt_runtime = <span class="number">950000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __task_rq_lock - lock the rq @p resides on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *__<span class="title">task_rq_lock</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">	__<span class="title">acquires</span>(<span class="title">rq</span>-&gt;<span class="title">lock</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		rq = task_rq(p);</span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) &#123;</span><br><span class="line">			rq_pin_lock(rq, rf);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (unlikely(task_on_rq_migrating(p)))</span><br><span class="line">			cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * task_rq_lock - lock p-&gt;pi_lock and lock the rq @p resides on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct rq *<span class="title">task_rq_lock</span><span class="params">(struct task_struct *p, struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(p-&gt;pi_lock)</span></span></span><br><span class="line"><span class="function">	__<span class="title">acquires</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf-&gt;flags);</span><br><span class="line">		rq = task_rq(p);</span><br><span class="line">		raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *	move_queued_task()		task_rq_lock()</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *	ACQUIRE (rq-&gt;lock)</span></span><br><span class="line"><span class="comment">		 *	[S] -&gt;on_rq = MIGRATING		[L] rq = task_rq()</span></span><br><span class="line"><span class="comment">		 *	WMB (__set_task_cpu())		ACQUIRE (rq-&gt;lock);</span></span><br><span class="line"><span class="comment">		 *	[S] -&gt;cpu = new_cpu		[L] task_rq()</span></span><br><span class="line"><span class="comment">		 *					[L] -&gt;on_rq</span></span><br><span class="line"><span class="comment">		 *	RELEASE (rq-&gt;lock)</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If we observe the old CPU in task_rq_lock(), the acquire of</span></span><br><span class="line"><span class="comment">		 * the old rq-&gt;lock will fully serialize against the stores.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If we observe the new CPU in task_rq_lock(), the address</span></span><br><span class="line"><span class="comment">		 * dependency headed by '[L] rq = task_rq()' and the acquire</span></span><br><span class="line"><span class="comment">		 * will pair with the WMB to ensure we then also see migrating.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (likely(rq == task_rq(p) &amp;&amp; !task_on_rq_migrating(p))) &#123;</span><br><span class="line">			rq_pin_lock(rq, rf);</span><br><span class="line">			<span class="keyword">return</span> rq;</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, rf-&gt;flags);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (unlikely(task_on_rq_migrating(p)))</span><br><span class="line">			cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RQ-clock updating methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_rq_clock_task</span><span class="params">(struct rq *rq, s64 delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In theory, the compile should just see 0 here, and optimize out the call</span></span><br><span class="line"><span class="comment"> * to sched_rt_avg_update. But I don't trust it...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	s64 __maybe_unused steal = <span class="number">0</span>, irq_delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_TIME_ACCOUNTING</span></span><br><span class="line">	irq_delta = irq_time_read(cpu_of(rq)) - rq-&gt;prev_irq_time;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since irq_time is only updated on &#123;soft,&#125;irq_exit, we might run into</span></span><br><span class="line"><span class="comment">	 * this case when a previous update_rq_clock() happened inside a</span></span><br><span class="line"><span class="comment">	 * &#123;soft,&#125;irq region.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * When this happens, we stop -&gt;clock_task and only update the</span></span><br><span class="line"><span class="comment">	 * prev_irq_time stamp to account for the part that fit, so that a next</span></span><br><span class="line"><span class="comment">	 * update will consume the rest. This ensures -&gt;clock_task is</span></span><br><span class="line"><span class="comment">	 * monotonic.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * It does however cause some slight miss-attribution of &#123;soft,&#125;irq</span></span><br><span class="line"><span class="comment">	 * time, a more accurate solution would be to update the irq_time using</span></span><br><span class="line"><span class="comment">	 * the current rq-&gt;clock timestamp, except that would require using</span></span><br><span class="line"><span class="comment">	 * atomic ops.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (irq_delta &gt; delta)</span><br><span class="line">		irq_delta = delta;</span><br><span class="line"></span><br><span class="line">	rq-&gt;prev_irq_time += irq_delta;</span><br><span class="line">	delta -= irq_delta;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PARAVIRT_TIME_ACCOUNTING</span></span><br><span class="line">	<span class="keyword">if</span> (static_key_false((&amp;paravirt_steal_rq_enabled))) &#123;</span><br><span class="line">		steal = paravirt_steal_clock(cpu_of(rq));</span><br><span class="line">		steal -= rq-&gt;prev_steal_time_rq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(steal &gt; delta))</span><br><span class="line">			steal = delta;</span><br><span class="line"></span><br><span class="line">		rq-&gt;prev_steal_time_rq += steal;</span><br><span class="line">		delta -= steal;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_task += delta;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_SCHED_AVG_IRQ</span></span><br><span class="line">	<span class="keyword">if</span> ((irq_delta + steal) &amp;&amp; sched_feat(NONTASK_CAPACITY))</span><br><span class="line">		update_irq_load_avg(rq, irq_delta + steal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	update_rq_clock_pelt(rq, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_rq_clock</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;clock_update_flags &amp; RQCF_ACT_SKIP)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(WARN_DOUBLE_CLOCK))</span><br><span class="line">		SCHED_WARN_ON(rq-&gt;clock_update_flags &amp; RQCF_UPDATED);</span><br><span class="line">	rq-&gt;clock_update_flags |= RQCF_UPDATED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	delta = sched_clock_cpu(cpu_of(rq)) - rq-&gt;clock;</span><br><span class="line">	<span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	rq-&gt;clock += delta;</span><br><span class="line">	update_rq_clock_task(rq, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rq_csd_init(struct rq *rq, <span class="keyword">call_single_data_t</span> *csd, <span class="keyword">smp_call_func_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	csd-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	csd-&gt;func = func;</span><br><span class="line">	csd-&gt;info = rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_HRTICK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Use HR-timers to deliver accurate preemption points.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hrtick_clear</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hrtimer_active(&amp;rq-&gt;hrtick_timer))</span><br><span class="line">		hrtimer_cancel(&amp;rq-&gt;hrtick_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * High-resolution timer tick.</span></span><br><span class="line"><span class="comment"> * Runs from hardirq context with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> hrtimer_restart <span class="title">hrtick</span><span class="params">(struct hrtimer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">container_of</span>(<span class="title">timer</span>, <span class="title">struct</span> <span class="title">rq</span>, <span class="title">hrtick_timer</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(cpu_of(rq) != smp_processor_id());</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	rq-&gt;curr-&gt;sched_class-&gt;task_tick(rq, rq-&gt;curr, <span class="number">1</span>);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> HRTIMER_NORESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __hrtick_restart(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">timer</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">hrtick_timer</span>;</span></span><br><span class="line"></span><br><span class="line">	hrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * called from hardirq (IPI) context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __hrtick_start(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">arg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	__hrtick_restart(rq);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called to set the hrtick timer state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * called with rq-&gt;lock held and irqs disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hrtick_start</span><span class="params">(struct rq *rq, u64 delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">timer</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">hrtick_timer</span>;</span></span><br><span class="line">	<span class="keyword">ktime_t</span> time;</span><br><span class="line">	s64 delta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't schedule slices shorter than 10000ns, that just</span></span><br><span class="line"><span class="comment">	 * doesn't make sense and can cause timer DoS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	delta = <span class="keyword">max_t</span>(s64, delay, <span class="number">10000L</span>L);</span><br><span class="line">	time = ktime_add_ns(timer-&gt;base-&gt;get_time(), delta);</span><br><span class="line"></span><br><span class="line">	hrtimer_set_expires(timer, time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq == this_rq())</span><br><span class="line">		__hrtick_restart(rq);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		smp_call_function_single_async(cpu_of(rq), &amp;rq-&gt;hrtick_csd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called to set the hrtick timer state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * called with rq-&gt;lock held and irqs disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hrtick_start</span><span class="params">(struct rq *rq, u64 delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't schedule slices shorter than 10000ns, that just</span></span><br><span class="line"><span class="comment">	 * doesn't make sense. Rely on vruntime for fairness.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	delay = <span class="keyword">max_t</span>(u64, delay, <span class="number">10000L</span>L);</span><br><span class="line">	hrtimer_start(&amp;rq-&gt;hrtick_timer, ns_to_ktime(delay),</span><br><span class="line">		      HRTIMER_MODE_REL_PINNED_HARD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hrtick_rq_init</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq_csd_init(rq, &amp;rq-&gt;hrtick_csd, __hrtick_start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	hrtimer_init(&amp;rq-&gt;hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);</span><br><span class="line">	rq-&gt;hrtick_timer.function = hrtick;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* CONFIG_SCHED_HRTICK */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hrtick_clear</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hrtick_rq_init</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_SCHED_HRTICK */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cmpxchg based fetch_or, macro so it works for different integer types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fetch_or(ptr, mask)						\</span></span><br><span class="line">	(&#123;								\</span><br><span class="line">		typeof(ptr) _ptr = (ptr);				\</span><br><span class="line">		typeof(mask) _mask = (mask);				\</span><br><span class="line">		typeof(*_ptr) _old, _val = *_ptr;			\</span><br><span class="line">									\</span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;						\</span><br><span class="line">			_old = cmpxchg(_ptr, _val, _val | _mask);	\</span><br><span class="line">			<span class="keyword">if</span> (_old == _val)				\</span><br><span class="line">				<span class="keyword">break</span>;					\</span><br><span class="line">			_val = _old;					\</span><br><span class="line">		&#125;							\</span><br><span class="line">	_old;								\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP) &amp;&amp; defined(TIF_POLLING_NRFLAG)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Atomically set TIF_NEED_RESCHED and test for TIF_POLLING_NRFLAG,</span></span><br><span class="line"><span class="comment"> * this avoids any races wrt polling state changes and thereby avoids</span></span><br><span class="line"><span class="comment"> * spurious IPIs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_and_not_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> = <span class="title">task_thread_info</span>(<span class="title">p</span>);</span></span><br><span class="line">	<span class="keyword">return</span> !(fetch_or(&amp;ti-&gt;flags, _TIF_NEED_RESCHED) &amp; _TIF_POLLING_NRFLAG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Atomically set TIF_NEED_RESCHED if TIF_POLLING_NRFLAG is set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this returns true, then the idle task promises to call</span></span><br><span class="line"><span class="comment"> * sched_ttwu_pending() and reschedule soon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_if_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> = <span class="title">task_thread_info</span>(<span class="title">p</span>);</span></span><br><span class="line">	typeof(ti-&gt;flags) old, val = READ_ONCE(ti-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(val &amp; _TIF_POLLING_NRFLAG))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; _TIF_NEED_RESCHED)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		old = cmpxchg(&amp;ti-&gt;flags, val, val | _TIF_NEED_RESCHED);</span><br><span class="line">		<span class="keyword">if</span> (old == val)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		val = old;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_and_not_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_tsk_need_resched(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">set_nr_if_polling</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __wake_q_add(struct wake_q_head *head, struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> *<span class="title">node</span> = &amp;<span class="title">task</span>-&gt;<span class="title">wake_q</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Atomically grab the task, if -&gt;wake_q is !nil already it means</span></span><br><span class="line"><span class="comment">	 * its already queued (either by us or someone else) and will get the</span></span><br><span class="line"><span class="comment">	 * wakeup due to that.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In order to ensure that a pending wakeup will observe our pending</span></span><br><span class="line"><span class="comment">	 * state, even in the failed case, an explicit smp_mb() must be used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	<span class="keyword">if</span> (unlikely(cmpxchg_relaxed(&amp;node-&gt;next, <span class="literal">NULL</span>, WAKE_Q_TAIL)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The head is context local, there can be no concurrency.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*head-&gt;lastp = node;</span><br><span class="line">	head-&gt;lastp = &amp;node-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_q_add() - queue a wakeup for 'later' waking.</span></span><br><span class="line"><span class="comment"> * @head: the wake_q_head to add @task to</span></span><br><span class="line"><span class="comment"> * @task: the task to queue for 'later' wakeup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue a task for later wakeup, most likely by the wake_up_q() call in the</span></span><br><span class="line"><span class="comment"> * same context, _HOWEVER_ this is not guaranteed, the wakeup can come</span></span><br><span class="line"><span class="comment"> * instantly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be used as-if it were wake_up_process(); IOW the task</span></span><br><span class="line"><span class="comment"> * must be ready to be woken at this location.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_q_add</span><span class="params">(struct wake_q_head *head, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__wake_q_add(head, task))</span><br><span class="line">		get_task_struct(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_q_add_safe() - safely queue a wakeup for 'later' waking.</span></span><br><span class="line"><span class="comment"> * @head: the wake_q_head to add @task to</span></span><br><span class="line"><span class="comment"> * @task: the task to queue for 'later' wakeup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Queue a task for later wakeup, most likely by the wake_up_q() call in the</span></span><br><span class="line"><span class="comment"> * same context, _HOWEVER_ this is not guaranteed, the wakeup can come</span></span><br><span class="line"><span class="comment"> * instantly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function must be used as-if it were wake_up_process(); IOW the task</span></span><br><span class="line"><span class="comment"> * must be ready to be woken at this location.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is essentially a task-safe equivalent to wake_q_add(). Callers</span></span><br><span class="line"><span class="comment"> * that already hold reference to @task can call the 'safe' version and trust</span></span><br><span class="line"><span class="comment"> * wake_q to do the right thing depending whether or not the @task is already</span></span><br><span class="line"><span class="comment"> * queued for wakeup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_q_add_safe</span><span class="params">(struct wake_q_head *head, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__wake_q_add(head, task))</span><br><span class="line">		put_task_struct(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_q</span><span class="params">(struct wake_q_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> *<span class="title">node</span> = <span class="title">head</span>-&gt;<span class="title">first</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (node != WAKE_Q_TAIL) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">		task = container_of(node, struct task_struct, wake_q);</span><br><span class="line">		BUG_ON(!task);</span><br><span class="line">		<span class="comment">/* Task can safely be re-inserted now: */</span></span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		task-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * wake_up_process() executes a full barrier, which pairs with</span></span><br><span class="line"><span class="comment">		 * the queueing in wake_q_add() so as not to miss wakeups.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		wake_up_process(task);</span><br><span class="line">		put_task_struct(task);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resched_curr - mark rq's current task 'to be rescheduled now'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP this means the setting of the need_resched flag, on SMP it</span></span><br><span class="line"><span class="comment"> * might also involve a cross-CPU call to trigger the scheduler on</span></span><br><span class="line"><span class="comment"> * the target CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resched_curr</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_tsk_need_resched(curr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	cpu = cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resched_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (cpu_online(cpu) || cpu == smp_processor_id())</span><br><span class="line">		resched_curr(rq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In the semi idle case, use the nearest busy CPU for migrating timers</span></span><br><span class="line"><span class="comment"> * from an idle CPU.  This is good for power-savings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We don't do similar optimization for completely idle system, as</span></span><br><span class="line"><span class="comment"> * selecting an idle CPU will add more delays to the timers than intended</span></span><br><span class="line"><span class="comment"> * (as that CPU's timer base may not be uptodate wrt jiffies etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nohz_timer_target</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, cpu = smp_processor_id(), default_cpu = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TIMER)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!idle_cpu(cpu))</span><br><span class="line">			<span class="keyword">return</span> cpu;</span><br><span class="line">		default_cpu = cpu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	for_each_domain(cpu, sd) &#123;</span><br><span class="line">		for_each_cpu_and(i, sched_domain_span(sd),</span><br><span class="line">			housekeeping_cpumask(HK_FLAG_TIMER)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cpu == i)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!idle_cpu(i)) &#123;</span><br><span class="line">				cpu = i;</span><br><span class="line">				<span class="keyword">goto</span> unlock;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (default_cpu == <span class="number">-1</span>)</span><br><span class="line">		default_cpu = housekeeping_any_cpu(HK_FLAG_TIMER);</span><br><span class="line">	cpu = default_cpu;</span><br><span class="line">unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When add_timer_on() enqueues a timer into the timer wheel of an</span></span><br><span class="line"><span class="comment"> * idle CPU then this timer might expire before the next timer event</span></span><br><span class="line"><span class="comment"> * which is scheduled to wake up that CPU. In case of a completely</span></span><br><span class="line"><span class="comment"> * idle system the next event might even be infinite time into the</span></span><br><span class="line"><span class="comment"> * future. wake_up_idle_cpu() ensures that the CPU is woken up and</span></span><br><span class="line"><span class="comment"> * leaves the inner idle loop so the newly added timer is taken into</span></span><br><span class="line"><span class="comment"> * account when the CPU goes back to idle and evaluates the timer</span></span><br><span class="line"><span class="comment"> * wheel for the next timer event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wake_up_idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpu == smp_processor_id())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">wake_up_full_nohz_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We just need the target to call irq_exit() and re-evaluate</span></span><br><span class="line"><span class="comment">	 * the next tick. The nohz full kick at least implies that.</span></span><br><span class="line"><span class="comment">	 * If needed we can still optimize that later with an</span></span><br><span class="line"><span class="comment">	 * empty IRQ.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpu_is_offline(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/* Don't try to wake offline CPUs. */</span></span><br><span class="line">	<span class="keyword">if</span> (tick_nohz_full_cpu(cpu)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cpu != smp_processor_id() ||</span><br><span class="line">		    tick_nohz_tick_stopped())</span><br><span class="line">			tick_nohz_full_kick_cpu(cpu);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wake up the specified CPU.  If the CPU is going offline, it is the</span></span><br><span class="line"><span class="comment"> * caller's responsibility to deal with the lost wakeup, for example,</span></span><br><span class="line"><span class="comment"> * by hooking into the CPU_DEAD notifier like timers and hrtimers do.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_nohz_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wake_up_full_nohz_cpu(cpu))</span><br><span class="line">		wake_up_idle_cpu(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nohz_csd_func</span><span class="params">(<span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu = cpu_of(rq);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release the rq::nohz_csd.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	flags = atomic_fetch_andnot(NOHZ_KICK_MASK, nohz_flags(cpu));</span><br><span class="line">	WARN_ON(!(flags &amp; NOHZ_KICK_MASK));</span><br><span class="line"></span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;idle_balance &amp;&amp; !need_resched()) &#123;</span><br><span class="line">		rq-&gt;nohz_idle_balance = flags;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_COMMON */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sched_can_stop_tick</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fifo_nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deadline tasks, even if single, need the tick */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;dl.dl_nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there are more than one RR tasks, we need the tick to effect the</span></span><br><span class="line"><span class="comment">	 * actual RR behaviour.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rt.rr_nr_running) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;rt.rr_nr_running == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there's no RR tasks, but FIFO tasks, we can skip the tick, no</span></span><br><span class="line"><span class="comment">	 * forced preemption between FIFO tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fifo_nr_running = rq-&gt;rt.rt_nr_running - rq-&gt;rt.rr_nr_running;</span><br><span class="line">	<span class="keyword">if</span> (fifo_nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;</span></span><br><span class="line"><span class="comment">	 * if there's more than one we need the tick for involuntary</span></span><br><span class="line"><span class="comment">	 * preemption.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NO_HZ_FULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) &amp;&amp; \</span></span><br><span class="line">			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Iterate task_group tree rooted at *from, calling @down when first entering a</span></span><br><span class="line"><span class="comment"> * node and @up when leaving it for the final time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Caller must hold rcu_lock or sufficient equivalent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">walk_tg_tree_from</span><span class="params">(struct task_group *from,</span></span></span><br><span class="line"><span class="function"><span class="params">			     tg_visitor down, tg_visitor up, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span>, *<span class="title">child</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	parent = from;</span><br><span class="line"></span><br><span class="line">down:</span><br><span class="line">	ret = (*down)(parent, data);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	list_for_each_entry_rcu(child, &amp;parent-&gt;children, siblings) &#123;</span><br><span class="line">		parent = child;</span><br><span class="line">		<span class="keyword">goto</span> down;</span><br><span class="line"></span><br><span class="line">up:</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = (*up)(parent, data);</span><br><span class="line">	<span class="keyword">if</span> (ret || parent == from)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	child = parent;</span><br><span class="line">	parent = parent-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		<span class="keyword">goto</span> up;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tg_nop</span><span class="params">(struct task_group *tg, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_load_weight</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> update_load)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio = p-&gt;static_prio - MAX_RT_PRIO;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> *<span class="title">load</span> = &amp;<span class="title">p</span>-&gt;<span class="title">se</span>.<span class="title">load</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SCHED_IDLE tasks get minimal weight:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_idle_policy(p)) &#123;</span><br><span class="line">		load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);</span><br><span class="line">		load-&gt;inv_weight = WMULT_IDLEPRIO;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * SCHED_OTHER tasks have to update their load when changing their</span></span><br><span class="line"><span class="comment">	 * weight</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (update_load &amp;&amp; p-&gt;sched_class == &amp;fair_sched_class) &#123;</span><br><span class="line">		reweight_task(p, prio);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		load-&gt;weight = scale_load(sched_prio_to_weight[prio]);</span><br><span class="line">		load-&gt;inv_weight = sched_prio_to_wmult[prio];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Serializes updates of utilization clamp values</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The (slow-path) user-space triggers utilization clamp value updates which</span></span><br><span class="line"><span class="comment"> * can require updates on (fast-path) scheduler's data structures used to</span></span><br><span class="line"><span class="comment"> * support enqueue/dequeue operations.</span></span><br><span class="line"><span class="comment"> * While the per-CPU rq lock protects fast-path update operations, user-space</span></span><br><span class="line"><span class="comment"> * requests are serialized using a mutex to reduce the risk of conflicting</span></span><br><span class="line"><span class="comment"> * updates or API abuses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(uclamp_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Max allowed minimum utilization */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_uclamp_util_min = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Max allowed maximum utilization */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sysctl_sched_uclamp_util_max = SCHED_CAPACITY_SCALE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* All clamps are required to be less or equal than these values */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uclamp_default</span>[<span class="title">UCLAMP_CNT</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Integer rounded range for each bucket */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_BUCKET_DELTA DIV_ROUND_CLOSEST(SCHED_CAPACITY_SCALE, UCLAMP_BUCKETS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_clamp_id(clamp_id) \</span></span><br><span class="line">	<span class="keyword">for</span> ((clamp_id) = <span class="number">0</span>; (clamp_id) &lt; UCLAMP_CNT; (clamp_id)++)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_bucket_id</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> clamp_value / UCLAMP_BUCKET_DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_bucket_base_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UCLAMP_BUCKET_DELTA * uclamp_bucket_id(clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_none</span><span class="params">(<span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (clamp_id == UCLAMP_MIN)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> SCHED_CAPACITY_SCALE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_se_set</span><span class="params">(struct uclamp_se *uc_se,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">unsigned</span> <span class="keyword">int</span> value, <span class="keyword">bool</span> user_defined)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uc_se-&gt;value = value;</span><br><span class="line">	uc_se-&gt;bucket_id = uclamp_bucket_id(value);</span><br><span class="line">	uc_se-&gt;user_defined = user_defined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">uclamp_idle_value(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span><br><span class="line">		  <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Avoid blocked utilization pushing up the frequency when we go</span></span><br><span class="line"><span class="comment">	 * idle (which drops the max-clamp) by retaining the last known</span></span><br><span class="line"><span class="comment">	 * max-clamp.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (clamp_id == UCLAMP_MAX) &#123;</span><br><span class="line">		rq-&gt;uclamp_flags |= UCLAMP_FLAG_IDLE;</span><br><span class="line">		<span class="keyword">return</span> clamp_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uclamp_none(UCLAMP_MIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_idle_reset</span><span class="params">(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span></span></span><br><span class="line"><span class="function"><span class="params">				     <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Reset max-clamp retention only on idle exit */</span></span><br><span class="line">	<span class="keyword">if</span> (!(rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(rq-&gt;uclamp[clamp_id].value, clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">uclamp_rq_max_value</span><span class="params">(struct rq *rq, <span class="keyword">enum</span> uclamp_id clamp_id,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span> = <span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>].<span class="title">bucket</span>;</span></span><br><span class="line">	<span class="keyword">int</span> bucket_id = UCLAMP_BUCKETS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since both min and max clamps are max aggregated, find the</span></span><br><span class="line"><span class="comment">	 * top most bucket with tasks in.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; bucket_id &gt;= <span class="number">0</span>; bucket_id--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!bucket[bucket_id].tasks)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">return</span> bucket[bucket_id].value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* No tasks -- default clamp values */</span></span><br><span class="line">	<span class="keyword">return</span> uclamp_idle_value(rq, clamp_id, clamp_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span></span></span><br><span class="line"><span class="class"><span class="title">uclamp_tg_restrict</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">enum</span> <span class="title">uclamp_id</span> <span class="title">clamp_id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_req</span> = <span class="title">p</span>-&gt;<span class="title">uclamp_req</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks in autogroups or root task group will be</span></span><br><span class="line"><span class="comment">	 * restricted by system defaults.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_group_is_autogroup(task_group(p)))</span><br><span class="line">		<span class="keyword">return</span> uc_req;</span><br><span class="line">	<span class="keyword">if</span> (task_group(p) == &amp;root_task_group)</span><br><span class="line">		<span class="keyword">return</span> uc_req;</span><br><span class="line"></span><br><span class="line">	uc_max = task_group(p)-&gt;uclamp[clamp_id];</span><br><span class="line">	<span class="keyword">if</span> (uc_req.value &gt; uc_max.value || !uc_req.user_defined)</span><br><span class="line">		<span class="keyword">return</span> uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uc_req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The effective clamp bucket index of a task depends on, by increasing</span></span><br><span class="line"><span class="comment"> * priority:</span></span><br><span class="line"><span class="comment"> * - the task specific clamp value, when explicitly requested from userspace</span></span><br><span class="line"><span class="comment"> * - the task group effective clamp value, for tasks not either in the root</span></span><br><span class="line"><span class="comment"> *   group or in an autogroup</span></span><br><span class="line"><span class="comment"> * - the system default clamp value, defined by the sysadmin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span></span></span><br><span class="line"><span class="class"><span class="title">uclamp_eff_get</span>(<span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">enum</span> <span class="title">uclamp_id</span> <span class="title">clamp_id</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_req</span> = <span class="title">uclamp_tg_restrict</span>(<span class="title">p</span>, <span class="title">clamp_id</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span> = <span class="title">uclamp_default</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* System default restrictions always apply */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(uc_req.value &gt; uc_max.value))</span><br><span class="line">		<span class="keyword">return</span> uc_max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uc_req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">uclamp_eff_value</span><span class="params">(struct task_struct *p, <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_eff</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Task currently refcounted: use back-annotated (effective) value */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;uclamp[clamp_id].active)</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)p-&gt;uclamp[clamp_id].value;</span><br><span class="line"></span><br><span class="line">	uc_eff = uclamp_eff_get(p, clamp_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)uc_eff.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When a task is enqueued on a rq, the clamp bucket currently defined by the</span></span><br><span class="line"><span class="comment"> * task's uclamp::bucket_id is refcounted on that rq. This also immediately</span></span><br><span class="line"><span class="comment"> * updates the rq's clamp value if required.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tasks can have a task-specific value requested from user-space, track</span></span><br><span class="line"><span class="comment"> * within each bucket the maximum value for tasks refcounted in it.</span></span><br><span class="line"><span class="comment"> * This "local max aggregation" allows to track the exact "requested" value</span></span><br><span class="line"><span class="comment"> * for each bucket when all its RUNNABLE tasks require the same clamp.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc_id</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span> *<span class="title">uc_rq</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update task effective clamp */</span></span><br><span class="line">	p-&gt;uclamp[clamp_id] = uclamp_eff_get(p, clamp_id);</span><br><span class="line"></span><br><span class="line">	bucket = &amp;uc_rq-&gt;bucket[uc_se-&gt;bucket_id];</span><br><span class="line">	bucket-&gt;tasks++;</span><br><span class="line">	uc_se-&gt;active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	uclamp_idle_reset(rq, clamp_id, uc_se-&gt;value);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Local max aggregation: rq buckets always track the max</span></span><br><span class="line"><span class="comment">	 * "requested" clamp value of its RUNNABLE tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bucket-&gt;tasks == <span class="number">1</span> || uc_se-&gt;value &gt; bucket-&gt;value)</span><br><span class="line">		bucket-&gt;value = uc_se-&gt;value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uc_se-&gt;value &gt; READ_ONCE(uc_rq-&gt;value))</span><br><span class="line">		WRITE_ONCE(uc_rq-&gt;value, uc_se-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When a task is dequeued from a rq, the clamp bucket refcounted by the task</span></span><br><span class="line"><span class="comment"> * is released. If this is the last task reference counting the rq's max</span></span><br><span class="line"><span class="comment"> * active clamp value, then the rq's clamp value is updated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both refcounted tasks and rq's cached clamp values are expected to be</span></span><br><span class="line"><span class="comment"> * always valid. If it's detected they are not, as defensive programming,</span></span><br><span class="line"><span class="comment"> * enforce the expected state and warn.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec_id</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_rq</span> *<span class="title">uc_rq</span> = &amp;<span class="title">rq</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_bucket</span> *<span class="title">bucket</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bkt_clamp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rq_clamp;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	bucket = &amp;uc_rq-&gt;bucket[uc_se-&gt;bucket_id];</span><br><span class="line">	SCHED_WARN_ON(!bucket-&gt;tasks);</span><br><span class="line">	<span class="keyword">if</span> (likely(bucket-&gt;tasks))</span><br><span class="line">		bucket-&gt;tasks--;</span><br><span class="line">	uc_se-&gt;active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep "local max aggregation" simple and accept to (possibly)</span></span><br><span class="line"><span class="comment">	 * overboost some RUNNABLE tasks in the same bucket.</span></span><br><span class="line"><span class="comment">	 * The rq clamp bucket value is reset to its base value whenever</span></span><br><span class="line"><span class="comment">	 * there are no more RUNNABLE tasks refcounting it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(bucket-&gt;tasks))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq_clamp = READ_ONCE(uc_rq-&gt;value);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defensive programming: this should never happen. If it happens,</span></span><br><span class="line"><span class="comment">	 * e.g. due to future modification, warn and fixup the expected value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SCHED_WARN_ON(bucket-&gt;value &gt; rq_clamp);</span><br><span class="line">	<span class="keyword">if</span> (bucket-&gt;value &gt;= rq_clamp) &#123;</span><br><span class="line">		bkt_clamp = uclamp_rq_max_value(rq, clamp_id, uc_se-&gt;value);</span><br><span class="line">		WRITE_ONCE(uc_rq-&gt;value, bkt_clamp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!p-&gt;sched_class-&gt;uclamp_enabled))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		uclamp_rq_inc_id(rq, p, clamp_id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reset clamp idle holding when there is one RUNNABLE task */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;uclamp_flags &amp; UCLAMP_FLAG_IDLE)</span><br><span class="line">		rq-&gt;uclamp_flags &amp;= ~UCLAMP_FLAG_IDLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec</span><span class="params">(struct rq *rq, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!p-&gt;sched_class-&gt;uclamp_enabled))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		uclamp_rq_dec_id(rq, p, clamp_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">uclamp_update_active(struct task_struct *p, <span class="keyword">enum</span> uclamp_id clamp_id)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Lock the task and the rq where the task is (or was) queued.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We might lock the (previous) rq of a !RUNNABLE task, but that's the</span></span><br><span class="line"><span class="comment">	 * price to pay to safely serialize util_&#123;min,max&#125; updates with</span></span><br><span class="line"><span class="comment">	 * enqueues, dequeues and migration operations.</span></span><br><span class="line"><span class="comment">	 * This is the same locking schema used by __set_cpus_allowed_ptr().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setting the clamp bucket is serialized by task_rq_lock().</span></span><br><span class="line"><span class="comment">	 * If the task is not yet RUNNABLE and its task_struct is not</span></span><br><span class="line"><span class="comment">	 * affecting a valid clamp bucket, the next time it's enqueued,</span></span><br><span class="line"><span class="comment">	 * it will already see the updated clamp bucket value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;uclamp[clamp_id].active) &#123;</span><br><span class="line">		uclamp_rq_dec_id(rq, p, clamp_id);</span><br><span class="line">		uclamp_rq_inc_id(rq, p, clamp_id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">uclamp_update_active_tasks(struct cgroup_subsys_state *css,</span><br><span class="line">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> clamps)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_task_iter</span> <span class="title">it</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	css_task_iter_start(css, <span class="number">0</span>, &amp;it);</span><br><span class="line">	<span class="keyword">while</span> ((p = css_task_iter_next(&amp;it))) &#123;</span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="number">0x1</span> &lt;&lt; clamp_id) &amp; clamps)</span><br><span class="line">				uclamp_update_active(p, clamp_id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	css_task_iter_end(&amp;it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_util_update_eff</span><span class="params">(struct cgroup_subsys_state *css)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_update_root_tg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = &amp;<span class="title">root_task_group</span>;</span></span><br><span class="line"></span><br><span class="line">	uclamp_se_set(&amp;tg-&gt;uclamp_req[UCLAMP_MIN],</span><br><span class="line">		      sysctl_sched_uclamp_util_min, <span class="literal">false</span>);</span><br><span class="line">	uclamp_se_set(&amp;tg-&gt;uclamp_req[UCLAMP_MAX],</span><br><span class="line">		      sysctl_sched_uclamp_util_max, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	cpu_util_update_eff(&amp;root_task_group.css);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_update_root_tg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_sched_uclamp_handler</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> update_root_tg = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> old_min, old_max;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;uclamp_mutex);</span><br><span class="line">	old_min = sysctl_sched_uclamp_util_min;</span><br><span class="line">	old_max = sysctl_sched_uclamp_util_max;</span><br><span class="line"></span><br><span class="line">	result = proc_dointvec(table, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> undo;</span><br><span class="line">	<span class="keyword">if</span> (!write)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysctl_sched_uclamp_util_min &gt; sysctl_sched_uclamp_util_max ||</span><br><span class="line">	    sysctl_sched_uclamp_util_max &gt; SCHED_CAPACITY_SCALE) &#123;</span><br><span class="line">		result = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> undo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_min != sysctl_sched_uclamp_util_min) &#123;</span><br><span class="line">		uclamp_se_set(&amp;uclamp_default[UCLAMP_MIN],</span><br><span class="line">			      sysctl_sched_uclamp_util_min, <span class="literal">false</span>);</span><br><span class="line">		update_root_tg = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (old_max != sysctl_sched_uclamp_util_max) &#123;</span><br><span class="line">		uclamp_se_set(&amp;uclamp_default[UCLAMP_MAX],</span><br><span class="line">			      sysctl_sched_uclamp_util_max, <span class="literal">false</span>);</span><br><span class="line">		update_root_tg = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (update_root_tg)</span><br><span class="line">		uclamp_update_root_tg();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We update all RUNNABLE tasks only when task groups are in use.</span></span><br><span class="line"><span class="comment">	 * Otherwise, keep it simple and do just a lazy update at each next</span></span><br><span class="line"><span class="comment">	 * task enqueue time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">undo:</span><br><span class="line">	sysctl_sched_uclamp_util_min = old_min;</span><br><span class="line">	sysctl_sched_uclamp_util_max = old_max;</span><br><span class="line">done:</span><br><span class="line">	mutex_unlock(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uclamp_validate</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lower_bound = p-&gt;uclamp_req[UCLAMP_MIN].value;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> upper_bound = p-&gt;uclamp_req[UCLAMP_MAX].value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MIN)</span><br><span class="line">		lower_bound = attr-&gt;sched_util_min;</span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MAX)</span><br><span class="line">		upper_bound = attr-&gt;sched_util_max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lower_bound &gt; upper_bound)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (upper_bound &gt; SCHED_CAPACITY_SCALE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_uclamp(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct sched_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On scheduling class change, reset to default clamps for tasks</span></span><br><span class="line"><span class="comment">	 * without a task-specific value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = &amp;<span class="title">p</span>-&gt;<span class="title">uclamp_req</span>[<span class="title">clamp_id</span>];</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> clamp_value = uclamp_none(clamp_id);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Keep using defined clamps across class changes */</span></span><br><span class="line">		<span class="keyword">if</span> (uc_se-&gt;user_defined)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* By default, RT tasks always get 100% boost */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(rt_task(p) &amp;&amp; clamp_id == UCLAMP_MIN))</span><br><span class="line">			clamp_value = uclamp_none(UCLAMP_MAX);</span><br><span class="line"></span><br><span class="line">		uclamp_se_set(uc_se, clamp_value, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!(attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MIN) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[UCLAMP_MIN],</span><br><span class="line">			      attr-&gt;sched_util_min, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP_MAX) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[UCLAMP_MAX],</span><br><span class="line">			      attr-&gt;sched_util_max, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uclamp_fork</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id)</span><br><span class="line">		p-&gt;uclamp[clamp_id].active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!p-&gt;sched_reset_on_fork))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;p-&gt;uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_uclamp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> <span class="title">uc_max</span> = &#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;cpu_rq(cpu)-&gt;uclamp, <span class="number">0</span>,</span><br><span class="line">				<span class="keyword">sizeof</span>(struct uclamp_rq)*UCLAMP_CNT);</span><br><span class="line">		cpu_rq(cpu)-&gt;uclamp_flags = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;init_task.uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* System defaults allow max clamp values for both indexes */</span></span><br><span class="line">	uclamp_se_set(&amp;uc_max, uclamp_none(UCLAMP_MAX), <span class="literal">false</span>);</span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_default[clamp_id] = uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">		root_task_group.uclamp_req[clamp_id] = uc_max;</span><br><span class="line">		root_task_group.uclamp[clamp_id] = uc_max;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_UCLAMP_TASK */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_inc</span><span class="params">(struct rq *rq, struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_rq_dec</span><span class="params">(struct rq *rq, struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">uclamp_validate</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_uclamp(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct sched_attr *attr) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uclamp_fork</span><span class="params">(struct task_struct *p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_uclamp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_UCLAMP_TASK */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">enqueue_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; ENQUEUE_RESTORE)) &#123;</span><br><span class="line">		sched_info_queued(rq, p);</span><br><span class="line">		psi_enqueue(p, flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_inc(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dequeue_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DEQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DEQUEUE_SAVE)) &#123;</span><br><span class="line">		sched_info_dequeued(rq, p);</span><br><span class="line">		psi_dequeue(p, flags &amp; DEQUEUE_SLEEP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_dec(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activate_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">	p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deactivate_task</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;on_rq = (flags &amp; DEQUEUE_SLEEP) ? <span class="number">0</span> : TASK_ON_RQ_MIGRATING;</span><br><span class="line"></span><br><span class="line">	dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __normal_prio - return the priority that is based on the static prio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __normal_prio(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;static_prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the expected normal priority: i.e. priority</span></span><br><span class="line"><span class="comment"> * without taking RT-inheritance into account. Might be</span></span><br><span class="line"><span class="comment"> * boosted by interactivity modifiers. Changes upon fork,</span></span><br><span class="line"><span class="comment"> * setprio syscalls, and whenever the interactivity</span></span><br><span class="line"><span class="comment"> * estimator recalculates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">normal_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">		prio = MAX_DL_PRIO<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		prio = MAX_RT_PRIO<span class="number">-1</span> - p-&gt;rt_priority;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		prio = __normal_prio(p);</span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the current priority, i.e. the priority</span></span><br><span class="line"><span class="comment"> * taken into account by the scheduler. This value might</span></span><br><span class="line"><span class="comment"> * be boosted by RT tasks, or might be boosted by</span></span><br><span class="line"><span class="comment"> * interactivity modifiers. Will be RT if the task got</span></span><br><span class="line"><span class="comment"> * RT-boosted. If not then it returns p-&gt;normal_prio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">effective_prio</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are RT tasks or we were boosted to RT priority,</span></span><br><span class="line"><span class="comment">	 * keep the priority unchanged. Otherwise, update priority</span></span><br><span class="line"><span class="comment">	 * to the normal priority:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!rt_prio(p-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> p-&gt;normal_prio;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_curr - is this task currently executing on a CPU?</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the task is currently executing. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">task_curr</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_curr(task_cpu(p)) == p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * switched_from, switched_to and prio_changed must _NOT_ drop rq-&gt;lock,</span></span><br><span class="line"><span class="comment"> * use the balance_callback list if you want balancing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this means any call to check_class_changed() must be followed by a call to</span></span><br><span class="line"><span class="comment"> * balance_callback().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check_class_changed</span><span class="params">(struct rq *rq, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">const</span> struct sched_class *prev_class,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">int</span> oldprio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (prev_class != p-&gt;sched_class) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prev_class-&gt;switched_from)</span><br><span class="line">			prev_class-&gt;switched_from(rq, p);</span><br><span class="line"></span><br><span class="line">		p-&gt;sched_class-&gt;switched_to(rq, p);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldprio != p-&gt;prio || dl_task(p))</span><br><span class="line">		p-&gt;sched_class-&gt;prio_changed(rq, p, oldprio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_preempt_curr</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class == rq-&gt;curr-&gt;sched_class) &#123;</span><br><span class="line">		rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class == rq-&gt;curr-&gt;sched_class)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (class == p-&gt;sched_class) &#123;</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A queue event has occurred, and we're going to schedule.  In</span></span><br><span class="line"><span class="comment">	 * this case, we can save a useless back to back clock update.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(rq-&gt;curr) &amp;&amp; test_tsk_need_resched(rq-&gt;curr))</span><br><span class="line">		rq_clock_skip_update(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per-CPU kthreads are allowed to run on !active &amp;&amp; online CPUs, see</span></span><br><span class="line"><span class="comment"> * __set_cpus_allowed_ptr() and select_fallback_rq().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_cpu_allowed</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(cpu, p-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_per_cpu_kthread(p))</span><br><span class="line">		<span class="keyword">return</span> cpu_online(cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cpu_active(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is how migration works:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) we invoke migration_cpu_stop() on the target CPU using</span></span><br><span class="line"><span class="comment"> *    stop_one_cpu().</span></span><br><span class="line"><span class="comment"> * 2) stopper starts to run (implicitly forcing the migrated thread</span></span><br><span class="line"><span class="comment"> *    off the CPU)</span></span><br><span class="line"><span class="comment"> * 3) it checks whether the migrated task is still in the wrong runqueue.</span></span><br><span class="line"><span class="comment"> * 4) if it's in the wrong runqueue then the migration thread removes</span></span><br><span class="line"><span class="comment"> *    it and puts it into the right queue.</span></span><br><span class="line"><span class="comment"> * 5) stopper completes and stop_one_cpu() returns and the migration</span></span><br><span class="line"><span class="comment"> *    is done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * move_queued_task - move a queued task to new rq.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns (locked) new rq. Old rq's lock is released.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct rq *<span class="title">move_queued_task</span><span class="params">(struct rq *rq, struct rq_flags *rf,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct task_struct *p, <span class="keyword">int</span> new_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(p-&gt;on_rq, TASK_ON_RQ_MIGRATING);</span><br><span class="line">	dequeue_task(rq, p, DEQUEUE_NOCLOCK);</span><br><span class="line">	set_task_cpu(p, new_cpu);</span><br><span class="line">	rq_unlock(rq, rf);</span><br><span class="line"></span><br><span class="line">	rq = cpu_rq(new_cpu);</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, rf);</span><br><span class="line">	BUG_ON(task_cpu(p) != new_cpu);</span><br><span class="line">	enqueue_task(rq, p, <span class="number">0</span>);</span><br><span class="line">	p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">	check_preempt_curr(rq, p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Move (not current) task off this CPU, onto the destination CPU. We're doing</span></span><br><span class="line"><span class="comment"> * this because either it can't run here any more (set_cpus_allowed()</span></span><br><span class="line"><span class="comment"> * away from this CPU, or CPU going down), or because we're</span></span><br><span class="line"><span class="comment"> * attempting to rebalance this task on exec (sched_exec).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So we race with normal scheduler movements, but that's OK, as long</span></span><br><span class="line"><span class="comment"> * as the task is no longer on this CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *__<span class="title">migrate_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>,</span></span><br><span class="line"><span class="class">				 <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, <span class="title">int</span> <span class="title">dest_cpu</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/* Affinity changed (again). */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_cpu_allowed(p, dest_cpu))</span><br><span class="line">		<span class="keyword">return</span> rq;</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	rq = move_queued_task(rq, rf, p, dest_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * migration_cpu_stop - this will be executed by a highprio stopper thread</span></span><br><span class="line"><span class="comment"> * and performs thread migration by bumping thread off CPU then</span></span><br><span class="line"><span class="comment"> * 'pushing' onto another runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">migration_cpu_stop</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> *<span class="title">arg</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">arg</span>-&gt;<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The original target CPU might have gone down and we might</span></span><br><span class="line"><span class="comment">	 * be on another CPU but it doesn't matter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to explicitly wake pending tasks before running</span></span><br><span class="line"><span class="comment">	 * __migrate_task() such that we will not miss enforcing cpus_ptr</span></span><br><span class="line"><span class="comment">	 * during wakeups, see set_cpus_allowed_ptr()'s TASK_WAKING test.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	flush_smp_call_function_from_idle();</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;p-&gt;pi_lock);</span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If task_rq(p) != rq, it cannot be migrated here, because we're</span></span><br><span class="line"><span class="comment">	 * holding rq-&gt;lock, if p-&gt;on_rq == 0 it cannot get enqueued because</span></span><br><span class="line"><span class="comment">	 * we're holding p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_rq(p) == rq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task_on_rq_queued(p))</span><br><span class="line">			rq = __migrate_task(rq, &amp;rf, p, arg-&gt;dest_cpu);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p-&gt;wake_cpu = arg-&gt;dest_cpu;</span><br><span class="line">	&#125;</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">	raw_spin_unlock(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_class::set_cpus_allowed must do the below, but is not required to</span></span><br><span class="line"><span class="comment"> * actually call this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cpus_allowed_common</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpumask_copy(&amp;p-&gt;cpus_mask, new_mask);</span><br><span class="line">	p-&gt;nr_cpus_allowed = cpumask_weight(new_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_set_cpus_allowed</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">task_rq</span>(<span class="title">p</span>);</span></span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because __kthread_bind() calls this on blocked tasks without</span></span><br><span class="line"><span class="comment">		 * holding rq-&gt;lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_class-&gt;set_cpus_allowed(p, new_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change a given task's CPU affinity. Migrate the thread to a</span></span><br><span class="line"><span class="comment"> * proper CPU and schedule it away if the CPU it's executing on</span></span><br><span class="line"><span class="comment"> * is removed from the allowed bitmask.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> the caller must have a valid reference to the task, the</span></span><br><span class="line"><span class="comment"> * task must not exit() &amp; deallocate itself prematurely. The</span></span><br><span class="line"><span class="comment"> * call is not atomic; no spinlocks may be held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __set_cpus_allowed_ptr(struct task_struct *p,</span><br><span class="line">				  <span class="keyword">const</span> struct cpumask *new_mask, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">cpu_valid_mask</span> = <span class="title">cpu_active_mask</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dest_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Kernel threads are allowed on online &amp;&amp; !active CPUs</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpu_valid_mask = cpu_online_mask;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must re-check here, to close a race against __kthread_bind(),</span></span><br><span class="line"><span class="comment">	 * sched_setaffinity() is not guaranteed to observe the flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check &amp;&amp; (p-&gt;flags &amp; PF_NO_SETAFFINITY)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpumask_equal(&amp;p-&gt;cpus_mask, new_mask))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Picking a ~random cpu helps in cases where we are changing affinity</span></span><br><span class="line"><span class="comment">	 * for groups of tasks (ie. cpuset), so that load balancing is not</span></span><br><span class="line"><span class="comment">	 * immediately required to distribute the tasks within their new mask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dest_cpu = cpumask_any_and_distribute(cpu_valid_mask, new_mask);</span><br><span class="line">	<span class="keyword">if</span> (dest_cpu &gt;= nr_cpu_ids) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	do_set_cpus_allowed(p, new_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For kernel threads that do indeed end up on online &amp;&amp;</span></span><br><span class="line"><span class="comment">		 * !active we want to ensure they are strict per-CPU threads.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON(cpumask_intersects(new_mask, cpu_online_mask) &amp;&amp;</span><br><span class="line">			!cpumask_intersects(new_mask, cpu_active_mask) &amp;&amp;</span><br><span class="line">			p-&gt;nr_cpus_allowed != <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can the task run on the task's current CPU? If so, we're done */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_test_cpu(task_cpu(p), new_mask))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_running(rq, p) || p-&gt;state == TASK_WAKING) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, dest_cpu &#125;;</span><br><span class="line">		<span class="comment">/* Need help from migration thread: drop lock and wait. */</span></span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">		stop_one_cpu(cpu_of(rq), migration_cpu_stop, &amp;arg);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK, since we're going to drop the lock immediately</span></span><br><span class="line"><span class="comment">		 * afterwards anyway.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = move_queued_task(rq, &amp;rf, p, dest_cpu);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_cpus_allowed_ptr</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __set_cpus_allowed_ptr(p, new_mask, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_task_cpu</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> new_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We should never call set_task_cpu() on a blocked task,</span></span><br><span class="line"><span class="comment">	 * ttwu() will sort out the placement.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(p-&gt;state != TASK_RUNNING &amp;&amp; p-&gt;state != TASK_WAKING &amp;&amp;</span><br><span class="line">			!p-&gt;on_rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Migrating fair class task must have p-&gt;on_rq = TASK_ON_RQ_MIGRATING,</span></span><br><span class="line"><span class="comment">	 * because schedstat_wait_&#123;start,end&#125; rebase migrating task's wait_start</span></span><br><span class="line"><span class="comment">	 * time relying on p-&gt;on_rq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(p-&gt;state == TASK_RUNNING &amp;&amp;</span><br><span class="line">		     p-&gt;sched_class == &amp;fair_sched_class &amp;&amp;</span><br><span class="line">		     (p-&gt;on_rq &amp;&amp; !task_on_rq_migrating(p)));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The caller should hold either p-&gt;pi_lock or rq-&gt;lock, when changing</span></span><br><span class="line"><span class="comment">	 * a task's CPU. -&gt;pi_lock for waking tasks, rq-&gt;lock for runnable tasks.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sched_move_task() holds both and thus holding either pins the cgroup,</span></span><br><span class="line"><span class="comment">	 * see task_group().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Furthermore, all task_rq users should acquire both locks, see</span></span><br><span class="line"><span class="comment">	 * task_rq_lock().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(debug_locks &amp;&amp; !(lockdep_is_held(&amp;p-&gt;pi_lock) ||</span><br><span class="line">				      lockdep_is_held(&amp;task_rq(p)-&gt;lock)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clearly, migrating tasks to offline CPUs is a fairly daft thing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!cpu_online(new_cpu));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	trace_sched_migrate_task(p, new_cpu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) != new_cpu) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;sched_class-&gt;migrate_task_rq)</span><br><span class="line">			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);</span><br><span class="line">		p-&gt;se.nr_migrations++;</span><br><span class="line">		rseq_migrate(p);</span><br><span class="line">		perf_event_task_migrate(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__set_task_cpu(p, new_cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __migrate_swap_task(struct task_struct *p, <span class="keyword">int</span> cpu)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">src_rq</span>, *<span class="title">dst_rq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">srf</span>, <span class="title">drf</span>;</span></span><br><span class="line"></span><br><span class="line">		src_rq = task_rq(p);</span><br><span class="line">		dst_rq = cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">		rq_pin_lock(src_rq, &amp;srf);</span><br><span class="line">		rq_pin_lock(dst_rq, &amp;drf);</span><br><span class="line"></span><br><span class="line">		deactivate_task(src_rq, p, <span class="number">0</span>);</span><br><span class="line">		set_task_cpu(p, cpu);</span><br><span class="line">		activate_task(dst_rq, p, <span class="number">0</span>);</span><br><span class="line">		check_preempt_curr(dst_rq, p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		rq_unpin_lock(dst_rq, &amp;drf);</span><br><span class="line">		rq_unpin_lock(src_rq, &amp;srf);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Task isn't running anymore; make it appear like we migrated</span></span><br><span class="line"><span class="comment">		 * it before it went to sleep. This means on wakeup we make the</span></span><br><span class="line"><span class="comment">		 * previous CPU our target instead of where it really is.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;wake_cpu = cpu;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">src_task</span>, *<span class="title">dst_task</span>;</span></span><br><span class="line">	<span class="keyword">int</span> src_cpu, dst_cpu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">migrate_swap_stop</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> *<span class="title">arg</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">src_rq</span>, *<span class="title">dst_rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpu_active(arg-&gt;src_cpu) || !cpu_active(arg-&gt;dst_cpu))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	src_rq = cpu_rq(arg-&gt;src_cpu);</span><br><span class="line">	dst_rq = cpu_rq(arg-&gt;dst_cpu);</span><br><span class="line"></span><br><span class="line">	double_raw_lock(&amp;arg-&gt;src_task-&gt;pi_lock,</span><br><span class="line">			&amp;arg-&gt;dst_task-&gt;pi_lock);</span><br><span class="line">	double_rq_lock(src_rq, dst_rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(arg-&gt;dst_task) != arg-&gt;dst_cpu)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_cpu(arg-&gt;src_task) != arg-&gt;src_cpu)</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg-&gt;dst_cpu, arg-&gt;src_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg-&gt;src_cpu, arg-&gt;dst_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	__migrate_swap_task(arg-&gt;src_task, arg-&gt;dst_cpu);</span><br><span class="line">	__migrate_swap_task(arg-&gt;dst_task, arg-&gt;src_cpu);</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	double_rq_unlock(src_rq, dst_rq);</span><br><span class="line">	raw_spin_unlock(&amp;arg-&gt;dst_task-&gt;pi_lock);</span><br><span class="line">	raw_spin_unlock(&amp;arg-&gt;src_task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cross migrate two tasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">migrate_swap</span><span class="params">(struct task_struct *cur, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> target_cpu, <span class="keyword">int</span> curr_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_swap_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	arg = (struct migration_swap_arg)&#123;</span><br><span class="line">		.src_task = cur,</span><br><span class="line">		.src_cpu = curr_cpu,</span><br><span class="line">		.dst_task = p,</span><br><span class="line">		.dst_cpu = target_cpu,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arg.src_cpu == arg.dst_cpu)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These three tests are all lockless; this is OK since all of them</span></span><br><span class="line"><span class="comment">	 * will be re-checked with proper locks held further down the line.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg.dst_cpu, arg.src_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(arg.src_cpu, arg.dst_task-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);</span><br><span class="line">	ret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &amp;arg);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wait_task_inactive - wait for a thread to unschedule.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @match_state is nonzero, it's the @p-&gt;state value just checked and</span></span><br><span class="line"><span class="comment"> * not expected to change.  If it changes, i.e. @p might have woken up,</span></span><br><span class="line"><span class="comment"> * then return zero.  When we succeed in waiting for @p to be off its CPU,</span></span><br><span class="line"><span class="comment"> * we return a positive number (its total switch count).  If a second call</span></span><br><span class="line"><span class="comment"> * a short while later returns the same number, the caller can be sure that</span></span><br><span class="line"><span class="comment"> * @p has remained unscheduled the whole time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller must ensure that the task *will* unschedule sometime soon,</span></span><br><span class="line"><span class="comment"> * else this function might spin for a *long* time. This function can't</span></span><br><span class="line"><span class="comment"> * be called with interrupts off, or it may introduce deadlock with</span></span><br><span class="line"><span class="comment"> * smp_call_function() if an IPI is sent by the same process we are</span></span><br><span class="line"><span class="comment"> * waiting to become inactive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">wait_task_inactive</span><span class="params">(struct task_struct *p, <span class="keyword">long</span> match_state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> running, queued;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ncsw;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We do the initial early heuristics without holding</span></span><br><span class="line"><span class="comment">		 * any task-queue locks at all. We'll only try to get</span></span><br><span class="line"><span class="comment">		 * the runqueue lock when things look like they will</span></span><br><span class="line"><span class="comment">		 * work out!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = task_rq(p);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the task is actively running on another CPU</span></span><br><span class="line"><span class="comment">		 * still, just relax and busy-wait without holding</span></span><br><span class="line"><span class="comment">		 * any locks.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * NOTE! Since we don't hold any locks, it's not</span></span><br><span class="line"><span class="comment">		 * even sure that "rq" stays as the right runqueue!</span></span><br><span class="line"><span class="comment">		 * But we don't care, since "task_running()" will</span></span><br><span class="line"><span class="comment">		 * return false if the runqueue has changed and p</span></span><br><span class="line"><span class="comment">		 * is actually now running somewhere else!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span> (task_running(rq, p)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (match_state &amp;&amp; unlikely(p-&gt;state != match_state))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			cpu_relax();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ok, time to look more closely! We need the rq</span></span><br><span class="line"><span class="comment">		 * lock now, to be *sure*. If we're wrong, we'll</span></span><br><span class="line"><span class="comment">		 * just go back and repeat.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">		trace_sched_wait_task(p);</span><br><span class="line">		running = task_running(rq, p);</span><br><span class="line">		queued = task_on_rq_queued(p);</span><br><span class="line">		ncsw = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!match_state || p-&gt;state == match_state)</span><br><span class="line">			ncsw = p-&gt;nvcsw | LONG_MIN; <span class="comment">/* sets MSB */</span></span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If it changed from the expected state, bail out now.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!ncsw))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Was it really running after all now that we</span></span><br><span class="line"><span class="comment">		 * checked with the proper locks actually held?</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Oops. Go back and try again..</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(running)) &#123;</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It's not enough that it's not actively running,</span></span><br><span class="line"><span class="comment">		 * it must be off the runqueue _entirely_, and not</span></span><br><span class="line"><span class="comment">		 * preempted!</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * So if it was still runnable (but just not actively</span></span><br><span class="line"><span class="comment">		 * running right now), it's preempted, and we should</span></span><br><span class="line"><span class="comment">		 * yield - it could be a while.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(queued)) &#123;</span><br><span class="line">			<span class="keyword">ktime_t</span> to = NSEC_PER_SEC / HZ;</span><br><span class="line"></span><br><span class="line">			set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">			schedule_hrtimeout(&amp;to, HRTIMER_MODE_REL);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ahh, all good. It wasn't running, and it wasn't</span></span><br><span class="line"><span class="comment">		 * runnable, which means that it will never become</span></span><br><span class="line"><span class="comment">		 * running in the future either. We're all done!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ncsw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * kick_process - kick a running thread to enter/exit the kernel</span></span><br><span class="line"><span class="comment"> * @p: the to-be-kicked thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Cause a process which is running on another CPU to enter</span></span><br><span class="line"><span class="comment"> * kernel-mode, without any delay. (to get signals handled.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this function doesn't have to take the runqueue lock,</span></span><br><span class="line"><span class="comment"> * because all it wants to ensure is that the remote task enters</span></span><br><span class="line"><span class="comment"> * the kernel. If the IPI races and the task has been migrated</span></span><br><span class="line"><span class="comment"> * to another CPU then no harm is done and the purpose has been</span></span><br><span class="line"><span class="comment"> * achieved as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kick_process</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu = task_cpu(p);</span><br><span class="line">	<span class="keyword">if</span> ((cpu != smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;cpus_ptr is protected by both rq-&gt;lock and p-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A few notes on cpu_active vs cpu_online:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - cpu_active must be a subset of cpu_online</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - on CPU-up we allow per-CPU kthreads on the online &amp;&amp; !active CPU,</span></span><br><span class="line"><span class="comment"> *    see __set_cpus_allowed_ptr(). At this point the newly online</span></span><br><span class="line"><span class="comment"> *    CPU isn't yet part of the sched domains, and balancing will not</span></span><br><span class="line"><span class="comment"> *    see it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - on CPU-down we clear cpu_active() to mask the sched domains and</span></span><br><span class="line"><span class="comment"> *    avoid the load balancer to place new tasks on the to be removed</span></span><br><span class="line"><span class="comment"> *    CPU. Existing tasks will remain running there and will be taken</span></span><br><span class="line"><span class="comment"> *    off.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This means that fallback selection must not select !active CPUs.</span></span><br><span class="line"><span class="comment"> * And can assume that any active CPU must be online. Conversely</span></span><br><span class="line"><span class="comment"> * select_task_rq() below may allow selection of !active CPUs in order</span></span><br><span class="line"><span class="comment"> * to satisfy the above rules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select_fallback_rq</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nid = cpu_to_node(cpu);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">nodemask</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; cpuset, possible, fail &#125; state = cpuset;</span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the node that the CPU is on has been offlined, cpu_to_node()</span></span><br><span class="line"><span class="comment">	 * will return -1. There is no CPU on the node, and we should</span></span><br><span class="line"><span class="comment">	 * select the CPU on the other node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nid != <span class="number">-1</span>) &#123;</span><br><span class="line">		nodemask = cpumask_of_node(nid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Look for allowed, online CPU in same node. */</span></span><br><span class="line">		for_each_cpu(dest_cpu, nodemask) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!cpu_active(dest_cpu))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (cpumask_test_cpu(dest_cpu, p-&gt;cpus_ptr))</span><br><span class="line">				<span class="keyword">return</span> dest_cpu;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/* Any allowed, online CPU? */</span></span><br><span class="line">		for_each_cpu(dest_cpu, p-&gt;cpus_ptr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_cpu_allowed(p, dest_cpu))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No more Mr. Nice Guy. */</span></span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">		<span class="keyword">case</span> cpuset:</span><br><span class="line">			<span class="keyword">if</span> (IS_ENABLED(CONFIG_CPUSETS)) &#123;</span><br><span class="line">				cpuset_cpus_allowed_fallback(p);</span><br><span class="line">				state = possible;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Fall-through */</span></span><br><span class="line">		<span class="keyword">case</span> possible:</span><br><span class="line">			do_set_cpus_allowed(p, cpu_possible_mask);</span><br><span class="line">			state = fail;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> fail:</span><br><span class="line">			BUG();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (state != cpuset) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don't tell them about moving exiting tasks or</span></span><br><span class="line"><span class="comment">		 * kernel threads (both mm NULL), since they never</span></span><br><span class="line"><span class="comment">		 * leave kernel.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;mm &amp;&amp; printk_ratelimit()) &#123;</span><br><span class="line">			printk_deferred(<span class="string">"process %d (%s) no longer affine to cpu%d\n"</span>,</span><br><span class="line">					task_pid_nr(p), p-&gt;comm, cpu);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dest_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller (fork, wakeup) owns p-&gt;pi_lock, -&gt;cpus_ptr is stable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select_task_rq</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> sd_flags, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lockdep_assert_held(&amp;p-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;nr_cpus_allowed &gt; <span class="number">1</span>)</span><br><span class="line">		cpu = p-&gt;sched_class-&gt;select_task_rq(p, cpu, sd_flags, wake_flags);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cpu = cpumask_any(p-&gt;cpus_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In order not to call set_task_cpu() on a blocking task we need</span></span><br><span class="line"><span class="comment">	 * to rely on ttwu() to place the task on a valid -&gt;cpus_ptr</span></span><br><span class="line"><span class="comment">	 * CPU.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Since this is common to all placement strategies, this lives here.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * [ this allows -&gt;select_task() to simply return task_cpu(p) and</span></span><br><span class="line"><span class="comment">	 *   not worry about this generic constraint ]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!is_cpu_allowed(p, cpu)))</span><br><span class="line">		cpu = select_fallback_rq(task_cpu(p), p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_set_stop_task</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span> .sched_priority = MAX_RT_PRIO - <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">old_stop</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>)-&gt;<span class="title">stop</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stop) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make it appear like a SCHED_FIFO task, its something</span></span><br><span class="line"><span class="comment">		 * userspace knows about and won't get confused about.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Also, it will make PI more or less work without too</span></span><br><span class="line"><span class="comment">		 * much confusion -- but then, stop work should not</span></span><br><span class="line"><span class="comment">		 * rely on PI working anyway.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sched_setscheduler_nocheck(stop, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">		stop-&gt;sched_class = &amp;stop_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpu_rq(cpu)-&gt;stop = stop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_stop) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Reset it back to a normal scheduling class so that</span></span><br><span class="line"><span class="comment">		 * it can die in pieces.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		old_stop-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __set_cpus_allowed_ptr(struct task_struct *p,</span><br><span class="line">					 <span class="keyword">const</span> struct cpumask *new_mask, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> set_cpus_allowed_ptr(p, new_mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ttwu_stat(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!schedstat_enabled())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq = this_rq();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (cpu == rq-&gt;cpu) &#123;</span><br><span class="line">		__schedstat_inc(rq-&gt;ttwu_local);</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_local);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct sched_domain *sd;</span><br><span class="line"></span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_remote);</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		for_each_domain(rq-&gt;cpu, sd) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cpumask_test_cpu(cpu, sched_domain_span(sd))) &#123;</span><br><span class="line">				__schedstat_inc(sd-&gt;ttwu_wake_remote);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_MIGRATED)</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_migrate);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	__schedstat_inc(rq-&gt;ttwu_count);</span><br><span class="line">	__schedstat_inc(p-&gt;se.statistics.nr_wakeups);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_SYNC)</span><br><span class="line">		__schedstat_inc(p-&gt;se.statistics.nr_wakeups_sync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the task runnable and perform wakeup-preemption.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ttwu_do_wakeup</span><span class="params">(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			   struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line">	trace_sched_wakeup(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Our task @p is fully woken up and running; so its safe to</span></span><br><span class="line"><span class="comment">		 * drop the rq-&gt;lock, hereafter rq is only used for statistics.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unpin_lock(rq, rf);</span><br><span class="line">		p-&gt;sched_class-&gt;task_woken(rq, p);</span><br><span class="line">		rq_repin_lock(rq, rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;idle_stamp) &#123;</span><br><span class="line">		u64 delta = rq_clock(rq) - rq-&gt;idle_stamp;</span><br><span class="line">		u64 max = <span class="number">2</span>*rq-&gt;max_idle_balance_cost;</span><br><span class="line"></span><br><span class="line">		update_avg(&amp;rq-&gt;avg_idle, delta);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;avg_idle &gt; max)</span><br><span class="line">			rq-&gt;avg_idle = max;</span><br><span class="line"></span><br><span class="line">		rq-&gt;idle_stamp = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ttwu_do_activate(struct rq *rq, struct task_struct *p, <span class="keyword">int</span> wake_flags,</span><br><span class="line">		 struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_contributes_to_load)</span><br><span class="line">		rq-&gt;nr_uninterruptible--;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (wake_flags &amp; WF_MIGRATED)</span><br><span class="line">		en_flags |= ENQUEUE_MIGRATED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	activate_task(rq, p, en_flags);</span><br><span class="line">	ttwu_do_wakeup(rq, p, wake_flags, rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called in case the task @p isn't fully descheduled from its runqueue,</span></span><br><span class="line"><span class="comment"> * in this case we must do a remote wakeup. Its a 'light' wakeup though,</span></span><br><span class="line"><span class="comment"> * since all we need to do is flip p-&gt;state to TASK_RUNNING, since</span></span><br><span class="line"><span class="comment"> * the task is still -&gt;on_rq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ttwu_remote</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (task_on_rq_queued(p)) &#123;</span><br><span class="line">		<span class="comment">/* check_preempt_curr() may use rq clock */</span></span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line">		ttwu_do_wakeup(rq, p, wake_flags, &amp;rf);</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__task_rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_ttwu_pending</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">llist</span> = <span class="title">arg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!llist)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * rq::ttwu_pending racy indication of out-standing wakeups.</span></span><br><span class="line"><span class="comment">	 * Races such that false-negatives are possible, since they</span></span><br><span class="line"><span class="comment">	 * are shorter lived that false-positives would be.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(rq-&gt;ttwu_pending, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry.llist) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(p-&gt;on_cpu))</span><br><span class="line">			smp_cond_load_acquire(&amp;p-&gt;on_cpu, !VAL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))</span><br><span class="line">			set_task_cpu(p, cpu_of(rq));</span><br><span class="line"></span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : <span class="number">0</span>, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_call_function_single_ipi</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">		arch_send_call_function_single_ipi(cpu);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue a task on the target CPUs wake_list and wake the CPU via IPI if</span></span><br><span class="line"><span class="comment"> * necessary. The wakee CPU on receipt of the IPI will queue the task</span></span><br><span class="line"><span class="comment"> * via sched_ttwu_wakeup() for activation so the wakee incurs the cost</span></span><br><span class="line"><span class="comment"> * of the wakeup instead of the waker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ttwu_queue_wakelist(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup = !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(rq-&gt;ttwu_pending, <span class="number">1</span>);</span><br><span class="line">	__smp_call_single_queue(cpu, &amp;p-&gt;wake_entry.llist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_if_idle</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		<span class="comment">/* Else CPU is not idle, do nothing here: */</span></span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cpus_share_cache</span><span class="params">(<span class="keyword">int</span> this_cpu, <span class="keyword">int</span> that_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ttwu_queue_cond</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the CPU does not share cache, then queue the task on the</span></span><br><span class="line"><span class="comment">	 * remote rqs wakelist to avoid accessing remote data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!cpus_share_cache(smp_processor_id(), cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the task is descheduling and the only running task on the</span></span><br><span class="line"><span class="comment">	 * CPU then use the wakelist to offload the task activation to</span></span><br><span class="line"><span class="comment">	 * the soon-to-be-idle CPU as the current CPU is likely busy.</span></span><br><span class="line"><span class="comment">	 * nr_running is checked to avoid unnecessary task stacking.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((wake_flags &amp; WF_ON_CPU) &amp;&amp; cpu_rq(cpu)-&gt;nr_running &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ttwu_queue_wakelist</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sched_feat(TTWU_QUEUE) &amp;&amp; ttwu_queue_cond(cpu, wake_flags)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(cpu == smp_processor_id()))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		sched_clock_cpu(cpu); <span class="comment">/* Sync clocks across CPUs */</span></span><br><span class="line">		__ttwu_queue_wakelist(p, cpu, wake_flags);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ttwu_queue</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> cpu, <span class="keyword">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">	<span class="keyword">if</span> (ttwu_queue_wakelist(p, cpu, wake_flags))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notes on Program-Order guarantees on SMP systems.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  MIGRATION</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The basic program-order guarantee on SMP systems is that when a task [t]</span></span><br><span class="line"><span class="comment"> * migrates, all its activity on its old CPU [c0] happens-before any subsequent</span></span><br><span class="line"><span class="comment"> * execution on its new CPU [c1].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For migration (of runnable tasks) this is provided by the following means:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  A) UNLOCK of the rq(c0)-&gt;lock scheduling out task t</span></span><br><span class="line"><span class="comment"> *  B) migration for t is required to synchronize *both* rq(c0)-&gt;lock and</span></span><br><span class="line"><span class="comment"> *     rq(c1)-&gt;lock (if not at the same time, then in that order).</span></span><br><span class="line"><span class="comment"> *  C) LOCK of the rq(c1)-&gt;lock scheduling in task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release/acquire chaining guarantees that B happens after A and C after B.</span></span><br><span class="line"><span class="comment"> * Note: the CPU doing B need not be c0 or c1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   CPU0            CPU1            CPU2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   LOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *   sched-out X</span></span><br><span class="line"><span class="comment"> *   sched-in Y</span></span><br><span class="line"><span class="comment"> *   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                   LOCK rq(0)-&gt;lock // orders against CPU0</span></span><br><span class="line"><span class="comment"> *                                   dequeue X</span></span><br><span class="line"><span class="comment"> *                                   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                   LOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *                                   enqueue X</span></span><br><span class="line"><span class="comment"> *                                   UNLOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                   LOCK rq(1)-&gt;lock // orders against CPU2</span></span><br><span class="line"><span class="comment"> *                   sched-out Z</span></span><br><span class="line"><span class="comment"> *                   sched-in X</span></span><br><span class="line"><span class="comment"> *                   UNLOCK rq(1)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  BLOCKING -- aka. SLEEP + WAKEUP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For blocking we (obviously) need to provide the same guarantee as for</span></span><br><span class="line"><span class="comment"> * migration. However the means are completely different as there is no lock</span></span><br><span class="line"><span class="comment"> * chain to provide order. Instead we do:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1) smp_store_release(X-&gt;on_cpu, 0)</span></span><br><span class="line"><span class="comment"> *   2) smp_cond_load_acquire(!X-&gt;on_cpu)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   CPU0 (schedule)  CPU1 (try_to_wake_up) CPU2 (schedule)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   LOCK rq(0)-&gt;lock LOCK X-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *   dequeue X</span></span><br><span class="line"><span class="comment"> *   sched-out X</span></span><br><span class="line"><span class="comment"> *   smp_store_release(X-&gt;on_cpu, 0);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    smp_cond_load_acquire(&amp;X-&gt;on_cpu, !VAL);</span></span><br><span class="line"><span class="comment"> *                    X-&gt;state = WAKING</span></span><br><span class="line"><span class="comment"> *                    set_task_cpu(X,2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    LOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *                    enqueue X</span></span><br><span class="line"><span class="comment"> *                    X-&gt;state = RUNNING</span></span><br><span class="line"><span class="comment"> *                    UNLOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                                          LOCK rq(2)-&gt;lock // orders against CPU1</span></span><br><span class="line"><span class="comment"> *                                          sched-out Z</span></span><br><span class="line"><span class="comment"> *                                          sched-in X</span></span><br><span class="line"><span class="comment"> *                                          UNLOCK rq(2)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                    UNLOCK X-&gt;pi_lock</span></span><br><span class="line"><span class="comment"> *   UNLOCK rq(0)-&gt;lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, for wakeups there is a second guarantee we must provide, namely we</span></span><br><span class="line"><span class="comment"> * must ensure that CONDITION=1 done by the caller can not be reordered with</span></span><br><span class="line"><span class="comment"> * accesses to the task state; see try_to_wake_up() and set_current_state().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_wake_up - wake up a thread</span></span><br><span class="line"><span class="comment"> * @p: the thread to be awakened</span></span><br><span class="line"><span class="comment"> * @state: the mask of task states that can be woken</span></span><br><span class="line"><span class="comment"> * @wake_flags: wake modifier flags (WF_*)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If (@state &amp; @p-&gt;state) @p-&gt;state = TASK_RUNNING.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task was not queued/runnable, also place it back on a runqueue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomic against schedule() which would dequeue a task, also see</span></span><br><span class="line"><span class="comment"> * set_current_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function executes a full memory barrier before accessing the task</span></span><br><span class="line"><span class="comment"> * state; see set_current_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: %true if @p-&gt;state changes (an actual wakeup was done),</span></span><br><span class="line"><span class="comment"> *	   %false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">try_to_wake_up(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state, <span class="keyword">int</span> wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> cpu, success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (p == current) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We're waking current, this means 'p-&gt;on_rq' and 'task_cpu(p)</span></span><br><span class="line"><span class="comment">		 * == smp_processor_id()'. Together this means we can special</span></span><br><span class="line"><span class="comment">		 * case the whole 'p-&gt;on_rq &amp;&amp; ttwu_remote()' case below</span></span><br><span class="line"><span class="comment">		 * without taking any locks.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In particular:</span></span><br><span class="line"><span class="comment">		 *  - we rely on Program-Order guarantees for all the ordering,</span></span><br><span class="line"><span class="comment">		 *  - we're serialized against set_special_state() by virtue of</span></span><br><span class="line"><span class="comment">		 *    it disabling IRQs (this allows not taking -&gt;pi_lock).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		success = <span class="number">1</span>;</span><br><span class="line">		trace_sched_waking(p);</span><br><span class="line">		p-&gt;state = TASK_RUNNING;</span><br><span class="line">		trace_sched_wakeup(p);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are going to wake up a thread waiting for CONDITION we</span></span><br><span class="line"><span class="comment">	 * need to ensure that CONDITION=1 done by the caller can not be</span></span><br><span class="line"><span class="comment">	 * reordered with p-&gt;state check below. This pairs with mb() in</span></span><br><span class="line"><span class="comment">	 * set_current_state() the waiting thread does.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;state &amp; state))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	trace_sched_waking(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We're going to change -&gt;state: */</span></span><br><span class="line">	success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would</span></span><br><span class="line"><span class="comment">	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck</span></span><br><span class="line"><span class="comment">	 * in smp_cond_load_acquire() below.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sched_ttwu_pending()			try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 1			  LOAD p-&gt;state</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * [task p]</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;state = UNINTERRUPTIBLE	  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * A similar smb_rmb() lives in try_invoke_on_locked_down_task().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(p-&gt;on_rq) &amp;&amp; ttwu_remote(p, wake_flags))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;in_iowait) &#123;</span><br><span class="line">		delayacct_blkio_end(p);</span><br><span class="line">		atomic_dec(&amp;task_rq(p)-&gt;nr_iowait);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we load p-&gt;on_cpu _after_ p-&gt;on_rq, otherwise it would be</span></span><br><span class="line"><span class="comment">	 * possible to, falsely, observe p-&gt;on_cpu == 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * One must be running (-&gt;on_cpu == 1) in order to remove oneself</span></span><br><span class="line"><span class="comment">	 * from the runqueue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')	try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_cpu = 1		  LOAD p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 *   UNLOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __schedule() (put 'p' to sleep)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			  smp_rmb();</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock();</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_rq = 0			  LOAD p-&gt;on_cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in</span></span><br><span class="line"><span class="comment">	 * __schedule().  See the comment for smp_mb__after_spinlock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Form a control-dep-acquire with p-&gt;on_rq == 0 above, to ensure</span></span><br><span class="line"><span class="comment">	 * schedule()'s deactivate_task() has 'happened' and p will no longer</span></span><br><span class="line"><span class="comment">	 * care about it's own p-&gt;state. See the comment in __schedule().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_acquire__after_ctrl_dep();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're doing the wakeup (@success == 1), they did a dequeue (p-&gt;on_rq</span></span><br><span class="line"><span class="comment">	 * == 0), which means we need to do an enqueue, change p-&gt;state to</span></span><br><span class="line"><span class="comment">	 * TASK_WAKING such that we can unlock p-&gt;pi_lock before doing the</span></span><br><span class="line"><span class="comment">	 * enqueue, such as ttwu_queue_wakelist().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;state = TASK_WAKING;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the owning (remote) CPU is still in the middle of schedule() with</span></span><br><span class="line"><span class="comment">	 * this task as prev, considering queueing p on the remote CPUs wake_list</span></span><br><span class="line"><span class="comment">	 * which potentially sends an IPI instead of spinning on p-&gt;on_cpu to</span></span><br><span class="line"><span class="comment">	 * let the waker make forward progress. This is safe because IRQs are</span></span><br><span class="line"><span class="comment">	 * disabled and the IPI will deliver after on_cpu is cleared.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ensure we load task_cpu(p) after p-&gt;on_cpu:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * set_task_cpu(p, cpu);</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;cpu = @cpu</span></span><br><span class="line"><span class="comment">	 * __schedule() (switch to task 'p')</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spin_lock()		smp_cond_load_acquire(&amp;p-&gt;on_cpu)</span></span><br><span class="line"><span class="comment">	 *   STORE p-&gt;on_cpu = 1		LOAD p-&gt;cpu</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * to ensure we observe the correct CPU on which the task is currently</span></span><br><span class="line"><span class="comment">	 * scheduling.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp;</span><br><span class="line">	    ttwu_queue_wakelist(p, task_cpu(p), wake_flags | WF_ON_CPU))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the owning (remote) CPU is still in the middle of schedule() with</span></span><br><span class="line"><span class="comment">	 * this task as prev, wait until its done referencing the task.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the smp_store_release() in finish_task().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This ensures that tasks getting woken will be fully ordered against</span></span><br><span class="line"><span class="comment">	 * their previous state and preserve Program Order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_cond_load_acquire(&amp;p-&gt;on_cpu, !VAL);</span><br><span class="line"></span><br><span class="line">	cpu = select_task_rq(p, p-&gt;wake_cpu, SD_BALANCE_WAKE, wake_flags);</span><br><span class="line">	<span class="keyword">if</span> (task_cpu(p) != cpu) &#123;</span><br><span class="line">		wake_flags |= WF_MIGRATED;</span><br><span class="line">		psi_ttwu_dequeue(p);</span><br><span class="line">		set_task_cpu(p, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	cpu = task_cpu(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line">	ttwu_queue(p, cpu, wake_flags);</span><br><span class="line">unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (success)</span><br><span class="line">		ttwu_stat(p, task_cpu(p), wake_flags);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_invoke_on_locked_down_task - Invoke a function on task in fixed state</span></span><br><span class="line"><span class="comment"> * @p: Process for which the function is to be invoked.</span></span><br><span class="line"><span class="comment"> * @func: Function to invoke.</span></span><br><span class="line"><span class="comment"> * @arg: Argument to function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the specified task can be quickly locked into a definite state</span></span><br><span class="line"><span class="comment"> * (either sleeping or on a given runqueue), arrange to keep it in that</span></span><br><span class="line"><span class="comment"> * state while invoking @func(@arg).  This function can use -&gt;on_rq and</span></span><br><span class="line"><span class="comment"> * task_curr() to work out what the state is, if required.  Given that</span></span><br><span class="line"><span class="comment"> * @func can be invoked with a runqueue lock held, it had better be quite</span></span><br><span class="line"><span class="comment"> * lightweight.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	@false if the task slipped out from under the locks.</span></span><br><span class="line"><span class="comment"> *	@true if the task was locked onto a runqueue or is sleeping.</span></span><br><span class="line"><span class="comment"> *		However, @func can override this by returning @false.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">try_invoke_on_locked_down_task</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> (*func)(struct task_struct *t, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line">	raw_spin_lock_irq(&amp;p-&gt;pi_lock);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;on_rq) &#123;</span><br><span class="line">		rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (task_rq(p) == rq)</span><br><span class="line">			ret = func(p, arg);</span><br><span class="line">		rq_unlock(rq, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">		<span class="keyword">case</span> TASK_RUNNING:</span><br><span class="line">		<span class="keyword">case</span> TASK_WAKING:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			smp_rmb(); <span class="comment">// See smp_rmb() comment in try_to_wake_up().</span></span><br><span class="line">			<span class="keyword">if</span> (!p-&gt;on_rq)</span><br><span class="line">				ret = func(p, arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irq(&amp;p-&gt;pi_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_up_process - Wake up a specific process</span></span><br><span class="line"><span class="comment"> * @p: The process to be woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Attempt to wake up the nominated process and move it to the set of runnable</span></span><br><span class="line"><span class="comment"> * processes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the process was woken up, 0 if it was already running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function executes a full memory barrier before accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_process</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(wake_up_process);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_state</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, state, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform scheduler related setup for a newly forked process p.</span></span><br><span class="line"><span class="comment"> * p is forked by current.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __sched_fork() is basic setup used by init_idle() too:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched_fork(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;on_rq			= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;se.on_rq			= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.exec_start		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.sum_exec_runtime		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.prev_sum_exec_runtime	= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.nr_migrations		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;se.vruntime			= <span class="number">0</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;se.group_node);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	p-&gt;se.cfs_rq			= <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">	<span class="comment">/* Even if schedstat is disabled, there should not be garbage */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;p-&gt;se.statistics, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;se.statistics));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	RB_CLEAR_NODE(&amp;p-&gt;dl.rb_node);</span><br><span class="line">	init_dl_task_timer(&amp;p-&gt;dl);</span><br><span class="line">	init_dl_inactive_task_timer(&amp;p-&gt;dl);</span><br><span class="line">	__dl_clear_params(p);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;rt.run_list);</span><br><span class="line">	p-&gt;rt.timeout		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;rt.time_slice	= sched_rr_timeslice;</span><br><span class="line">	p-&gt;rt.on_rq		= <span class="number">0</span>;</span><br><span class="line">	p-&gt;rt.on_list		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	INIT_HLIST_HEAD(&amp;p-&gt;preempt_notifiers);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	p-&gt;capture_control = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_numa_balancing(clone_flags, p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	p-&gt;wake_entry.u_flags = CSD_TYPE_TTWU;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_STATIC_KEY_FALSE(sched_numa_balancing);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_numabalancing_state</span><span class="params">(<span class="keyword">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (enabled)</span><br><span class="line">		static_branch_enable(&amp;sched_numa_balancing);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		static_branch_disable(&amp;sched_numa_balancing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_SYSCTL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_numa_balancing</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> state = static_branch_likely(&amp;sched_numa_balancing);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (write &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	t = *table;</span><br><span class="line">	t.data = &amp;state;</span><br><span class="line">	err = proc_dointvec_minmax(&amp;t, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		set_numabalancing_state(state);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line"></span><br><span class="line">DEFINE_STATIC_KEY_FALSE(sched_schedstats);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __initdata __sched_schedstats = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_schedstats</span><span class="params">(<span class="keyword">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (enabled)</span><br><span class="line">		static_branch_enable(&amp;sched_schedstats);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		static_branch_disable(&amp;sched_schedstats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force_schedstat_enabled</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!schedstat_enabled()) &#123;</span><br><span class="line">		pr_info(<span class="string">"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\n"</span>);</span><br><span class="line">		static_branch_enable(&amp;sched_schedstats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">setup_schedstats</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!str)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This code is called before jump labels have been set up, so we can't</span></span><br><span class="line"><span class="comment">	 * change the static branch directly just yet.  Instead set a temporary</span></span><br><span class="line"><span class="comment">	 * variable so init_schedstats() can do it later.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str, <span class="string">"enable"</span>)) &#123;</span><br><span class="line">		__sched_schedstats = <span class="literal">true</span>;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(str, <span class="string">"disable"</span>)) &#123;</span><br><span class="line">		__sched_schedstats = <span class="literal">false</span>;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		pr_warn(<span class="string">"Unable to parse schedstats=\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">__setup(<span class="string">"schedstats="</span>, setup_schedstats);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_schedstats</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_schedstats(__sched_schedstats);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_SYSCTL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysctl_schedstats</span><span class="params">(struct ctl_table *table, <span class="keyword">int</span> write, <span class="keyword">void</span> *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">size_t</span> *lenp, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> state = static_branch_likely(&amp;sched_schedstats);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (write &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	t = *table;</span><br><span class="line">	t.data = &amp;state;</span><br><span class="line">	err = proc_dointvec_minmax(&amp;t, write, buffer, lenp, ppos);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	<span class="keyword">if</span> (write)</span><br><span class="line">		set_schedstats(state);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PROC_SYSCTL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !CONFIG_SCHEDSTATS */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_schedstats</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SCHEDSTATS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fork()/clone()-time setup:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	__sched_fork(clone_flags, p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We mark the process as NEW here. This guarantees that</span></span><br><span class="line"><span class="comment">	 * nobody will actually run it, and a signal or other external</span></span><br><span class="line"><span class="comment">	 * event cannot wake it up and insert it on the runqueue either.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;state = TASK_NEW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we do not leak PI boosting priority to the child.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;prio = current-&gt;normal_prio;</span><br><span class="line"></span><br><span class="line">	uclamp_fork(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Revert to default priority/policy on fork if requested.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p-&gt;sched_reset_on_fork)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) &#123;</span><br><span class="line">			p-&gt;policy = SCHED_NORMAL;</span><br><span class="line">			p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">			p-&gt;rt_priority = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PRIO_TO_NICE(p-&gt;static_prio) &lt; <span class="number">0</span>)</span><br><span class="line">			p-&gt;static_prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		p-&gt;prio = p-&gt;normal_prio = __normal_prio(p);</span><br><span class="line">		set_load_weight(p, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We don't need the reset flag anymore after the fork. It has</span></span><br><span class="line"><span class="comment">		 * fulfilled its duty:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;sched_reset_on_fork = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(p-&gt;prio))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line"></span><br><span class="line">	init_entity_runnable_average(&amp;p-&gt;se);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The child is not yet in the pid-hash so no cgroup attach races,</span></span><br><span class="line"><span class="comment">	 * and the cgroup is pinned to this child due to cgroup_fork()</span></span><br><span class="line"><span class="comment">	 * is ran before sched_fork().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Silence PROVE_RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	rseq_migrate(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're setting the CPU for the first time, we don't migrate,</span></span><br><span class="line"><span class="comment">	 * so use __set_task_cpu().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__set_task_cpu(p, smp_processor_id());</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_fork)</span><br><span class="line">		p-&gt;sched_class-&gt;task_fork(p);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_INFO</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sched_info_on()))</span><br><span class="line">		<span class="built_in">memset</span>(&amp;p-&gt;sched_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;sched_info));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">	p-&gt;on_cpu = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_task_preempt_count(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	plist_node_init(&amp;p-&gt;pushable_tasks, MAX_PRIO);</span><br><span class="line">	RB_CLEAR_NODE(&amp;p-&gt;pushable_dl_tasks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">to_ratio</span><span class="params">(u64 period, u64 runtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (runtime == RUNTIME_INF)</span><br><span class="line">		<span class="keyword">return</span> BW_UNIT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Doing this here saves a lot of checks in all</span></span><br><span class="line"><span class="comment">	 * the calling paths, and returning zero seems</span></span><br><span class="line"><span class="comment">	 * safe for them anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (period == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> div64_u64(runtime &lt;&lt; BW_SHIFT, period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * wake_up_new_task - wake up a newly created task for the first time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function will do some initial scheduler statistics housekeeping</span></span><br><span class="line"><span class="comment"> * that must be done for every newly created context, then puts the task</span></span><br><span class="line"><span class="comment"> * on the runqueue and wakes it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_new_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, rf.flags);</span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fork balancing, do it here and not earlier because:</span></span><br><span class="line"><span class="comment">	 *  - cpus_ptr can change in the fork path</span></span><br><span class="line"><span class="comment">	 *  - any previously selected CPU might disappear through hotplug</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,</span></span><br><span class="line"><span class="comment">	 * as we're not fully set-up yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;recent_used_cpu = task_cpu(p);</span><br><span class="line">	rseq_migrate(p);</span><br><span class="line">	__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	post_init_entity_util_avg(p);</span><br><span class="line"></span><br><span class="line">	activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">	trace_sched_wakeup_new(p);</span><br><span class="line">	check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Nothing relies on rq-&gt;lock after this, so its fine to</span></span><br><span class="line"><span class="comment">		 * drop it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unpin_lock(rq, &amp;rf);</span><br><span class="line">		p-&gt;sched_class-&gt;task_woken(rq, p);</span><br><span class="line">		rq_repin_lock(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_STATIC_KEY_FALSE</span><span class="params">(preempt_notifier_key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_inc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	static_branch_inc(&amp;preempt_notifier_key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_inc);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_dec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	static_branch_dec(&amp;preempt_notifier_key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_dec);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_register</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">"registering preempt_notifier while notifiers disabled\n"</span>);</span><br><span class="line"></span><br><span class="line">	hlist_add_head(&amp;notifier-&gt;link, &amp;current-&gt;preempt_notifiers);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_notifier_unregister - no longer interested in preemption notifications</span></span><br><span class="line"><span class="comment"> * @notifier: notifier struct to unregister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is *not* safe to call from within a preemption notifier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_notifier_unregister</span><span class="params">(struct preempt_notifier *notifier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	hlist_del(&amp;notifier-&gt;link);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_notifier_unregister);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __fire_sched_in_preempt_notifiers(struct task_struct *curr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">		notifier-&gt;ops-&gt;sched_in(notifier, raw_smp_processor_id());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">fire_sched_in_preempt_notifiers</span><span class="params">(struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		__fire_sched_in_preempt_notifiers(curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				   struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">preempt_notifier</span> *<span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry(notifier, &amp;curr-&gt;preempt_notifiers, link)</span><br><span class="line">		notifier-&gt;ops-&gt;sched_out(notifier, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				 struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;preempt_notifier_key))</span><br><span class="line">		__fire_sched_out_preempt_notifiers(curr, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_PREEMPT_NOTIFIERS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fire_sched_in_preempt_notifiers</span><span class="params">(struct task_struct *curr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">fire_sched_out_preempt_notifiers(struct task_struct *curr,</span><br><span class="line">				 struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PREEMPT_NOTIFIERS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prepare_task</span><span class="params">(struct task_struct *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Claim the task as running, we do this before switching to it</span></span><br><span class="line"><span class="comment">	 * such that any running task will have this set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	next-&gt;on_cpu = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">finish_task</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * After -&gt;on_cpu is cleared, the task can be moved to a different CPU.</span></span><br><span class="line"><span class="comment">	 * We must ensure this doesn't happen until the switch is completely</span></span><br><span class="line"><span class="comment">	 * finished.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In particular, the load of prev-&gt;state in finish_task_switch() must</span></span><br><span class="line"><span class="comment">	 * happen before this.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_store_release(&amp;prev-&gt;on_cpu, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">prepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since the runqueue lock will be released by the next</span></span><br><span class="line"><span class="comment">	 * task (which is an invalid locking op but in the case</span></span><br><span class="line"><span class="comment">	 * of the scheduler it's an obvious special-case), so we</span></span><br><span class="line"><span class="comment">	 * do an early lockdep release here:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_unpin_lock(rq, rf);</span><br><span class="line">	spin_release(&amp;rq-&gt;lock.dep_map, _THIS_IP_);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="comment">/* this is a valid case when another task releases the spinlock */</span></span><br><span class="line">	rq-&gt;lock.owner = next;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">finish_lock_switch</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are tracking spinlock dependencies then we have to</span></span><br><span class="line"><span class="comment">	 * fix up the runqueue lock - which gets 'carried over' from</span></span><br><span class="line"><span class="comment">	 * prev into current:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_acquire(&amp;rq-&gt;lock.dep_map, <span class="number">0</span>, <span class="number">0</span>, _THIS_IP_);</span><br><span class="line">	raw_spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NOP if the arch has not defined these:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> prepare_arch_switch</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> prepare_arch_switch(next)	do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> finish_arch_post_lock_switch</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> finish_arch_post_lock_switch()	do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_task_switch - prepare to switch tasks</span></span><br><span class="line"><span class="comment"> * @rq: the runqueue preparing to switch</span></span><br><span class="line"><span class="comment"> * @prev: the current task that is being switched out</span></span><br><span class="line"><span class="comment"> * @next: the task we are going to switch to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called with the rq lock held and interrupts off. It must</span></span><br><span class="line"><span class="comment"> * be paired with a subsequent finish_task_switch after the context</span></span><br><span class="line"><span class="comment"> * switch.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * prepare_task_switch sets up locking and calls architecture specific</span></span><br><span class="line"><span class="comment"> * hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">prepare_task_switch(struct rq *rq, struct task_struct *prev,</span><br><span class="line">		    struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">	kcov_prepare_switch(prev);</span><br><span class="line">	sched_info_switch(rq, prev, next);</span><br><span class="line">	perf_event_task_sched_out(prev, next);</span><br><span class="line">	rseq_preempt(prev);</span><br><span class="line">	fire_sched_out_preempt_notifiers(prev, next);</span><br><span class="line">	prepare_task(next);</span><br><span class="line">	prepare_arch_switch(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * finish_task_switch - clean up after a task-switch</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * finish_task_switch must be called after the context switch, paired</span></span><br><span class="line"><span class="comment"> * with a prepare_task_switch call before the context switch.</span></span><br><span class="line"><span class="comment"> * finish_task_switch will reconcile locking set up by prepare_task_switch,</span></span><br><span class="line"><span class="comment"> * and do any other architecture-specific cleanup actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we may have delayed dropping an mm in context_switch(). If</span></span><br><span class="line"><span class="comment"> * so, we finish that here outside of the runqueue lock. (Doing it</span></span><br><span class="line"><span class="comment"> * with the lock held can cause deadlocks; see schedule() for</span></span><br><span class="line"><span class="comment"> * details.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The context switch have flipped the stack from under us and restored the</span></span><br><span class="line"><span class="comment"> * local variables which were saved when this task called schedule() in the</span></span><br><span class="line"><span class="comment"> * past. prev == current is still correct but we need to recalculate this_rq</span></span><br><span class="line"><span class="comment"> * because prev may have moved to another CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct rq *<span class="title">finish_task_switch</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">this_rq</span>();</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">rq</span>-&gt;<span class="title">prev_mm</span>;</span></span><br><span class="line">	<span class="keyword">long</span> prev_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The previous task will have left us with a preempt_count of 2</span></span><br><span class="line"><span class="comment">	 * because it left us after:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	schedule()</span></span><br><span class="line"><span class="comment">	 *	  preempt_disable();			// 1</span></span><br><span class="line"><span class="comment">	 *	  __schedule()</span></span><br><span class="line"><span class="comment">	 *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, see FORK_PREEMPT_COUNT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ONCE(preempt_count() != <span class="number">2</span>*PREEMPT_DISABLE_OFFSET,</span><br><span class="line">		      <span class="string">"corrupted preempt_count: %s/%d/0x%x\n"</span>,</span><br><span class="line">		      current-&gt;comm, current-&gt;pid, preempt_count()))</span><br><span class="line">		preempt_count_set(FORK_PREEMPT_COUNT);</span><br><span class="line"></span><br><span class="line">	rq-&gt;prev_mm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A task struct has one reference for the use as "current".</span></span><br><span class="line"><span class="comment">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span></span><br><span class="line"><span class="comment">	 * schedule one last time. The schedule call will never return, and</span></span><br><span class="line"><span class="comment">	 * the scheduled task must drop that reference.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in</span></span><br><span class="line"><span class="comment">	 * finish_task), otherwise a concurrent wakeup can get prev</span></span><br><span class="line"><span class="comment">	 * running on another CPU and we could rave with its RUNNING -&gt; DEAD</span></span><br><span class="line"><span class="comment">	 * transition, resulting in a double drop.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev_state = prev-&gt;state;</span><br><span class="line">	vtime_task_switch(prev);</span><br><span class="line">	perf_event_task_sched_in(prev, current);</span><br><span class="line">	finish_task(prev);</span><br><span class="line">	finish_lock_switch(rq);</span><br><span class="line">	finish_arch_post_lock_switch();</span><br><span class="line">	kcov_finish_switch(current);</span><br><span class="line"></span><br><span class="line">	fire_sched_in_preempt_notifiers(current);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When switching through a kernel thread, the loop in</span></span><br><span class="line"><span class="comment">	 * membarrier_&#123;private,global&#125;_expedited() may have observed that</span></span><br><span class="line"><span class="comment">	 * kernel thread and not issued an IPI. It is therefore possible to</span></span><br><span class="line"><span class="comment">	 * schedule between user-&gt;kernel-&gt;user threads without passing though</span></span><br><span class="line"><span class="comment">	 * switch_mm(). Membarrier requires a barrier after storing to</span></span><br><span class="line"><span class="comment">	 * rq-&gt;curr, before returning to userspace, so provide them here:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - a full memory barrier for &#123;PRIVATE,GLOBAL&#125;_EXPEDITED, implicitly</span></span><br><span class="line"><span class="comment">	 *   provided by mmdrop(),</span></span><br><span class="line"><span class="comment">	 * - a sync_core for SYNC_CORE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		membarrier_mm_sync_core_before_usermode(mm);</span><br><span class="line">		mmdrop(mm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(prev_state == TASK_DEAD)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;sched_class-&gt;task_dead)</span><br><span class="line">			prev-&gt;sched_class-&gt;task_dead(prev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Remove function-return probe instances associated with this</span></span><br><span class="line"><span class="comment">		 * task and put them back on the free list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kprobe_flush_task(prev);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Task is done with its stack. */</span></span><br><span class="line">		put_task_stack(prev);</span><br><span class="line"></span><br><span class="line">		put_task_struct_rcu_user(prev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tick_nohz_task_switch();</span><br><span class="line">	<span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rq-&gt;lock is NOT held, but preemption is disabled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __balance_callback(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">head</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(struct rq *rq);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span><br><span class="line">	head = rq-&gt;balance_callback;</span><br><span class="line">	rq-&gt;balance_callback = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		func = (<span class="keyword">void</span> (*)(struct rq *))head-&gt;func;</span><br><span class="line">		next = head-&gt;next;</span><br><span class="line">		head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		head = next;</span><br><span class="line"></span><br><span class="line">		func(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">balance_callback</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(rq-&gt;balance_callback))</span><br><span class="line">		__balance_callback(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">balance_callback</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_tail - first thing a freshly forked thread must call.</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">schedule_tail</span><span class="params">(struct task_struct *prev)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(rq-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * New tasks start with FORK_PREEMPT_COUNT, see there and</span></span><br><span class="line"><span class="comment">	 * finish_task_switch() for details.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count</span></span><br><span class="line"><span class="comment">	 * and the preempt_enable() will end up enabling preemption (on</span></span><br><span class="line"><span class="comment">	 * PREEMPT_COUNT kernels).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	rq = finish_task_switch(prev);</span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;set_child_tid)</span><br><span class="line">		put_user(task_pid_vnr(current), current-&gt;set_child_tid);</span><br><span class="line"></span><br><span class="line">	calculate_sigpending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context_switch - switch to the new MM and the new thread's register state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *</span></span><br><span class="line"><span class="class"><span class="title">context_switch</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>,</span></span><br><span class="line"><span class="class">	       <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	prepare_task_switch(rq, prev, next);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For paravirt, this is coupled with an exit in switch_to to</span></span><br><span class="line"><span class="comment">	 * combine the page table reload and the switch backend into</span></span><br><span class="line"><span class="comment">	 * one hypercall.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	arch_start_context_switch(prev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * kernel -&gt; kernel   lazy + transfer active</span></span><br><span class="line"><span class="comment">	 *   user -&gt; kernel   lazy + mmgrab() active</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * kernel -&gt;   user   switch + mmdrop() active</span></span><br><span class="line"><span class="comment">	 *   user -&gt;   user   switch</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!next-&gt;mm) &#123;                                <span class="comment">// to kernel</span></span><br><span class="line">		enter_lazy_tlb(prev-&gt;active_mm, next);</span><br><span class="line"></span><br><span class="line">		next-&gt;active_mm = prev-&gt;active_mm;</span><br><span class="line">		<span class="keyword">if</span> (prev-&gt;mm)                           <span class="comment">// from user</span></span><br><span class="line">			mmgrab(prev-&gt;active_mm);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;                                        <span class="comment">// to user</span></span><br><span class="line">		membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * sys_membarrier() requires an smp_mb() between setting</span></span><br><span class="line"><span class="comment">		 * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The below provides this either through switch_mm(), or in</span></span><br><span class="line"><span class="comment">		 * case 'prev-&gt;active_mm == next-&gt;mm' through</span></span><br><span class="line"><span class="comment">		 * finish_task_switch()'s mmdrop().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!prev-&gt;mm) &#123;                        <span class="comment">// from kernel</span></span><br><span class="line">			<span class="comment">/* will mmdrop() in finish_task_switch(). */</span></span><br><span class="line">			rq-&gt;prev_mm = prev-&gt;active_mm;</span><br><span class="line">			prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line"></span><br><span class="line">	prepare_lock_switch(rq, next, rf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">	switch_to(prev, next, prev);</span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nr_running and nr_context_switches:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * externally visible scheduler statistics: current number of runnable</span></span><br><span class="line"><span class="comment"> * threads, total number of context switches performed since bootup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_online_cpu(i)</span><br><span class="line">		sum += cpu_rq(i)-&gt;nr_running;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if only the current task is running on the CPU.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Caution: this function does not check that the caller has disabled</span></span><br><span class="line"><span class="comment"> * preemption, thus the result might have a time-of-check-to-time-of-use</span></span><br><span class="line"><span class="comment"> * race.  The caller is responsible to use it correctly, for example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - from a non-preemptible section (of course)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - from a thread that is bound to a single CPU</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - in a loop with very short iterations (e.g. a polling loop)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">single_task_running</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> raw_rq()-&gt;nr_running == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_task_running);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">nr_context_switches</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		sum += cpu_rq(i)-&gt;nr_switches;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Consumers of these two interfaces, like for example the cpuidle menu</span></span><br><span class="line"><span class="comment"> * governor, are using nonsensical data. Preferring shallow idle state selection</span></span><br><span class="line"><span class="comment"> * for a CPU that has IO-wait which might not even end up running the task when</span></span><br><span class="line"><span class="comment"> * it does become runnable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_iowait_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> atomic_read(&amp;cpu_rq(cpu)-&gt;nr_iowait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO-wait accounting, and how its mostly bollocks (on SMP).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The idea behind IO-wait account is to account the idle time that we could</span></span><br><span class="line"><span class="comment"> * have spend running if it were not for IO. That is, if we were to improve the</span></span><br><span class="line"><span class="comment"> * storage performance, we'd have a proportional reduction in IO-wait time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This all works nicely on UP, where, when a task blocks on IO, we account</span></span><br><span class="line"><span class="comment"> * idle time as IO-wait, because if the storage were faster, it could've been</span></span><br><span class="line"><span class="comment"> * running and we'd not be idle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This has been extended to SMP, by doing the same for each CPU. This however</span></span><br><span class="line"><span class="comment"> * is broken.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Imagine for instance the case where two tasks block on one CPU, only the one</span></span><br><span class="line"><span class="comment"> * CPU will have IO-wait accounted, while the other has regular idle. Even</span></span><br><span class="line"><span class="comment"> * though, if the storage were faster, both could've ran at the same time,</span></span><br><span class="line"><span class="comment"> * utilising both CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This means, that when looking globally, the current IO-wait accounting on</span></span><br><span class="line"><span class="comment"> * SMP is a lower bound, by reason of under accounting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Worse, since the numbers are provided per CPU, they are sometimes</span></span><br><span class="line"><span class="comment"> * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly</span></span><br><span class="line"><span class="comment"> * associated with any one particular CPU, it can wake to another CPU than it</span></span><br><span class="line"><span class="comment"> * blocked on. This means the per CPU IO-wait number is meaningless.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Task CPU affinities can make all that even more 'interesting'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nr_iowait</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i)</span><br><span class="line">		sum += nr_iowait_cpu(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_exec - execve() is a valuable balancing opportunity, because at</span></span><br><span class="line"><span class="comment"> * this point the task has the smallest effective memory and cache footprint.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_exec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	dest_cpu = p-&gt;sched_class-&gt;select_task_rq(p, task_cpu(p), SD_BALANCE_EXEC, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (dest_cpu == smp_processor_id())</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(cpu_active(dest_cpu))) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, dest_cpu &#125;;</span><br><span class="line"></span><br><span class="line">		raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">		stop_one_cpu(task_cpu(p), migration_cpu_stop, &amp;arg);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(struct kernel_stat, kstat);</span><br><span class="line">DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);</span><br><span class="line"></span><br><span class="line">EXPORT_PER_CPU_SYMBOL(kstat);</span><br><span class="line">EXPORT_PER_CPU_SYMBOL(kernel_cpustat);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The function fair_sched_class.update_curr accesses the struct curr</span></span><br><span class="line"><span class="comment"> * and its field curr-&gt;exec_start; when called from task_sched_runtime(),</span></span><br><span class="line"><span class="comment"> * we observe a high rate of cache misses in practice.</span></span><br><span class="line"><span class="comment"> * Prefetching this data results in improved performance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prefetch_curr_exec_start</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = (&amp;<span class="title">p</span>-&gt;<span class="title">se</span>)-&gt;<span class="title">cfs_rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> = (&amp;<span class="title">task_rq</span>(<span class="title">p</span>)-&gt;<span class="title">cfs</span>)-&gt;<span class="title">curr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	prefetch(curr);</span><br><span class="line">	prefetch(&amp;curr-&gt;exec_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return accounted runtime for the task.</span></span><br><span class="line"><span class="comment"> * In case the task is currently running, return the runtime plus current's</span></span><br><span class="line"><span class="comment"> * pending runtime that have not been accounted yet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">task_sched_runtime</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	u64 ns;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_64BIT) &amp;&amp; defined(CONFIG_SMP)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 64-bit doesn't need locks to atomically read a 64-bit value.</span></span><br><span class="line"><span class="comment">	 * So we have a optimization chance when the task's delta_exec is 0.</span></span><br><span class="line"><span class="comment">	 * Reading -&gt;on_cpu is racy, but this is ok.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If we race with it leaving CPU, we'll take a lock. So we're correct.</span></span><br><span class="line"><span class="comment">	 * If we race with it entering CPU, unaccounted time is 0. This is</span></span><br><span class="line"><span class="comment">	 * indistinguishable from the read occurring a few cycles earlier.</span></span><br><span class="line"><span class="comment">	 * If we see -&gt;on_cpu without -&gt;on_rq, the task is leaving, and has</span></span><br><span class="line"><span class="comment">	 * been accounted, so we're correct here as well.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;on_cpu || !task_on_rq_queued(p))</span><br><span class="line">		<span class="keyword">return</span> p-&gt;se.sum_exec_runtime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be -&gt;curr _and_ -&gt;on_rq.  If dequeued, we would</span></span><br><span class="line"><span class="comment">	 * project cycles that may never be accounted to this</span></span><br><span class="line"><span class="comment">	 * thread, breaking clock_gettime().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_current(rq, p) &amp;&amp; task_on_rq_queued(p)) &#123;</span><br><span class="line">		prefetch_curr_exec_start(p);</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line">		p-&gt;sched_class-&gt;update_curr(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	ns = p-&gt;se.sum_exec_runtime;</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU(<span class="keyword">unsigned</span> <span class="keyword">long</span>, thermal_pressure);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_set_thermal_pressure</span><span class="params">(struct cpumask *cpus,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">unsigned</span> <span class="keyword">long</span> th_pressure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	for_each_cpu(cpu, cpus)</span><br><span class="line">		WRITE_ONCE(per_cpu(thermal_pressure, cpu), th_pressure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function gets called by the timer code, with HZ frequency.</span></span><br><span class="line"><span class="comment"> * We call it with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler_tick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">rq</span>-&gt;<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> thermal_pressure;</span><br><span class="line"></span><br><span class="line">	arch_scale_freq_tick();</span><br><span class="line">	sched_clock_tick();</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	thermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));</span><br><span class="line">	update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure);</span><br><span class="line">	curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line">	calc_global_load_tick(rq);</span><br><span class="line">	psi_task_tick(rq);</span><br><span class="line"></span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	perf_event_task_tick();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq-&gt;idle_balance = idle_cpu(cpu);</span><br><span class="line">	trigger_load_balance(rq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;</span><br><span class="line">	<span class="keyword">atomic_t</span>		state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Values for -&gt;state, see diagram below. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_OFFLINE	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_OFFLINING	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK_SCHED_REMOTE_RUNNING	2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * State diagram for -&gt;state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          TICK_SCHED_REMOTE_OFFLINE</span></span><br><span class="line"><span class="comment"> *                    |   ^</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    |   | sched_tick_remote()</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    +--TICK_SCHED_REMOTE_OFFLINING</span></span><br><span class="line"><span class="comment"> *                    |   ^</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> * sched_tick_start() |   | sched_tick_stop()</span></span><br><span class="line"><span class="comment"> *                    |   |</span></span><br><span class="line"><span class="comment"> *                    V   |</span></span><br><span class="line"><span class="comment"> *          TICK_SCHED_REMOTE_RUNNING</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()</span></span><br><span class="line"><span class="comment"> * and sched_tick_start() are happy to leave the state in RUNNING.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> __<span class="title">percpu</span> *<span class="title">tick_work_cpu</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_remote</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> *<span class="title">dwork</span> = <span class="title">to_delayed_work</span>(<span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span> = <span class="title">container_of</span>(<span class="title">dwork</span>, <span class="title">struct</span> <span class="title">tick_work</span>, <span class="title">work</span>);</span></span><br><span class="line">	<span class="keyword">int</span> cpu = twork-&gt;cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	u64 delta;</span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Handle the tick only if it appears the remote CPU is running in full</span></span><br><span class="line"><span class="comment">	 * dynticks mode. The check is racy by nature, but missing a tick or</span></span><br><span class="line"><span class="comment">	 * having one too much is no big deal because the scheduler tick updates</span></span><br><span class="line"><span class="comment">	 * statistics and checks timeslices in a time-independent way, regardless</span></span><br><span class="line"><span class="comment">	 * of when exactly it is running.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!tick_nohz_tick_stopped_cpu(cpu))</span><br><span class="line">		<span class="keyword">goto</span> out_requeue;</span><br><span class="line"></span><br><span class="line">	rq_lock_irq(rq, &amp;rf);</span><br><span class="line">	curr = rq-&gt;curr;</span><br><span class="line">	<span class="keyword">if</span> (cpu_is_offline(cpu))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_idle_task(curr)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make sure the next tick runs within a reasonable</span></span><br><span class="line"><span class="comment">		 * amount of time.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		delta = rq_clock_task(rq) - curr-&gt;se.exec_start;</span><br><span class="line">		WARN_ON_ONCE(delta &gt; (u64)NSEC_PER_SEC * <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	calc_load_nohz_remote(rq);</span><br><span class="line">out_unlock:</span><br><span class="line">	rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">out_requeue:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Run the remote tick once per second (1Hz). This arbitrary</span></span><br><span class="line"><span class="comment">	 * frequency is large enough to avoid overload but short enough</span></span><br><span class="line"><span class="comment">	 * to keep scheduler internal stats reasonably up to date.  But</span></span><br><span class="line"><span class="comment">	 * first update state to reflect hotplug activity if required.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	os = atomic_fetch_add_unless(&amp;twork-&gt;state, <span class="number">-1</span>, TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_OFFLINE);</span><br><span class="line">	<span class="keyword">if</span> (os == TICK_SCHED_REMOTE_RUNNING)</span><br><span class="line">		queue_delayed_work(system_unbound_wq, dwork, HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_start</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TICK))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!tick_work_cpu);</span><br><span class="line"></span><br><span class="line">	twork = per_cpu_ptr(tick_work_cpu, cpu);</span><br><span class="line">	os = atomic_xchg(&amp;twork-&gt;state, TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	<span class="keyword">if</span> (os == TICK_SCHED_REMOTE_OFFLINE) &#123;</span><br><span class="line">		twork-&gt;cpu = cpu;</span><br><span class="line">		INIT_DELAYED_WORK(&amp;twork-&gt;work, sched_tick_remote);</span><br><span class="line">		queue_delayed_work(system_unbound_wq, &amp;twork-&gt;work, HZ);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_tick_stop</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tick_work</span> *<span class="title">twork</span>;</span></span><br><span class="line">	<span class="keyword">int</span> os;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (housekeeping_cpu(cpu, HK_FLAG_TICK))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(!tick_work_cpu);</span><br><span class="line"></span><br><span class="line">	twork = per_cpu_ptr(tick_work_cpu, cpu);</span><br><span class="line">	<span class="comment">/* There cannot be competing actions, but don't rely on stop-machine. */</span></span><br><span class="line">	os = atomic_xchg(&amp;twork-&gt;state, TICK_SCHED_REMOTE_OFFLINING);</span><br><span class="line">	WARN_ON_ONCE(os != TICK_SCHED_REMOTE_RUNNING);</span><br><span class="line">	<span class="comment">/* Don't cancel, as this would mess up the state machine. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_HOTPLUG_CPU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">sched_tick_offload_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tick_work_cpu = alloc_percpu(struct tick_work);</span><br><span class="line">	BUG_ON(!tick_work_cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !CONFIG_NO_HZ_FULL */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_tick_start</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_tick_stop</span><span class="params">(<span class="keyword">int</span> cpu)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PREEMPTION) &amp;&amp; (defined(CONFIG_DEBUG_PREEMPT) || \</span></span><br><span class="line">				defined(CONFIG_TRACE_PREEMPT_TOGGLE))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the value passed in is equal to the current preempt count</span></span><br><span class="line"><span class="comment"> * then we just disabled preemption. Start timing the latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_start</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preempt_count() == val) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> ip = get_lock_parent_ip();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">		current-&gt;preempt_disable_ip = ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		trace_preempt_off(CALLER_ADDR0, ip);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_count_add</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Underflow?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON((preempt_count() &lt; <span class="number">0</span>)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__preempt_count_add(val);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Spinlock count overflowing soon?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DEBUG_LOCKS_WARN_ON((preempt_count() &amp; PREEMPT_MASK) &gt;=</span><br><span class="line">				PREEMPT_MASK - <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	preempt_latency_start(val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(preempt_count_add);</span><br><span class="line">NOKPROBE_SYMBOL(preempt_count_add);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the value passed in equals to the current preempt count</span></span><br><span class="line"><span class="comment"> * then we just enabled preemption. Stop timing the latency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_stop</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preempt_count() == val)</span><br><span class="line">		trace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preempt_count_sub</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Underflow?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON(val &gt; preempt_count()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Is the spinlock portion underflowing?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (DEBUG_LOCKS_WARN_ON((val &lt; PREEMPT_MASK) &amp;&amp;</span><br><span class="line">			!(preempt_count() &amp; PREEMPT_MASK)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	preempt_latency_stop(val);</span><br><span class="line">	__preempt_count_sub(val);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(preempt_count_sub);</span><br><span class="line">NOKPROBE_SYMBOL(preempt_count_sub);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_start</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preempt_latency_stop</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_preempt_disable_ip</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">return</span> p-&gt;preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Print scheduling while atomic bug:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __schedule_bug(struct task_struct *prev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Save this before calling printk(), since that will clobber it */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip = get_preempt_disable_ip(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oops_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR <span class="string">"BUG: scheduling while atomic: %s/%d/0x%08x\n"</span>,</span><br><span class="line">		prev-&gt;comm, prev-&gt;pid, preempt_count());</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(prev);</span><br><span class="line">	print_modules();</span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		print_irqtrace_events(prev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_PREEMPT)</span><br><span class="line">	    &amp;&amp; in_atomic_preempt_off()) &#123;</span><br><span class="line">		pr_err(<span class="string">"Preemption disabled at:"</span>);</span><br><span class="line">		print_ip_sym(KERN_ERR, preempt_disable_ip);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (panic_on_warn)</span><br><span class="line">		panic(<span class="string">"scheduling while atomic\n"</span>);</span><br><span class="line"></span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Various schedule()-time debugging checks and statistics:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">schedule_debug</span><span class="params">(struct task_struct *prev, <span class="keyword">bool</span> preempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_STACK_END_CHECK</span></span><br><span class="line">	<span class="keyword">if</span> (task_stack_end_corrupted(prev))</span><br><span class="line">		panic(<span class="string">"corrupted stack end detected inside scheduler\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_scs_end_corrupted(prev))</span><br><span class="line">		panic(<span class="string">"corrupted shadow stack detected inside scheduler\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state &amp;&amp; prev-&gt;non_block_count) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"BUG: scheduling in a non-blocking section: %s/%d/%i\n"</span>,</span><br><span class="line">			prev-&gt;comm, prev-&gt;pid, prev-&gt;non_block_count);</span><br><span class="line">		dump_stack();</span><br><span class="line">		add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic_preempt_off())) &#123;</span><br><span class="line">		__schedule_bug(prev);</span><br><span class="line">		preempt_count_set(PREEMPT_DISABLED);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_sleep_check();</span><br><span class="line"></span><br><span class="line">	profile_hit(SCHED_PROFILING, __builtin_return_address(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	schedstat_inc(this_rq()-&gt;sched_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_prev_task_balance</span><span class="params">(struct rq *rq, struct task_struct *prev,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must do the balancing pass before put_prev_task(), such</span></span><br><span class="line"><span class="comment">	 * that when we release the rq-&gt;lock the task is in the same</span></span><br><span class="line"><span class="comment">	 * state as before we took rq-&gt;lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We can terminate the balance pass as soon as we know there is</span></span><br><span class="line"><span class="comment">	 * a runnable task of @class priority or higher.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_class_range(class, prev-&gt;sched_class, &amp;idle_sched_class) &#123;</span><br><span class="line">		<span class="keyword">if</span> (class-&gt;balance(rq, prev, rf))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	put_prev_task(rq, prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">pick_next_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, <span class="title">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, <span class="title">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment">	 * call that function directly, but only if the @prev task wasn't of a</span></span><br><span class="line"><span class="comment">	 * higher scheduling class, because otherwise those loose the</span></span><br><span class="line"><span class="comment">	 * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">		    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line"></span><br><span class="line">		p = pick_next_task_fair(rq, prev, rf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">		<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">			put_prev_task(rq, prev);</span><br><span class="line">			p = pick_next_task_idle(rq);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	put_prev_task_balance(rq, prev, rf);</span><br><span class="line"></span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">	BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __schedule() is the main scheduler function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The main means of driving the scheduler and thus entering this function are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return</span></span><br><span class="line"><span class="comment"> *      paths. For example, see arch/x86/entry_64.S.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      To drive preemption between tasks, the scheduler sets the flag in timer</span></span><br><span class="line"><span class="comment"> *      interrupt handler scheduler_tick().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   3. Wakeups don't really cause entry into schedule(). They add a</span></span><br><span class="line"><span class="comment"> *      task to the run-queue and that's it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Now, if the new task added to the run-queue preempts the current</span></span><br><span class="line"><span class="comment"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets</span></span><br><span class="line"><span class="comment"> *      called on the nearest possible occasion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is preemptible (CONFIG_PREEMPTION=y):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in syscall or exception context, at the next outmost</span></span><br><span class="line"><span class="comment"> *           preempt_enable(). (this might be as soon as the wake_up()'s</span></span><br><span class="line"><span class="comment"> *           spin_unlock()!)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         - in IRQ context, return from interrupt-handler to</span></span><br><span class="line"><span class="comment"> *           preemptible context</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       - If the kernel is not preemptible (CONFIG_PREEMPTION is not set)</span></span><br><span class="line"><span class="comment"> *         then at the next:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          - cond_resched() call</span></span><br><span class="line"><span class="comment"> *          - explicit schedule() call</span></span><br><span class="line"><span class="comment"> *          - return from syscall or exception to user-space</span></span><br><span class="line"><span class="comment"> *          - return from interrupt-handler to user-space</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: must be called with preemption disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace __schedule(<span class="keyword">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prev_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	schedule_debug(prev, preempt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	rcu_note_context_switch(preempt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure that signal_pending_state()-&gt;signal_pending() below</span></span><br><span class="line"><span class="comment">	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">	 * done by the caller to avoid the race with signal_wake_up():</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * __set_current_state(@state)		signal_wake_up()</span></span><br><span class="line"><span class="comment">	 * schedule()				  set_tsk_thread_flag(p, TIF_SIGPENDING)</span></span><br><span class="line"><span class="comment">	 *					  wake_up_state(p, state)</span></span><br><span class="line"><span class="comment">	 *   LOCK rq-&gt;lock			    LOCK p-&gt;pi_state</span></span><br><span class="line"><span class="comment">	 *   smp_mb__after_spinlock()		    smp_mb__after_spinlock()</span></span><br><span class="line"><span class="comment">	 *     if (signal_pending_state())	    if (p-&gt;state &amp; @state)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also, the membarrier system call requires a full memory barrier</span></span><br><span class="line"><span class="comment">	 * after coming from user-space, before storing to rq-&gt;curr.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">	rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We must load prev-&gt;state once (task_struct::state is volatile), such</span></span><br><span class="line"><span class="comment">	 * that:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  - we form a control dependency vs deactivate_task() below.</span></span><br><span class="line"><span class="comment">	 *  - ptrace_&#123;,un&#125;freeze_traced() can change -&gt;state underneath us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev_state = prev-&gt;state;</span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev_state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(prev_state, prev)) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			prev-&gt;sched_contributes_to_load =</span><br><span class="line">				(prev_state &amp; TASK_UNINTERRUPTIBLE) &amp;&amp;</span><br><span class="line">				!(prev_state &amp; TASK_NOLOAD) &amp;&amp;</span><br><span class="line">				!(prev-&gt;flags &amp; PF_FROZEN);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;sched_contributes_to_load)</span><br><span class="line">				rq-&gt;nr_uninterruptible++;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * __schedule()			ttwu()</span></span><br><span class="line"><span class="comment">			 *   prev_state = prev-&gt;state;    if (p-&gt;on_rq &amp;&amp; ...)</span></span><br><span class="line"><span class="comment">			 *   if (prev_state)		    goto out;</span></span><br><span class="line"><span class="comment">			 *     p-&gt;on_rq = 0;		  smp_acquire__after_ctrl_dep();</span></span><br><span class="line"><span class="comment">			 *				  p-&gt;state = TASK_WAKING</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * Where __schedule() and ttwu() have matching control dependencies.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * After this, schedule() must not care about p-&gt;state any more.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">				atomic_inc(&amp;rq-&gt;nr_iowait);</span><br><span class="line">				delayacct_blkio_start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * RCU users of rcu_dereference(rq-&gt;curr) may not see</span></span><br><span class="line"><span class="comment">		 * changes to task_struct made by pick_next_task().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RCU_INIT_POINTER(rq-&gt;curr, next);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The membarrier system call requires each architecture</span></span><br><span class="line"><span class="comment">		 * to have a full memory barrier after updating</span></span><br><span class="line"><span class="comment">		 * rq-&gt;curr, before returning to user-space.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Here are the schemes providing that barrier on the</span></span><br><span class="line"><span class="comment">		 * various architectures:</span></span><br><span class="line"><span class="comment">		 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.</span></span><br><span class="line"><span class="comment">		 *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.</span></span><br><span class="line"><span class="comment">		 * - finish_lock_switch() for weakly-ordered</span></span><br><span class="line"><span class="comment">		 *   architectures where spin_unlock is a full barrier,</span></span><br><span class="line"><span class="comment">		 * - switch_to() for arm64 (weakly-ordered, spin_unlock</span></span><br><span class="line"><span class="comment">		 *   is a RELEASE barrier),</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		++*switch_count;</span><br><span class="line"></span><br><span class="line">		psi_sched_switch(prev, next, !task_on_rq_queued(prev));</span><br><span class="line"></span><br><span class="line">		trace_sched_switch(preempt, prev, next);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">do_task_dead</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Causes final put_task_struct in finish_task_switch(): */</span></span><br><span class="line">	set_special_state(TASK_DEAD);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell freezer to ignore us: */</span></span><br><span class="line">	current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line"></span><br><span class="line">	__schedule(<span class="literal">false</span>);</span><br><span class="line">	BUG();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid "noreturn function does return" - but don't continue if BUG() is a NOP: */</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">		cpu_relax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sched_submit_work</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tsk-&gt;state)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If a worker went to sleep, notify and ask workqueue whether</span></span><br><span class="line"><span class="comment">	 * it wants to wake up a task to maintain concurrency.</span></span><br><span class="line"><span class="comment">	 * As this function is called inside the schedule() context,</span></span><br><span class="line"><span class="comment">	 * we disable preemption to avoid it calling schedule() again</span></span><br><span class="line"><span class="comment">	 * in the possible wakeup of a kworker and because wq_worker_sleeping()</span></span><br><span class="line"><span class="comment">	 * requires it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;flags &amp; (PF_WQ_WORKER | PF_IO_WORKER)) &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">			wq_worker_sleeping(tsk);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_wq_worker_sleeping(tsk);</span><br><span class="line">		preempt_enable_no_resched();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk_is_pi_blocked(tsk))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are going to sleep and we have plugged IO queued,</span></span><br><span class="line"><span class="comment">	 * make sure to submit it to avoid deadlocks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (blk_needs_flush_plug(tsk))</span><br><span class="line">		blk_schedule_flush_plug(tsk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_update_worker</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;flags &amp; (PF_WQ_WORKER | PF_IO_WORKER)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">			wq_worker_running(tsk);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_wq_worker_running(tsk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> = <span class="title">current</span>;</span></span><br><span class="line"></span><br><span class="line">	sched_submit_work(tsk);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">	sched_update_worker(tsk);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * synchronize_rcu_tasks() makes sure that no task is stuck in preempted</span></span><br><span class="line"><span class="comment"> * state (have scheduled out non-voluntarily) by making sure that all</span></span><br><span class="line"><span class="comment"> * tasks have either left the run queue or have gone into user space.</span></span><br><span class="line"><span class="comment"> * As idle tasks do not do either, they must not ever be preempted</span></span><br><span class="line"><span class="comment"> * (schedule out non-voluntarily).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * schedule_idle() is similar to schedule_preempt_disable() except that it</span></span><br><span class="line"><span class="comment"> * never enables preemption because it does not call sched_submit_work().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">schedule_idle</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As this skips calling sched_submit_work(), which the idle task does</span></span><br><span class="line"><span class="comment">	 * regardless because that function is a nop when the task is in a</span></span><br><span class="line"><span class="comment">	 * TASK_RUNNING state, make sure this isn't used someplace that the</span></span><br><span class="line"><span class="comment">	 * current task can be in any other state. Note, idle is always in the</span></span><br><span class="line"><span class="comment">	 * TASK_RUNNING state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(current-&gt;state);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONTEXT_TRACKING</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule_user</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we come here after a random call to set_need_resched(),</span></span><br><span class="line"><span class="comment">	 * or we have been woken up remotely but the IPI has not yet arrived,</span></span><br><span class="line"><span class="comment">	 * we haven't yet exited the RCU idle mode. Do it here manually until</span></span><br><span class="line"><span class="comment">	 * we find a better solution.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * NB: There are buggy callers of this function.  Ideally we</span></span><br><span class="line"><span class="comment">	 * should warn if prev_state != CONTEXT_USER, but that will trigger</span></span><br><span class="line"><span class="comment">	 * too frequently to make sense yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_state = exception_enter();</span><br><span class="line">	schedule();</span><br><span class="line">	exception_exit(prev_state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_preempt_disabled - called with preemption disabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns with preemption disabled. Note: preempt_count must be 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">schedule_preempt_disabled</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line">	schedule();</span><br><span class="line">	preempt_disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule_common</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because the function tracer can trace preempt_count_sub()</span></span><br><span class="line"><span class="comment">		 * and it also uses preempt_enable/disable_notrace(), if</span></span><br><span class="line"><span class="comment">		 * NEED_RESCHED is set, the preempt_enable_notrace() called</span></span><br><span class="line"><span class="comment">		 * by the function tracer will call this function again and</span></span><br><span class="line"><span class="comment">		 * cause infinite recursion.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Preemption must be disabled here before the function</span></span><br><span class="line"><span class="comment">		 * tracer can trace. Break up preempt_disable() into two</span></span><br><span class="line"><span class="comment">		 * calls. One to disable preemption without fear of being</span></span><br><span class="line"><span class="comment">		 * traced. The other to still record the preemption latency,</span></span><br><span class="line"><span class="comment">		 * which can also be traced by the function tracer.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		preempt_disable_notrace();</span><br><span class="line">		preempt_latency_start(<span class="number">1</span>);</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		preempt_latency_stop(<span class="number">1</span>);</span><br><span class="line">		preempt_enable_no_resched_notrace();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check again in case we missed a preemption opportunity</span></span><br><span class="line"><span class="comment">		 * between schedule and now.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPTION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the entry point to schedule() from in-kernel preemption</span></span><br><span class="line"><span class="comment"> * off of preempt_enable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is a non-zero preempt_count or interrupts are disabled,</span></span><br><span class="line"><span class="comment">	 * we do not want to preempt the current task. Just return..</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	preempt_schedule_common();</span><br><span class="line">&#125;</span><br><span class="line">NOKPROBE_SYMBOL(preempt_schedule);</span><br><span class="line">EXPORT_SYMBOL(preempt_schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * preempt_schedule_notrace - preempt_schedule called by tracing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The tracing infrastructure uses preempt_enable_notrace to prevent</span></span><br><span class="line"><span class="comment"> * recursion and tracing preempt enabling caused by the tracing</span></span><br><span class="line"><span class="comment"> * infrastructure itself. But as tracing can happen in areas coming</span></span><br><span class="line"><span class="comment"> * from userspace or just about to enter userspace, a preempt enable</span></span><br><span class="line"><span class="comment"> * can occur before user_exit() is called. This will cause the scheduler</span></span><br><span class="line"><span class="comment"> * to be called when the system is still in usermode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To prevent this, the preempt_enable_notrace will use this function</span></span><br><span class="line"><span class="comment"> * instead of preempt_schedule() to exit user context if needed before</span></span><br><span class="line"><span class="comment"> * calling the scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched notrace <span class="title">preempt_schedule_notrace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_ctx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!preemptible()))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because the function tracer can trace preempt_count_sub()</span></span><br><span class="line"><span class="comment">		 * and it also uses preempt_enable/disable_notrace(), if</span></span><br><span class="line"><span class="comment">		 * NEED_RESCHED is set, the preempt_enable_notrace() called</span></span><br><span class="line"><span class="comment">		 * by the function tracer will call this function again and</span></span><br><span class="line"><span class="comment">		 * cause infinite recursion.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Preemption must be disabled here before the function</span></span><br><span class="line"><span class="comment">		 * tracer can trace. Break up preempt_disable() into two</span></span><br><span class="line"><span class="comment">		 * calls. One to disable preemption without fear of being</span></span><br><span class="line"><span class="comment">		 * traced. The other to still record the preemption latency,</span></span><br><span class="line"><span class="comment">		 * which can also be traced by the function tracer.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		preempt_disable_notrace();</span><br><span class="line">		preempt_latency_start(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Needs preempt disabled in case user_exit() is traced</span></span><br><span class="line"><span class="comment">		 * and the tracer calls preempt_enable_notrace() causing</span></span><br><span class="line"><span class="comment">		 * an infinite recursion.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		prev_ctx = exception_enter();</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		exception_exit(prev_ctx);</span><br><span class="line"></span><br><span class="line">		preempt_latency_stop(<span class="number">1</span>);</span><br><span class="line">		preempt_enable_no_resched_notrace();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(preempt_schedule_notrace);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_PREEMPTION */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the entry point to schedule() from kernel preemption</span></span><br><span class="line"><span class="comment"> * off of irq context.</span></span><br><span class="line"><span class="comment"> * Note, that this is called and return with irqs disabled. This will</span></span><br><span class="line"><span class="comment"> * protect us against recursive calling from irq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">preempt_schedule_irq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> ctx_state prev_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Catch callers which need to be fixed */</span></span><br><span class="line">	BUG_ON(preempt_count() || !irqs_disabled());</span><br><span class="line"></span><br><span class="line">	prev_state = exception_enter();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		__schedule(<span class="literal">true</span>);</span><br><span class="line">		local_irq_disable();</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line"></span><br><span class="line">	exception_exit(prev_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">default_wake_function</span><span class="params">(<span class="keyword">wait_queue_entry_t</span> *curr, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> wake_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) &amp;&amp; wake_flags &amp; ~WF_SYNC);</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(curr-&gt;<span class="keyword">private</span>, mode, wake_flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(default_wake_function);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __rt_effective_prio(struct task_struct *pi_task, <span class="keyword">int</span> prio)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pi_task)</span><br><span class="line">		prio = min(prio, pi_task-&gt;prio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rt_effective_prio</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pi_task</span> = <span class="title">rt_mutex_get_top_task</span>(<span class="title">p</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __rt_effective_prio(pi_task, prio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rt_mutex_setprio - set the current priority of a task</span></span><br><span class="line"><span class="comment"> * @p: task to boost</span></span><br><span class="line"><span class="comment"> * @pi_task: donor task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function changes the 'effective' priority of a task. It does</span></span><br><span class="line"><span class="comment"> * not touch -&gt;normal_prio like __setscheduler().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used by the rt_mutex code to implement priority inheritance</span></span><br><span class="line"><span class="comment"> * logic. Call site only calls if the priority of the task changed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rt_mutex_setprio</span><span class="params">(struct task_struct *p, struct task_struct *pi_task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> prio, oldprio, queued, running, queue_flag =</span><br><span class="line">		DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">prev_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XXX used to be waiter-&gt;prio, not waiter-&gt;task-&gt;prio */</span></span><br><span class="line">	prio = __rt_effective_prio(pi_task, p-&gt;normal_prio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If nothing changed; bail early.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;pi_top_task == pi_task &amp;&amp; prio == p-&gt;prio &amp;&amp; !dl_prio(prio))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	rq = __task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set under pi_lock &amp;&amp; rq-&gt;lock, such that the value can be used under</span></span><br><span class="line"><span class="comment">	 * either lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note that there is loads of tricky to make this pointer cache work</span></span><br><span class="line"><span class="comment">	 * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to</span></span><br><span class="line"><span class="comment">	 * ensure a task is de-boosted (pi_task is set to NULL) before the</span></span><br><span class="line"><span class="comment">	 * task is allowed to run again (and can exit). This ensures the pointer</span></span><br><span class="line"><span class="comment">	 * points to a blocked task -- which guaratees the task is present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;pi_top_task = pi_task;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For FIFO/RR we only need to set prio, if that matches we're done.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (prio == p-&gt;prio &amp;&amp; !dl_prio(prio))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Idle task boosting is a nono in general. There is one</span></span><br><span class="line"><span class="comment">	 * exception, when PREEMPT_RT and NOHZ is active:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The idle task calls get_next_timer_interrupt() and holds</span></span><br><span class="line"><span class="comment">	 * the timer wheel base-&gt;lock on the CPU and another CPU wants</span></span><br><span class="line"><span class="comment">	 * to access the timer (probably to cancel it). We can safely</span></span><br><span class="line"><span class="comment">	 * ignore the boosting request, as the idle CPU runs this code</span></span><br><span class="line"><span class="comment">	 * with interrupts disabled and will complete the lock</span></span><br><span class="line"><span class="comment">	 * protected section without being interrupted. So there is no</span></span><br><span class="line"><span class="comment">	 * real need to boost.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(p == rq-&gt;idle)) &#123;</span><br><span class="line">		WARN_ON(p != rq-&gt;curr);</span><br><span class="line">		WARN_ON(p-&gt;pi_blocked_on);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_sched_pi_setprio(p, pi_task);</span><br><span class="line">	oldprio = p-&gt;prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldprio == prio)</span><br><span class="line">		queue_flag &amp;= ~DEQUEUE_MOVE;</span><br><span class="line"></span><br><span class="line">	prev_class = p-&gt;sched_class;</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, queue_flag);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Boosting condition are:</span></span><br><span class="line"><span class="comment">	 * 1. -rt task is running and holds mutex A</span></span><br><span class="line"><span class="comment">	 *      --&gt; -dl task blocks on mutex A</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2. -dl task is running and holds mutex A</span></span><br><span class="line"><span class="comment">	 *      --&gt; -dl task blocks on mutex A and could preempt the</span></span><br><span class="line"><span class="comment">	 *          running task</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(prio)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dl_prio(p-&gt;normal_prio) ||</span><br><span class="line">		    (pi_task &amp;&amp; dl_prio(pi_task-&gt;prio) &amp;&amp;</span><br><span class="line">		     dl_entity_preempt(&amp;pi_task-&gt;dl, &amp;p-&gt;dl))) &#123;</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">1</span>;</span><br><span class="line">			queue_flag |= ENQUEUE_REPLENISH;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		p-&gt;sched_class = &amp;dl_sched_class;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(prio)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_prio(oldprio))</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (oldprio &lt; prio)</span><br><span class="line">			queue_flag |= ENQUEUE_HEAD;</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_prio(oldprio))</span><br><span class="line">			p-&gt;dl.dl_boosted = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (rt_prio(oldprio))</span><br><span class="line">			p-&gt;rt.timeout = <span class="number">0</span>;</span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;prio = prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, queue_flag);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	check_class_changed(rq, p, prev_class, oldprio);</span><br><span class="line">out_unlock:</span><br><span class="line">	<span class="comment">/* Avoid rq from going away on us: */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	__task_rq_unlock(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rt_effective_prio</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> prio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prio;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_user_nice</span><span class="params">(struct task_struct *p, <span class="keyword">long</span> nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line">	<span class="keyword">int</span> old_prio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_nice(p) == nice || nice &lt; MIN_NICE || nice &gt; MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to be careful, if called from sys_setpriority(),</span></span><br><span class="line"><span class="comment">	 * the task might be in the middle of scheduling on another CPU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The RT priorities are set via sched_setscheduler(), but we still</span></span><br><span class="line"><span class="comment">	 * allow the 'normal' nice value to be set - but as expected</span></span><br><span class="line"><span class="comment">	 * it wont have any effect on scheduling until the task is</span></span><br><span class="line"><span class="comment">	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) || task_has_rt_policy(p)) &#123;</span><br><span class="line">		p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;static_prio = NICE_TO_PRIO(nice);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">	old_prio = p-&gt;prio;</span><br><span class="line">	p-&gt;prio = effective_prio(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the task increased its priority or is running and</span></span><br><span class="line"><span class="comment">	 * lowered its priority, then reschedule its CPU:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;sched_class-&gt;prio_changed(rq, p, old_prio);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(set_user_nice);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * can_nice - check if a task can reduce its nice value</span></span><br><span class="line"><span class="comment"> * @p: task</span></span><br><span class="line"><span class="comment"> * @nice: nice value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">can_nice</span><span class="params">(<span class="keyword">const</span> struct task_struct *p, <span class="keyword">const</span> <span class="keyword">int</span> nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Convert nice value [19,-20] to rlimit style value [1,40]: */</span></span><br><span class="line">	<span class="keyword">int</span> nice_rlim = nice_to_rlimit(nice);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (nice_rlim &lt;= task_rlimit(p, RLIMIT_NICE) ||</span><br><span class="line">		capable(CAP_SYS_NICE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_SYS_NICE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_nice - change the priority of the current process.</span></span><br><span class="line"><span class="comment"> * @increment: priority increment</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sys_setpriority is a more generic, but much slower function that</span></span><br><span class="line"><span class="comment"> * does similar things.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(nice, <span class="keyword">int</span>, increment)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> nice, retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Setpriority might change our priority at the same moment.</span></span><br><span class="line"><span class="comment">	 * We don't have to worry. Conceptually one call occurs first</span></span><br><span class="line"><span class="comment">	 * and we have a single winner.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	increment = clamp(increment, -NICE_WIDTH, NICE_WIDTH);</span><br><span class="line">	nice = task_nice(current) + increment;</span><br><span class="line"></span><br><span class="line">	nice = clamp_val(nice, MIN_NICE, MAX_NICE);</span><br><span class="line">	<span class="keyword">if</span> (increment &lt; <span class="number">0</span> &amp;&amp; !can_nice(current, nice))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	retval = security_task_setnice(current, nice);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	set_user_nice(current, nice);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * task_prio - return the priority value of a given task.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The priority value as seen by users in /proc.</span></span><br><span class="line"><span class="comment"> * RT tasks are offset by -200. Normal tasks are centered</span></span><br><span class="line"><span class="comment"> * around 0, value goes from -16 to +15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task_prio</span><span class="params">(<span class="keyword">const</span> struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;prio - MAX_RT_PRIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idle_cpu - is a given CPU idle currently?</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the CPU is currently idle. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;curr != rq-&gt;idle)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;ttwu_pending)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * available_idle_cpu - is a given CPU idle for enqueuing work.</span></span><br><span class="line"><span class="comment"> * @cpu: the CPU in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the CPU is currently idle. 0 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available_idle_cpu</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!idle_cpu(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vcpu_is_preempted(cpu))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idle_task - return the idle task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The idle task for the CPU @cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">idle_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_rq(cpu)-&gt;idle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find_process_by_pid - find a process with a matching PID value.</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The task of @pid, if found. %NULL otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">find_process_by_pid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pid ? find_task_by_vpid(pid) : current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched_setparam() passes in -1 for its policy, to let the functions</span></span><br><span class="line"><span class="comment"> * it calls know not to change it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETPARAM_POLICY	-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler_params(struct task_struct *p,</span><br><span class="line">		<span class="keyword">const</span> struct sched_attr *attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> policy = attr-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (policy == SETPARAM_POLICY)</span><br><span class="line">		policy = p-&gt;policy;</span><br><span class="line"></span><br><span class="line">	p-&gt;policy = policy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_policy(policy))</span><br><span class="line">		__setparam_dl(p, attr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fair_policy(policy))</span><br><span class="line">		p-&gt;static_prio = NICE_TO_PRIO(attr-&gt;sched_nice);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * __sched_setscheduler() ensures attr-&gt;sched_priority == 0 when</span></span><br><span class="line"><span class="comment">	 * !rt_policy. Always setting this ensures that things like</span></span><br><span class="line"><span class="comment">	 * getparam()/getattr() don't report silly values for !rt tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;rt_priority = attr-&gt;sched_priority;</span><br><span class="line">	p-&gt;normal_prio = normal_prio(p);</span><br><span class="line">	set_load_weight(p, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Actually do priority change: must hold pi &amp; rq lock. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __setscheduler(struct rq *rq, struct task_struct *p,</span><br><span class="line">			   <span class="keyword">const</span> struct sched_attr *attr, <span class="keyword">bool</span> keep_boost)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If params can't change scheduling class changes aren't allowed</span></span><br><span class="line"><span class="comment">	 * either.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_KEEP_PARAMS)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__setscheduler_params(p, attr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep a potential priority boosting if called from</span></span><br><span class="line"><span class="comment">	 * sched_setscheduler().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p-&gt;prio = normal_prio(p);</span><br><span class="line">	<span class="keyword">if</span> (keep_boost)</span><br><span class="line">		p-&gt;prio = rt_effective_prio(p, p-&gt;prio);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;dl_sched_class;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (rt_prio(p-&gt;prio))</span><br><span class="line">		p-&gt;sched_class = &amp;rt_sched_class;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		p-&gt;sched_class = &amp;fair_sched_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check the target process has a UID that matches the current process's:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">check_same_owner</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> = <span class="title">current_cred</span>(), *<span class="title">pcred</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> match;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	pcred = __task_cred(p);</span><br><span class="line">	match = (uid_eq(cred-&gt;euid, pcred-&gt;euid) ||</span><br><span class="line">		 uid_eq(cred-&gt;euid, pcred-&gt;uid));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __sched_setscheduler(struct task_struct *p,</span><br><span class="line">				<span class="keyword">const</span> struct sched_attr *attr,</span><br><span class="line">				<span class="keyword">bool</span> user, <span class="keyword">bool</span> pi)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> newprio = dl_policy(attr-&gt;sched_policy) ? MAX_DL_PRIO - <span class="number">1</span> :</span><br><span class="line">		      MAX_RT_PRIO - <span class="number">1</span> - attr-&gt;sched_priority;</span><br><span class="line">	<span class="keyword">int</span> retval, oldprio, oldpolicy = <span class="number">-1</span>, queued, running;</span><br><span class="line">	<span class="keyword">int</span> new_effective_prio, policy = attr-&gt;sched_policy;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">prev_class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> reset_on_fork;</span><br><span class="line">	<span class="keyword">int</span> queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The pi code expects interrupts enabled */</span></span><br><span class="line">	BUG_ON(pi &amp;&amp; in_interrupt());</span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* Double check policy once rq lock held: */</span></span><br><span class="line">	<span class="keyword">if</span> (policy &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		reset_on_fork = p-&gt;sched_reset_on_fork;</span><br><span class="line">		policy = oldpolicy = p-&gt;policy;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		reset_on_fork = !!(attr-&gt;sched_flags &amp; SCHED_FLAG_RESET_ON_FORK);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!valid_policy(policy))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Valid priorities for SCHED_FIFO and SCHED_RR are</span></span><br><span class="line"><span class="comment">	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,</span></span><br><span class="line"><span class="comment">	 * SCHED_BATCH and SCHED_IDLE is 0.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;mm &amp;&amp; attr-&gt;sched_priority &gt; MAX_USER_RT_PRIO<span class="number">-1</span>) ||</span><br><span class="line">	    (!p-&gt;mm &amp;&amp; attr-&gt;sched_priority &gt; MAX_RT_PRIO<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> ((dl_policy(policy) &amp;&amp; !__checkparam_dl(attr)) ||</span><br><span class="line">	    (rt_policy(policy) != (attr-&gt;sched_priority != <span class="number">0</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Allow unprivileged RT tasks to decrease priority:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (user &amp;&amp; !capable(CAP_SYS_NICE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fair_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (attr-&gt;sched_nice &lt; task_nice(p) &amp;&amp;</span><br><span class="line">			    !can_nice(p, attr-&gt;sched_nice))</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rt_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> rlim_rtprio =</span><br><span class="line">					task_rlimit(p, RLIMIT_RTPRIO);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Can't set/change the rt policy: */</span></span><br><span class="line">			<span class="keyword">if</span> (policy != p-&gt;policy &amp;&amp; !rlim_rtprio)</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Can't increase priority: */</span></span><br><span class="line">			<span class="keyword">if</span> (attr-&gt;sched_priority &gt; p-&gt;rt_priority &amp;&amp;</span><br><span class="line">			    attr-&gt;sched_priority &gt; rlim_rtprio)</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">		  * Can't set/change SCHED_DEADLINE policy at all for now</span></span><br><span class="line"><span class="comment">		  * (safest behavior); in the future we would like to allow</span></span><br><span class="line"><span class="comment">		  * unprivileged DL tasks to increase their relative deadline</span></span><br><span class="line"><span class="comment">		  * or reduce their runtime (both ways reducing utilization)</span></span><br><span class="line"><span class="comment">		  */</span></span><br><span class="line">		<span class="keyword">if</span> (dl_policy(policy))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Treat SCHED_IDLE as nice 20. Only allow a switch to</span></span><br><span class="line"><span class="comment">		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (task_has_idle_policy(p) &amp;&amp; !idle_policy(policy)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!can_nice(p, task_nice(p)))</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Can't change other user's priorities: */</span></span><br><span class="line">		<span class="keyword">if</span> (!check_same_owner(p))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Normal users shall not reset the sched_reset_on_fork flag: */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;sched_reset_on_fork &amp;&amp; !reset_on_fork)</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (user) &#123;</span><br><span class="line">		<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_SUGOV)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		retval = security_task_setscheduler(p);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update task specific "requested" clamps */</span></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP) &#123;</span><br><span class="line">		retval = uclamp_validate(p, attr);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi)</span><br><span class="line">		cpuset_read_lock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure no PI-waiters arrive (or leave) while we are</span></span><br><span class="line"><span class="comment">	 * changing the priority of the task:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * To be able to change p-&gt;policy safely, the appropriate</span></span><br><span class="line"><span class="comment">	 * runqueue lock must be held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Changing the policy of the stop threads its a very bad idea:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p == rq-&gt;stop) &#123;</span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If not changing anything there's no need to proceed further,</span></span><br><span class="line"><span class="comment">	 * but store a possible modification of reset_on_fork.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(policy == p-&gt;policy)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fair_policy(policy) &amp;&amp; attr-&gt;sched_nice != task_nice(p))</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (rt_policy(policy) &amp;&amp; attr-&gt;sched_priority != p-&gt;rt_priority)</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (dl_policy(policy) &amp;&amp; dl_param_changed(p, attr))</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line">		<span class="keyword">if</span> (attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP)</span><br><span class="line">			<span class="keyword">goto</span> change;</span><br><span class="line"></span><br><span class="line">		p-&gt;sched_reset_on_fork = reset_on_fork;</span><br><span class="line">		retval = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line">change:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (user) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Do not allow realtime tasks into groups that have no runtime</span></span><br><span class="line"><span class="comment">		 * assigned.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rt_bandwidth_enabled() &amp;&amp; rt_policy(policy) &amp;&amp;</span><br><span class="line">				task_group(p)-&gt;rt_bandwidth.rt_runtime == <span class="number">0</span> &amp;&amp;</span><br><span class="line">				!task_group_is_autogroup(task_group(p))) &#123;</span><br><span class="line">			retval = -EPERM;</span><br><span class="line">			<span class="keyword">goto</span> unlock;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		<span class="keyword">if</span> (dl_bandwidth_enabled() &amp;&amp; dl_policy(policy) &amp;&amp;</span><br><span class="line">				!(attr-&gt;sched_flags &amp; SCHED_FLAG_SUGOV)) &#123;</span><br><span class="line">			<span class="keyword">cpumask_t</span> *span = rq-&gt;rd-&gt;span;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Don't allow tasks with an affinity mask smaller than</span></span><br><span class="line"><span class="comment">			 * the entire root_domain to become SCHED_DEADLINE. We</span></span><br><span class="line"><span class="comment">			 * will also fail if there's no bandwidth available.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!cpumask_subset(span, p-&gt;cpus_ptr) ||</span><br><span class="line">			    rq-&gt;rd-&gt;dl_bw.bw == <span class="number">0</span>) &#123;</span><br><span class="line">				retval = -EPERM;</span><br><span class="line">				<span class="keyword">goto</span> unlock;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Re-check policy now with rq lock held: */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(oldpolicy != <span class="number">-1</span> &amp;&amp; oldpolicy != p-&gt;policy)) &#123;</span><br><span class="line">		policy = oldpolicy = <span class="number">-1</span>;</span><br><span class="line">		task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">		<span class="keyword">if</span> (pi)</span><br><span class="line">			cpuset_read_unlock();</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If setscheduling to SCHED_DEADLINE (or changing the parameters</span></span><br><span class="line"><span class="comment">	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth</span></span><br><span class="line"><span class="comment">	 * is available.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((dl_policy(policy) || dl_task(p)) &amp;&amp; sched_dl_overflow(p, policy, attr)) &#123;</span><br><span class="line">		retval = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_reset_on_fork = reset_on_fork;</span><br><span class="line">	oldprio = p-&gt;prio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Take priority boosted tasks into account. If the new</span></span><br><span class="line"><span class="comment">		 * effective priority is unchanged, we just store the new</span></span><br><span class="line"><span class="comment">		 * normal parameters and do not touch the scheduler class and</span></span><br><span class="line"><span class="comment">		 * the runqueue. This will be done when the task deboost</span></span><br><span class="line"><span class="comment">		 * itself.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		new_effective_prio = rt_effective_prio(p, newprio);</span><br><span class="line">		<span class="keyword">if</span> (new_effective_prio == oldprio)</span><br><span class="line">			queue_flags &amp;= ~DEQUEUE_MOVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	prev_class = p-&gt;sched_class;</span><br><span class="line"></span><br><span class="line">	__setscheduler(rq, p, attr, pi);</span><br><span class="line">	__setscheduler_uclamp(p, attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We enqueue to tail when the priority of a task is</span></span><br><span class="line"><span class="comment">		 * increased (user space view).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (oldprio &lt; p-&gt;prio)</span><br><span class="line">			queue_flags |= ENQUEUE_HEAD;</span><br><span class="line"></span><br><span class="line">		enqueue_task(rq, p, queue_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line"></span><br><span class="line">	check_class_changed(rq, p, prev_class, oldprio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid rq from going away on us: */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pi) &#123;</span><br><span class="line">		cpuset_read_unlock();</span><br><span class="line">		rt_mutex_adjust_pi(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Run balance callbacks after we've adjusted the PI chain: */</span></span><br><span class="line">	balance_callback(rq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (pi)</span><br><span class="line">		cpuset_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _sched_setscheduler(struct task_struct *p, <span class="keyword">int</span> policy,</span><br><span class="line">			       <span class="keyword">const</span> struct sched_param *param, <span class="keyword">bool</span> check)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span> = &#123;</span></span><br><span class="line">		.sched_policy   = policy,</span><br><span class="line">		.sched_priority = param-&gt;sched_priority,</span><br><span class="line">		.sched_nice	= PRIO_TO_NICE(p-&gt;static_prio),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fixup the legacy SCHED_RESET_ON_FORK hack. */</span></span><br><span class="line">	<span class="keyword">if</span> ((policy != SETPARAM_POLICY) &amp;&amp; (policy &amp; SCHED_RESET_ON_FORK)) &#123;</span><br><span class="line">		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;</span><br><span class="line">		policy &amp;= ~SCHED_RESET_ON_FORK;</span><br><span class="line">		attr.sched_policy = policy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, &amp;attr, check, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE that the task may be already dead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setscheduler</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> policy,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> struct sched_param *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _sched_setscheduler(p, policy, param, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setscheduler);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setattr</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, attr, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setattr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setattr_nocheck</span><span class="params">(struct task_struct *p, <span class="keyword">const</span> struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __sched_setscheduler(p, attr, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.</span></span><br><span class="line"><span class="comment"> * @p: the task in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Just like sched_setscheduler, only don't bother checking if the</span></span><br><span class="line"><span class="comment"> * current context has permission.  For example, this is needed in</span></span><br><span class="line"><span class="comment"> * stop_machine(): we create temporary high priority worker threads,</span></span><br><span class="line"><span class="comment"> * but our caller might not have that capability.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setscheduler_nocheck</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> policy,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">const</span> struct sched_param *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _sched_setscheduler(p, policy, param, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_setscheduler_nocheck);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_sched_setscheduler(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> policy, struct sched_param __user *param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">lparam</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param || pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;lparam, param, <span class="keyword">sizeof</span>(struct sched_param)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (likely(p))</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(p)) &#123;</span><br><span class="line">		retval = sched_setscheduler(p, policy, &amp;lparam);</span><br><span class="line">		put_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mimics kernel/events/core.c perf_copy_attr().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sched_copy_attr</span><span class="params">(struct sched_attr __user *uattr, struct sched_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 size;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Zero the full structure, so that a short copy will be nice: */</span></span><br><span class="line">	<span class="built_in">memset</span>(attr, <span class="number">0</span>, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line"></span><br><span class="line">	ret = get_user(size, &amp;uattr-&gt;size);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ABI compatibility quirk: */</span></span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		size = SCHED_ATTR_SIZE_VER0;</span><br><span class="line">	<span class="keyword">if</span> (size &lt; SCHED_ATTR_SIZE_VER0 || size &gt; PAGE_SIZE)</span><br><span class="line">		<span class="keyword">goto</span> err_size;</span><br><span class="line"></span><br><span class="line">	ret = copy_struct_from_user(attr, <span class="keyword">sizeof</span>(*attr), uattr, size);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret == -E2BIG)</span><br><span class="line">			<span class="keyword">goto</span> err_size;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((attr-&gt;sched_flags &amp; SCHED_FLAG_UTIL_CLAMP) &amp;&amp;</span><br><span class="line">	    size &lt; SCHED_ATTR_SIZE_VER1)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">XXX:</span> Do we want to be lenient like existing syscalls; or do we want</span></span><br><span class="line"><span class="comment">	 * to be strict and return an error on out-of-bounds values?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	attr-&gt;sched_nice = clamp(attr-&gt;sched_nice, MIN_NICE, MAX_NICE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_size:</span><br><span class="line">	put_user(<span class="keyword">sizeof</span>(*attr), &amp;uattr-&gt;size);</span><br><span class="line">	<span class="keyword">return</span> -E2BIG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setscheduler - set/change the scheduler policy and RT priority</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @policy: new policy.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setscheduler, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, policy, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (policy &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_sched_setscheduler(pid, policy, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setparam - set/change the RT priority of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the new RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_setparam, <span class="keyword">pid_t</span>, pid, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_sched_setscheduler(pid, SETPARAM_POLICY, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setattr - same as above, but with extended sched_attr</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @uattr: structure containing the extended parameters.</span></span><br><span class="line"><span class="comment"> * @flags: for future extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setattr, <span class="keyword">pid_t</span>, pid, struct sched_attr __user *, uattr,</span><br><span class="line">			       <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uattr || pid &lt; <span class="number">0</span> || flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = sched_copy_attr(uattr, &amp;attr);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">int</span>)attr.sched_policy &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (attr.sched_flags &amp; SCHED_FLAG_KEEP_POLICY)</span><br><span class="line">		attr.sched_policy = SETPARAM_POLICY;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (likely(p))</span><br><span class="line">		get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(p)) &#123;</span><br><span class="line">		retval = sched_setattr(p, &amp;attr);</span><br><span class="line">		put_task_struct(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getscheduler - get the policy (scheduling class) of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, the policy of the thread. Otherwise, a negative error</span></span><br><span class="line"><span class="comment"> * code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_getscheduler, <span class="keyword">pid_t</span>, pid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		retval = security_task_getscheduler(p);</span><br><span class="line">		<span class="keyword">if</span> (!retval)</span><br><span class="line">			retval = p-&gt;policy</span><br><span class="line">				| (p-&gt;sched_reset_on_fork ? SCHED_RESET_ON_FORK : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getparam - get the RT priority of a thread</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @param: structure containing the RT priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, 0 and the RT priority is in @param. Otherwise, an error</span></span><br><span class="line"><span class="comment"> * code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_getparam, <span class="keyword">pid_t</span>, pid, struct sched_param __user *, param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">lp</span> = &#123;</span> .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!param || pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		lp.sched_priority = p-&gt;rt_priority;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This one might sleep, we cannot do it with a spinlock held ...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	retval = copy_to_user(param, &amp;lp, <span class="keyword">sizeof</span>(*param)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the kernel size attribute structure (which might be larger</span></span><br><span class="line"><span class="comment"> * than what user-space knows about) to user-space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that all cases are valid: user-space buffer can be larger or</span></span><br><span class="line"><span class="comment"> * smaller than the kernel-space buffer. The usual case is that both</span></span><br><span class="line"><span class="comment"> * have the same size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sched_attr_copy_to_user(struct sched_attr __user *uattr,</span><br><span class="line">			struct sched_attr *kattr,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> usize)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ksize = <span class="keyword">sizeof</span>(*kattr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!access_ok(uattr, usize))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * sched_getattr() ABI forwards and backwards compatibility:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize == ksize then we just copy everything to user-space and all is good.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize &lt; ksize then we only copy as much as user-space has space for,</span></span><br><span class="line"><span class="comment">	 * this keeps ABI compatibility as well. We skip the rest.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If usize &gt; ksize then user-space is using a newer version of the ABI,</span></span><br><span class="line"><span class="comment">	 * which part the kernel doesn't know about. Just ignore it - tooling can</span></span><br><span class="line"><span class="comment">	 * detect the kernel's knowledge of attributes from the attr-&gt;size value</span></span><br><span class="line"><span class="comment">	 * which is set to ksize in this case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kattr-&gt;size = min(usize, ksize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(uattr, kattr, kattr-&gt;size))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getattr - similar to sched_getparam, but with sched_attr</span></span><br><span class="line"><span class="comment"> * @pid: the pid in question.</span></span><br><span class="line"><span class="comment"> * @uattr: structure containing the extended parameters.</span></span><br><span class="line"><span class="comment"> * @usize: sizeof(attr) for fwd/bwd comp.</span></span><br><span class="line"><span class="comment"> * @flags: for future extension.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(sched_getattr, <span class="keyword">pid_t</span>, pid, struct sched_attr __user *, uattr,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span>, usize, <span class="keyword">unsigned</span> <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">kattr</span> = &#123;</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uattr || pid &lt; <span class="number">0</span> || usize &gt; PAGE_SIZE ||</span><br><span class="line">	    usize &lt; SCHED_ATTR_SIZE_VER0 || flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	kattr.sched_policy = p-&gt;policy;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_reset_on_fork)</span><br><span class="line">		kattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;</span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p))</span><br><span class="line">		__getparam_dl(p, &amp;kattr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (task_has_rt_policy(p))</span><br><span class="line">		kattr.sched_priority = p-&gt;rt_priority;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kattr.sched_nice = task_nice(p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">	kattr.sched_util_min = p-&gt;uclamp_req[UCLAMP_MIN].value;</span><br><span class="line">	kattr.sched_util_max = p-&gt;uclamp_req[UCLAMP_MAX].value;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_attr_copy_to_user(uattr, &amp;kattr, usize);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> struct cpumask *in_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> cpus_allowed, new_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> -ESRCH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prevent p going away */</span></span><br><span class="line">	get_task_struct(p);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_NO_SETAFFINITY) &#123;</span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_put_task;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;cpus_allowed, GFP_KERNEL)) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_put_task;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL)) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_free_cpus_allowed;</span><br><span class="line">	&#125;</span><br><span class="line">	retval = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (!check_same_owner(p)) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		<span class="keyword">if</span> (!ns_capable(__task_cred(p)-&gt;user_ns, CAP_SYS_NICE)) &#123;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = security_task_setscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cpuset_cpus_allowed(p, cpus_allowed);</span><br><span class="line">	cpumask_and(new_mask, in_mask, cpus_allowed);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since bandwidth control happens on root_domain basis,</span></span><br><span class="line"><span class="comment">	 * if admission test is enabled, we only admit -deadline</span></span><br><span class="line"><span class="comment">	 * tasks allowed to run on all the CPUs in the task's</span></span><br><span class="line"><span class="comment">	 * root_domain.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (task_has_dl_policy(p) &amp;&amp; dl_bandwidth_enabled()) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		<span class="keyword">if</span> (!cpumask_subset(task_rq(p)-&gt;rd-&gt;span, new_mask)) &#123;</span><br><span class="line">			retval = -EBUSY;</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">goto</span> out_free_new_mask;</span><br><span class="line">		&#125;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">again:</span><br><span class="line">	retval = __set_cpus_allowed_ptr(p, new_mask, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">		cpuset_cpus_allowed(p, cpus_allowed);</span><br><span class="line">		<span class="keyword">if</span> (!cpumask_subset(new_mask, cpus_allowed)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We must have raced with a concurrent cpuset</span></span><br><span class="line"><span class="comment">			 * update. Just reset the cpus_allowed to the</span></span><br><span class="line"><span class="comment">			 * cpuset's cpus_allowed</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			cpumask_copy(new_mask, cpus_allowed);</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_free_new_mask:</span><br><span class="line">	free_cpumask_var(new_mask);</span><br><span class="line">out_free_cpus_allowed:</span><br><span class="line">	free_cpumask_var(cpus_allowed);</span><br><span class="line">out_put_task:</span><br><span class="line">	put_task_struct(p);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_user_cpu_mask</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *user_mask_ptr, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct cpumask *new_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; cpumask_size())</span><br><span class="line">		cpumask_clear(new_mask);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; cpumask_size())</span><br><span class="line">		len = cpumask_size();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_setaffinity - set the CPU affinity of a process</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process</span></span><br><span class="line"><span class="comment"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span></span><br><span class="line"><span class="comment"> * @user_mask_ptr: user-space pointer to the new CPU mask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0 on success. An error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_setaffinity, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, len,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, user_mask_ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> new_mask;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;new_mask, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = sched_setaffinity(pid, new_mask);</span><br><span class="line">	free_cpumask_var(new_mask);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, struct cpumask *mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;p-&gt;pi_lock, flags);</span><br><span class="line">	cpumask_and(mask, &amp;p-&gt;cpus_mask, cpu_active_mask);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;p-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_getaffinity - get the CPU affinity of a process</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process</span></span><br><span class="line"><span class="comment"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr</span></span><br><span class="line"><span class="comment"> * @user_mask_ptr: user-space pointer to hold the current CPU mask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: size of CPU mask copied to user_mask_ptr on success. An</span></span><br><span class="line"><span class="comment"> * error code otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(sched_getaffinity, <span class="keyword">pid_t</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">int</span>, len,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *, user_mask_ptr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">cpumask_var_t</span> mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((len * BITS_PER_BYTE) &lt; nr_cpu_ids)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (len &amp; (<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_cpumask_var(&amp;mask, GFP_KERNEL))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ret = sched_getaffinity(pid, mask);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> retlen = min(len, cpumask_size());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(user_mask_ptr, mask, retlen))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ret = retlen;</span><br><span class="line">	&#125;</span><br><span class="line">	free_cpumask_var(mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_yield - yield the current processor to other threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function yields the current CPU to other tasks. If there are no</span></span><br><span class="line"><span class="comment"> * other threads running on this CPU then this function will return.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = this_rq_lock_irq(&amp;rf);</span><br><span class="line"></span><br><span class="line">	schedstat_inc(rq-&gt;yld_count);</span><br><span class="line">	current-&gt;sched_class-&gt;yield_task(rq);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we are going to call schedule() anyway, there's</span></span><br><span class="line"><span class="comment">	 * no need to preempt or enable interrupts:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">	sched_preempt_enable_no_resched();</span><br><span class="line"></span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE0(sched_yield)</span><br><span class="line">&#123;</span><br><span class="line">	do_sched_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_PREEMPTION</span></span><br><span class="line"><span class="keyword">int</span> __sched _cond_resched(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (should_resched(<span class="number">0</span>)) &#123;</span><br><span class="line">		preempt_schedule_common();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_all_qs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(_cond_resched);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __cond_resched_lock() - if a reschedule is pending, drop the given lock,</span></span><br><span class="line"><span class="comment"> * call schedule, and on return reacquire the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level</span></span><br><span class="line"><span class="comment"> * operations here to prevent schedule() from being called twice (once via</span></span><br><span class="line"><span class="comment"> * spin_unlock(), once by hand).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __cond_resched_lock(<span class="keyword">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> resched = should_resched(PREEMPT_LOCK_OFFSET);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (spin_needbreak(lock) || resched) &#123;</span><br><span class="line">		spin_unlock(lock);</span><br><span class="line">		<span class="keyword">if</span> (resched)</span><br><span class="line">			preempt_schedule_common();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cpu_relax();</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		spin_lock(lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__cond_resched_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield - yield the current processor to other threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Do not ever use this function, there's a 99% chance you're doing it wrong.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The scheduler is at all times free to pick the calling task as the most</span></span><br><span class="line"><span class="comment"> * eligible task to run, if removing the yield() call from your code breaks</span></span><br><span class="line"><span class="comment"> * it, its already broken.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typical broken usage is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * while (!event)</span></span><br><span class="line"><span class="comment"> *	yield();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * where one assumes that yield() will let 'the other' process run that will</span></span><br><span class="line"><span class="comment"> * make event true. If the current task is a SCHED_FIFO task that will never</span></span><br><span class="line"><span class="comment"> * happen. Never use yield() as a progress guarantee!!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you want to use yield() to wait for something, use wait_event().</span></span><br><span class="line"><span class="comment"> * If you want to use yield() to be 'nice' for others, use cond_resched().</span></span><br><span class="line"><span class="comment"> * If you still want to use yield(), do not!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_current_state(TASK_RUNNING);</span><br><span class="line">	do_sched_yield();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(yield);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield_to - yield the current processor to another thread in</span></span><br><span class="line"><span class="comment"> * your thread group, or accelerate that thread toward the</span></span><br><span class="line"><span class="comment"> * processor it's on.</span></span><br><span class="line"><span class="comment"> * @p: target task</span></span><br><span class="line"><span class="comment"> * @preempt: whether task preemption is allowed or not</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It's the caller's job to ensure that the target task struct</span></span><br><span class="line"><span class="comment"> * can't go away on us before we can do any checks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *	true (&gt;0) if we indeed boosted the target task.</span></span><br><span class="line"><span class="comment"> *	false (0) if we failed to boost the target.</span></span><br><span class="line"><span class="comment"> *	-ESRCH if there's no task to yield to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __sched <span class="title">yield_to</span><span class="params">(struct task_struct *p, <span class="keyword">bool</span> preempt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>, *<span class="title">p_rq</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> yielded = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	rq = this_rq();</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	p_rq = task_rq(p);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we're the only runnable task on the rq and target rq also</span></span><br><span class="line"><span class="comment">	 * has only one task, there's absolutely no point in yielding.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;nr_running == <span class="number">1</span> &amp;&amp; p_rq-&gt;nr_running == <span class="number">1</span>) &#123;</span><br><span class="line">		yielded = -ESRCH;</span><br><span class="line">		<span class="keyword">goto</span> out_irq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	double_rq_lock(rq, p_rq);</span><br><span class="line">	<span class="keyword">if</span> (task_rq(p) != p_rq) &#123;</span><br><span class="line">		double_rq_unlock(rq, p_rq);</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!curr-&gt;sched_class-&gt;yield_to_task)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curr-&gt;sched_class != p-&gt;sched_class)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_running(p_rq, p) || p-&gt;state)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	yielded = curr-&gt;sched_class-&gt;yield_to_task(rq, p, preempt);</span><br><span class="line">	<span class="keyword">if</span> (yielded) &#123;</span><br><span class="line">		schedstat_inc(rq-&gt;yld_count);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Make p's CPU reschedule; pick_next_entity takes care of</span></span><br><span class="line"><span class="comment">		 * fairness.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (preempt &amp;&amp; rq != p_rq)</span><br><span class="line">			resched_curr(p_rq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	double_rq_unlock(rq, p_rq);</span><br><span class="line">out_irq:</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (yielded &gt; <span class="number">0</span>)</span><br><span class="line">		schedule();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> yielded;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(yield_to);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_schedule_prepare</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_iowait = current-&gt;in_iowait;</span><br><span class="line"></span><br><span class="line">	current-&gt;in_iowait = <span class="number">1</span>;</span><br><span class="line">	blk_schedule_flush_plug(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> old_iowait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_schedule_finish</span><span class="params">(<span class="keyword">int</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	current-&gt;in_iowait = token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This task is about to go to sleep on IO. Increment rq-&gt;nr_iowait so</span></span><br><span class="line"><span class="comment"> * that process accounting knows that this is a task in IO wait state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> __sched <span class="title">io_schedule_timeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line">	<span class="keyword">long</span> ret;</span><br><span class="line"></span><br><span class="line">	token = io_schedule_prepare();</span><br><span class="line">	ret = schedule_timeout(timeout);</span><br><span class="line">	io_schedule_finish(token);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(io_schedule_timeout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">io_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> token;</span><br><span class="line"></span><br><span class="line">	token = io_schedule_prepare();</span><br><span class="line">	schedule();</span><br><span class="line">	io_schedule_finish(token);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(io_schedule);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_get_priority_max - return maximum RT priority.</span></span><br><span class="line"><span class="comment"> * @policy: scheduling class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, this syscall returns the maximum</span></span><br><span class="line"><span class="comment"> * rt_priority that can be used by a given scheduling class.</span></span><br><span class="line"><span class="comment"> * On failure, a negative error code is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_get_priority_max, <span class="keyword">int</span>, policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">	<span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">	<span class="keyword">case</span> SCHED_RR:</span><br><span class="line">		ret = MAX_USER_RT_PRIO<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SCHED_DEADLINE:</span><br><span class="line">	<span class="keyword">case</span> SCHED_NORMAL:</span><br><span class="line">	<span class="keyword">case</span> SCHED_BATCH:</span><br><span class="line">	<span class="keyword">case</span> SCHED_IDLE:</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_get_priority_min - return minimum RT priority.</span></span><br><span class="line"><span class="comment"> * @policy: scheduling class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, this syscall returns the minimum</span></span><br><span class="line"><span class="comment"> * rt_priority that can be used by a given scheduling class.</span></span><br><span class="line"><span class="comment"> * On failure, a negative error code is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(sched_get_priority_min, <span class="keyword">int</span>, policy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (policy) &#123;</span><br><span class="line">	<span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">	<span class="keyword">case</span> SCHED_RR:</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SCHED_DEADLINE:</span><br><span class="line">	<span class="keyword">case</span> SCHED_NORMAL:</span><br><span class="line">	<span class="keyword">case</span> SCHED_BATCH:</span><br><span class="line">	<span class="keyword">case</span> SCHED_IDLE:</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sched_rr_get_interval</span><span class="params">(<span class="keyword">pid_t</span> pid, struct timespec64 *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	retval = -ESRCH;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	p = find_process_by_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	retval = security_task_getscheduler(p);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	time_slice = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;get_rr_interval)</span><br><span class="line">		time_slice = p-&gt;sched_class-&gt;get_rr_interval(rq, p);</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	jiffies_to_timespec64(time_slice, t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_sched_rr_get_interval - return the default timeslice of a process.</span></span><br><span class="line"><span class="comment"> * @pid: pid of the process.</span></span><br><span class="line"><span class="comment"> * @interval: userspace pointer to the timeslice value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * this syscall writes the default timeslice value of a given process</span></span><br><span class="line"><span class="comment"> * into the user-space timespec buffer. A value of '0' means infinity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: On success, 0 and the timeslice is in @interval. Otherwise,</span></span><br><span class="line"><span class="comment"> * an error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(sched_rr_get_interval, <span class="keyword">pid_t</span>, pid,</span><br><span class="line">		struct __kernel_timespec __user *, interval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = sched_rr_get_interval(pid, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = put_timespec64(&amp;t, interval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_32BIT_TIME</span></span><br><span class="line">SYSCALL_DEFINE2(sched_rr_get_interval_time32, <span class="keyword">pid_t</span>, pid,</span><br><span class="line">		struct old_timespec32 __user *, interval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = sched_rr_get_interval(pid, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">		retval = put_old_timespec32(&amp;t, interval);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_show_task</span><span class="params">(struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ppid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_get_task_stack(p))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">"%-15.15s %c"</span>, p-&gt;comm, task_state_to_char(p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == TASK_RUNNING)</span><br><span class="line">		printk(KERN_CONT <span class="string">"  running task    "</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_STACK_USAGE</span></span><br><span class="line">	<span class="built_in">free</span> = stack_not_used(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ppid = <span class="number">0</span>;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">if</span> (pid_alive(p))</span><br><span class="line">		ppid = task_pid_nr(rcu_dereference(p-&gt;real_parent));</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	printk(KERN_CONT <span class="string">"%5lu %5d %6d 0x%08lx\n"</span>, <span class="built_in">free</span>,</span><br><span class="line">		task_pid_nr(p), ppid,</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_thread_info(p)-&gt;flags);</span><br><span class="line"></span><br><span class="line">	print_worker_info(KERN_INFO, p);</span><br><span class="line">	show_stack(p, <span class="literal">NULL</span>, KERN_INFO);</span><br><span class="line">	put_task_stack(p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sched_show_task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">state_filter_match(<span class="keyword">unsigned</span> <span class="keyword">long</span> state_filter, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* no filter, everything matches */</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* filter, but doesn't match */</span></span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;state &amp; state_filter))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows</span></span><br><span class="line"><span class="comment">	 * TASK_KILLABLE).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (state_filter == TASK_UNINTERRUPTIBLE &amp;&amp; p-&gt;state == TASK_IDLE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_state_filter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> state_filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 32</span></span><br><span class="line">	printk(KERN_INFO</span><br><span class="line">		<span class="string">"  task                PC stack   pid father\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	printk(KERN_INFO</span><br><span class="line">		<span class="string">"  task                        PC stack   pid father\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	for_each_process_thread(g, p) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * reset the NMI-timeout, listing all files on a slow</span></span><br><span class="line"><span class="comment">		 * console might take a lot of time:</span></span><br><span class="line"><span class="comment">		 * Also, reset softlockup watchdogs on all CPUs, because</span></span><br><span class="line"><span class="comment">		 * another CPU might be blocked waiting for us to process</span></span><br><span class="line"><span class="comment">		 * an IPI.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		touch_nmi_watchdog();</span><br><span class="line">		touch_all_softlockup_watchdogs();</span><br><span class="line">		<span class="keyword">if</span> (state_filter_match(state_filter, p))</span><br><span class="line">			sched_show_task(p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		sysrq_sched_debug_show();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only show locks if all tasks are dumped:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!state_filter)</span><br><span class="line">		debug_show_all_locks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init_idle - set up an idle thread for a given CPU</span></span><br><span class="line"><span class="comment"> * @idle: task in question</span></span><br><span class="line"><span class="comment"> * @cpu: CPU the idle task belongs to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this function does not set the idle thread's NEED_RESCHED</span></span><br><span class="line"><span class="comment"> * flag, to make booting more robust.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_idle</span><span class="params">(struct task_struct *idle, <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	__sched_fork(<span class="number">0</span>, idle);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;idle-&gt;pi_lock, flags);</span><br><span class="line">	raw_spin_lock(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	idle-&gt;state = TASK_RUNNING;</span><br><span class="line">	idle-&gt;se.exec_start = sched_clock();</span><br><span class="line">	idle-&gt;flags |= PF_IDLE;</span><br><span class="line"></span><br><span class="line">	scs_task_reset(idle);</span><br><span class="line">	kasan_unpoison_task_stack(idle);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Its possible that init_idle() gets called multiple times on a task,</span></span><br><span class="line"><span class="comment">	 * in that case do_set_cpus_allowed() will not do the right thing.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * And since this is boot we can forgo the serialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_cpus_allowed_common(idle, cpumask_of(cpu));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We're having a chicken and egg problem, even though we are</span></span><br><span class="line"><span class="comment">	 * holding rq-&gt;lock, the CPU isn't yet set to this CPU so the</span></span><br><span class="line"><span class="comment">	 * lockdep check in task_group() will fail.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Similar case to sched_fork(). / Alternatively we could</span></span><br><span class="line"><span class="comment">	 * use task_rq_lock() here and obtain the other rq-&gt;lock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Silence PROVE_RCU</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	__set_task_cpu(idle, cpu);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	rq-&gt;idle = idle;</span><br><span class="line">	rcu_assign_pointer(rq-&gt;curr, idle);</span><br><span class="line">	idle-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	idle-&gt;on_cpu = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	raw_spin_unlock(&amp;rq-&gt;lock);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;idle-&gt;pi_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the preempt count _outside_ the spinlocks! */</span></span><br><span class="line">	init_idle_preempt_count(idle, cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The idle tasks have their own, simple scheduling class:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	idle-&gt;sched_class = &amp;idle_sched_class;</span><br><span class="line">	ftrace_graph_init_idle_task(idle, cpu);</span><br><span class="line">	vtime_init_idle(idle, cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="built_in">sprintf</span>(idle-&gt;comm, <span class="string">"%s/%d"</span>, INIT_TASK_COMM, cpu);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cpuset_cpumask_can_shrink</span><span class="params">(<span class="keyword">const</span> struct cpumask *cur,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">const</span> struct cpumask *trial)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_weight(cur))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = dl_cpuset_cpumask_can_shrink(cur, trial);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task_can_attach</span><span class="params">(struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">const</span> struct cpumask *cs_cpus_allowed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Kthreads which disallow setaffinity shouldn't be moved</span></span><br><span class="line"><span class="comment">	 * to a new cpuset; we don't want to change their CPU</span></span><br><span class="line"><span class="comment">	 * affinity and isolating such threads by their set of</span></span><br><span class="line"><span class="comment">	 * allowed nodes is unnecessary.  Thus, cpusets are not</span></span><br><span class="line"><span class="comment">	 * applicable for such threads.  This prevents checking for</span></span><br><span class="line"><span class="comment">	 * success of set_cpus_allowed_ptr() on all attached tasks</span></span><br><span class="line"><span class="comment">	 * before cpus_mask may be changed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_NO_SETAFFINITY) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dl_task(p) &amp;&amp; !cpumask_intersects(task_rq(p)-&gt;rd-&gt;span,</span><br><span class="line">					      cs_cpus_allowed))</span><br><span class="line">		ret = dl_task_can_attach(p, cs_cpus_allowed);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> sched_smp_initialized __read_mostly;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line"><span class="comment">/* Migrate current task p to target_cpu */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">migrate_task_to</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> target_cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">migration_arg</span> <span class="title">arg</span> = &#123;</span> p, target_cpu &#125;;</span><br><span class="line">	<span class="keyword">int</span> curr_cpu = task_cpu(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curr_cpu == target_cpu)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cpumask_test_cpu(target_cpu, p-&gt;cpus_ptr))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> This is not properly updating schedstats */</span></span><br><span class="line"></span><br><span class="line">	trace_sched_move_numa(p, curr_cpu, target_cpu);</span><br><span class="line">	<span class="keyword">return</span> stop_one_cpu(curr_cpu, migration_cpu_stop, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Requeue a task on a given node and accurately track the number of NUMA</span></span><br><span class="line"><span class="comment"> * tasks on the runqueues</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_setnuma</span><span class="params">(struct task_struct *p, <span class="keyword">int</span> nid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> queued, running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(p, &amp;rf);</span><br><span class="line">	queued = task_on_rq_queued(p);</span><br><span class="line">	running = task_current(rq, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, p, DEQUEUE_SAVE);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, p);</span><br><span class="line"></span><br><span class="line">	p-&gt;numa_preferred_nid = nid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		set_next_task(rq, p);</span><br><span class="line">	task_rq_unlock(rq, p, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA_BALANCING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ensure that the idle task is using init_mm right before its CPU goes</span></span><br><span class="line"><span class="comment"> * offline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idle_task_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">active_mm</span>;</span></span><br><span class="line"></span><br><span class="line">	BUG_ON(cpu_online(smp_processor_id()));</span><br><span class="line">	BUG_ON(current != this_rq()-&gt;idle);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm != &amp;init_mm) &#123;</span><br><span class="line">		switch_mm(mm, &amp;init_mm, current);</span><br><span class="line">		finish_arch_post_lock_switch();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* finish_cpu(), as ran on the BP, will clean up the active_mm state */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since this CPU is going 'away' for a while, fold any nr_active delta</span></span><br><span class="line"><span class="comment"> * we might have. Assumes we're called after migrate_tasks() so that the</span></span><br><span class="line"><span class="comment"> * nr_active count is stable. We need to take the teardown thread which</span></span><br><span class="line"><span class="comment"> * is calling this into account, so we hand in adjust = 1 to the load</span></span><br><span class="line"><span class="comment"> * calculation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also see the comment "Global load-average calculations".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calc_load_migrate</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> delta = calc_load_fold_active(rq, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (delta)</span><br><span class="line">		atomic_long_add(delta, &amp;calc_load_tasks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">pick_migrate_task</span>(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		next = class-&gt;pick_next_task(rq);</span><br><span class="line">		<span class="keyword">if</span> (next) &#123;</span><br><span class="line">			next-&gt;sched_class-&gt;put_prev_task(rq, next);</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The idle class should always have a runnable task */</span></span><br><span class="line">	BUG();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Migrate all tasks from the rq, sleeping tasks will be migrated by</span></span><br><span class="line"><span class="comment"> * try_to_wake_up()-&gt;select_task_rq().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called with rq-&gt;lock held even though we'er in stop_machine() and</span></span><br><span class="line"><span class="comment"> * there's no concurrency possible, we hold the required locks anyway</span></span><br><span class="line"><span class="comment"> * because of lock validation efforts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">migrate_tasks</span><span class="params">(struct rq *dead_rq, struct rq_flags *rf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">dead_rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next</span>, *<span class="title">stop</span> = <span class="title">rq</span>-&gt;<span class="title">stop</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">orf</span> = *<span class="title">rf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> dest_cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fudge the rq selection such that the below task selection loop</span></span><br><span class="line"><span class="comment">	 * doesn't get stuck on the currently eligible stop task.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We're currently inside stop_machine() and the rq is either stuck</span></span><br><span class="line"><span class="comment">	 * in the stop_machine_cpu_stop() loop, or we're executing this code,</span></span><br><span class="line"><span class="comment">	 * either way we should never end up calling schedule() until we're</span></span><br><span class="line"><span class="comment">	 * done here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq-&gt;stop = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * put_prev_task() and pick_next_task() sched</span></span><br><span class="line"><span class="comment">	 * class method both need to have an up-to-date</span></span><br><span class="line"><span class="comment">	 * value of rq-&gt;clock[_task]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * There's this thread running, bail when that's the only</span></span><br><span class="line"><span class="comment">		 * remaining thread:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rq-&gt;nr_running == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		next = __pick_migrate_task(rq);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Rules for changing task_struct::cpus_mask are holding</span></span><br><span class="line"><span class="comment">		 * both pi_lock and rq-&gt;lock, such that holding either</span></span><br><span class="line"><span class="comment">		 * stabilizes the mask.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Drop rq-&gt;lock is not quite as disastrous as it usually is</span></span><br><span class="line"><span class="comment">		 * because !cpu_active at this point, which means load-balance</span></span><br><span class="line"><span class="comment">		 * will not interfere. Also, stop-machine.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rq_unlock(rq, rf);</span><br><span class="line">		raw_spin_lock(&amp;next-&gt;pi_lock);</span><br><span class="line">		rq_relock(rq, rf);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Since we're inside stop-machine, _nothing_ should have</span></span><br><span class="line"><span class="comment">		 * changed the task, WARN if weird stuff happened, because in</span></span><br><span class="line"><span class="comment">		 * that case the above rq-&gt;lock drop is a fail too.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(task_rq(next) != rq || !task_on_rq_queued(next))) &#123;</span><br><span class="line">			raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Find suitable destination for @next, with force if needed. */</span></span><br><span class="line">		dest_cpu = select_fallback_rq(dead_rq-&gt;cpu, next);</span><br><span class="line">		rq = __migrate_task(rq, rf, next, dest_cpu);</span><br><span class="line">		<span class="keyword">if</span> (rq != dead_rq) &#123;</span><br><span class="line">			rq_unlock(rq, rf);</span><br><span class="line">			rq = dead_rq;</span><br><span class="line">			*rf = orf;</span><br><span class="line">			rq_relock(rq, rf);</span><br><span class="line">		&#125;</span><br><span class="line">		raw_spin_unlock(&amp;next-&gt;pi_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rq-&gt;stop = stop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_HOTPLUG_CPU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_rq_online</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!rq-&gt;online) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">		cpumask_set_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span><br><span class="line">		rq-&gt;online = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class-&gt;rq_online)</span><br><span class="line">				<span class="class"><span class="keyword">class</span>-&gt;<span class="title">rq_online</span>(<span class="title">rq</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_rq_offline</span><span class="params">(struct rq *rq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;online) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">class</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_class(class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (class-&gt;rq_offline)</span><br><span class="line">				<span class="class"><span class="keyword">class</span>-&gt;<span class="title">rq_offline</span>(<span class="title">rq</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cpumask_clear_cpu(rq-&gt;cpu, rq-&gt;rd-&gt;online);</span><br><span class="line">		rq-&gt;online = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * used to mark begin/end of suspend/resume:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_cpus_frozen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update cpusets according to cpu_active mask.  If cpusets are</span></span><br><span class="line"><span class="comment"> * disabled, cpuset_update_active_cpus() becomes a simple wrapper</span></span><br><span class="line"><span class="comment"> * around partition_sched_domains().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we come here as part of a suspend/resume, don't touch cpusets because we</span></span><br><span class="line"><span class="comment"> * want to restore it back to its original state upon resume anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpuset_cpu_active</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (cpuhp_tasks_frozen) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * num_cpus_frozen tracks how many CPUs are involved in suspend</span></span><br><span class="line"><span class="comment">		 * resume sequence. As long as this is not the last online</span></span><br><span class="line"><span class="comment">		 * operation in the resume sequence, just build a single sched</span></span><br><span class="line"><span class="comment">		 * domain, ignoring cpusets.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		partition_sched_domains(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (--num_cpus_frozen)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This is the last CPU online operation. So fall through and</span></span><br><span class="line"><span class="comment">		 * restore the original sched domains by considering the</span></span><br><span class="line"><span class="comment">		 * cpuset configurations.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		cpuset_force_rebuild();</span><br><span class="line">	&#125;</span><br><span class="line">	cpuset_update_active_cpus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpuset_cpu_inactive</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!cpuhp_tasks_frozen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dl_cpu_busy(cpu))</span><br><span class="line">			<span class="keyword">return</span> -EBUSY;</span><br><span class="line">		cpuset_update_active_cpus();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		num_cpus_frozen++;</span><br><span class="line">		partition_sched_domains(<span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_activate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_SMT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When going up, increment the number of cores with SMT present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_weight(cpu_smt_mask(cpu)) == <span class="number">2</span>)</span><br><span class="line">		static_branch_inc_cpuslocked(&amp;sched_smt_present);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_smp_initialized) &#123;</span><br><span class="line">		sched_domains_numa_masks_set(cpu);</span><br><span class="line">		cpuset_cpu_active();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Put the rq online, if not already. This happens:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1) In the early boot process, because we build the real domains</span></span><br><span class="line"><span class="comment">	 *    after all CPUs have been brought up.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 2) At runtime, if cpuset_cpu_active() fails to rebuild the</span></span><br><span class="line"><span class="comment">	 *    domains.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rd) &#123;</span><br><span class="line">		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span><br><span class="line">		set_rq_online(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_deactivate</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	set_cpu_active(cpu, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We've cleared cpu_active_mask, wait for all preempt-disabled and RCU</span></span><br><span class="line"><span class="comment">	 * users of this state to go away such that all new such users will</span></span><br><span class="line"><span class="comment">	 * observe it.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Do sync before park smpboot threads to take care the rcu boost case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	synchronize_rcu();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_SMT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When going down, decrement the number of cores with SMT present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cpumask_weight(cpu_smt_mask(cpu)) == <span class="number">2</span>)</span><br><span class="line">		static_branch_dec_cpuslocked(&amp;sched_smt_present);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sched_smp_initialized)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = cpuset_cpu_inactive(cpu);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	sched_domains_numa_masks_clear(cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_rq_cpu_starting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">	rq-&gt;calc_load_update = calc_load_update;</span><br><span class="line">	update_max_interval();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_starting</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_rq_cpu_starting(cpu);</span><br><span class="line">	sched_tick_start(cpu);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HOTPLUG_CPU</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_cpu_dying</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cpu_rq</span>(<span class="title">cpu</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle pending wakeups and then migrate everything off */</span></span><br><span class="line">	sched_tick_stop(cpu);</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	<span class="keyword">if</span> (rq-&gt;rd) &#123;</span><br><span class="line">		BUG_ON(!cpumask_test_cpu(cpu, rq-&gt;rd-&gt;span));</span><br><span class="line">		set_rq_offline(rq);</span><br><span class="line">	&#125;</span><br><span class="line">	migrate_tasks(rq, &amp;rf);</span><br><span class="line">	BUG_ON(rq-&gt;nr_running != <span class="number">1</span>);</span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line"></span><br><span class="line">	calc_load_migrate(rq);</span><br><span class="line">	update_max_interval();</span><br><span class="line">	nohz_balance_exit_idle(rq);</span><br><span class="line">	hrtick_clear(rq);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init_smp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_init_numa();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There's no userspace yet to cause hotplug operations; hence all the</span></span><br><span class="line"><span class="comment">	 * CPU masks are stable and all blatant races in the below code cannot</span></span><br><span class="line"><span class="comment">	 * happen.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;sched_domains_mutex);</span><br><span class="line">	sched_init_domains(cpu_active_mask);</span><br><span class="line">	mutex_unlock(&amp;sched_domains_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Move init over to a non-isolated CPU */</span></span><br><span class="line">	<span class="keyword">if</span> (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) &lt; <span class="number">0</span>)</span><br><span class="line">		BUG();</span><br><span class="line">	sched_init_granularity();</span><br><span class="line"></span><br><span class="line">	init_sched_rt_class();</span><br><span class="line">	init_sched_dl_class();</span><br><span class="line"></span><br><span class="line">	sched_smp_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">migration_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_cpu_starting(smp_processor_id());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(migration_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init_smp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sched_init_granularity();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_sched_functions</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> in_lock_functions(addr) ||</span><br><span class="line">		(addr &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__sched_text_start</span><br><span class="line">		&amp;&amp; addr &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)__sched_text_end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default task group.</span></span><br><span class="line"><span class="comment"> * Every task in system belongs to this group at bootup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> <span class="title">root_task_group</span>;</span></span><br><span class="line">LIST_HEAD(task_groups);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cacheline aligned slab cache for task_group */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_group_cache</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">cpumask_var_t</span>, load_balance_mask);</span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">cpumask_var_t</span>, select_idle_mask);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	wait_bit_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	ptr += <span class="number">2</span> * nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	ptr += <span class="number">2</span> * nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)kzalloc(ptr, GFP_NOWAIT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">		root_task_group.se = (struct sched_entity **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.cfs_rq = (struct cfs_rq **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.shares = ROOT_TASK_GROUP_LOAD;</span><br><span class="line">		init_cfs_bandwidth(&amp;root_task_group.cfs_bandwidth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		root_task_group.rt_se = (struct sched_rt_entity **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line">		root_task_group.rt_rq = (struct rt_rq **)ptr;</span><br><span class="line">		ptr += nr_cpu_ids * <span class="keyword">sizeof</span>(<span class="keyword">void</span> **);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUMASK_OFFSTACK</span></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		per_cpu(load_balance_mask, i) = (<span class="keyword">cpumask_var_t</span>)kzalloc_node(</span><br><span class="line">			cpumask_size(), GFP_KERNEL, cpu_to_node(i));</span><br><span class="line">		per_cpu(select_idle_mask, i) = (<span class="keyword">cpumask_var_t</span>)kzalloc_node(</span><br><span class="line">			cpumask_size(), GFP_KERNEL, cpu_to_node(i));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CPUMASK_OFFSTACK */</span></span></span><br><span class="line"></span><br><span class="line">	init_rt_bandwidth(&amp;def_rt_bandwidth, global_rt_period(), global_rt_runtime());</span><br><span class="line">	init_dl_bandwidth(&amp;def_dl_bandwidth, global_rt_period(), global_rt_runtime());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	init_defrootdomain();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">	init_rt_bandwidth(&amp;root_task_group.rt_bandwidth,</span><br><span class="line">			global_rt_period(), global_rt_runtime());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">	task_group_cache = KMEM_CACHE(task_group, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	list_add(&amp;root_task_group.<span class="built_in">list</span>, &amp;task_groups);</span><br><span class="line">	INIT_LIST_HEAD(&amp;root_task_group.children);</span><br><span class="line">	INIT_LIST_HEAD(&amp;root_task_group.siblings);</span><br><span class="line">	autogroup_init(&amp;init_task);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CGROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">		rq = cpu_rq(i);</span><br><span class="line">		raw_spin_lock_init(&amp;rq-&gt;lock);</span><br><span class="line">		rq-&gt;nr_running = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;calc_load_active = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;calc_load_update = jiffies + LOAD_FREQ;</span><br><span class="line">		init_cfs_rq(&amp;rq-&gt;cfs);</span><br><span class="line">		init_rt_rq(&amp;rq-&gt;rt);</span><br><span class="line">		init_dl_rq(&amp;rq-&gt;dl);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;rq-&gt;leaf_cfs_rq_list);</span><br><span class="line">		rq-&gt;tmp_alone_branch = &amp;rq-&gt;leaf_cfs_rq_list;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * How much CPU bandwidth does root_task_group get?</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In case of task-groups formed thr' the cgroup filesystem, it</span></span><br><span class="line"><span class="comment">		 * gets 100% of the CPU resources in the system. This overall</span></span><br><span class="line"><span class="comment">		 * system CPU resource is divided among the tasks of</span></span><br><span class="line"><span class="comment">		 * root_task_group and its child task-groups in a fair manner,</span></span><br><span class="line"><span class="comment">		 * based on each entity's (task or task-group's) weight</span></span><br><span class="line"><span class="comment">		 * (se-&gt;load.weight).</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * In other words, if root_task_group has 10 tasks of weight</span></span><br><span class="line"><span class="comment">		 * 1024) and two child groups A0 and A1 (of weight 1024 each),</span></span><br><span class="line"><span class="comment">		 * then A0's share of the CPU resource is:</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *	A0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We achieve this by letting root_task_group's tasks sit</span></span><br><span class="line"><span class="comment">		 * directly in rq-&gt;cfs (i.e root_task_group-&gt;se[] = NULL).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		init_tg_cfs_entry(&amp;root_task_group, &amp;rq-&gt;cfs, <span class="literal">NULL</span>, i, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line">		rq-&gt;rt.rt_runtime = def_rt_bandwidth.rt_runtime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		init_tg_rt_entry(&amp;root_task_group, &amp;rq-&gt;rt, <span class="literal">NULL</span>, i, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">		rq-&gt;sd = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;rd = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;cpu_capacity = rq-&gt;cpu_capacity_orig = SCHED_CAPACITY_SCALE;</span><br><span class="line">		rq-&gt;balance_callback = <span class="literal">NULL</span>;</span><br><span class="line">		rq-&gt;active_balance = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;next_balance = jiffies;</span><br><span class="line">		rq-&gt;push_cpu = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;cpu = i;</span><br><span class="line">		rq-&gt;online = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;idle_stamp = <span class="number">0</span>;</span><br><span class="line">		rq-&gt;avg_idle = <span class="number">2</span>*sysctl_sched_migration_cost;</span><br><span class="line">		rq-&gt;max_idle_balance_cost = sysctl_sched_migration_cost;</span><br><span class="line"></span><br><span class="line">		INIT_LIST_HEAD(&amp;rq-&gt;cfs_tasks);</span><br><span class="line"></span><br><span class="line">		rq_attach_root(rq, &amp;def_root_domain);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_COMMON</span></span><br><span class="line">		rq-&gt;last_blocked_load_update_tick = jiffies;</span><br><span class="line">		atomic_set(&amp;rq-&gt;nohz_flags, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		rq_csd_init(rq, &amp;rq-&gt;nohz_csd, nohz_csd_func);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">		hrtick_rq_init(rq);</span><br><span class="line">		atomic_set(&amp;rq-&gt;nr_iowait, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set_load_weight(&amp;init_task, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot idle thread does lazy MMU switching as well:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mmgrab(&amp;init_mm);</span><br><span class="line">	enter_lazy_tlb(&amp;init_mm, current);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make us the idle thread. Technically, schedule() should not be</span></span><br><span class="line"><span class="comment">	 * called from this thread, however somewhere below it might be,</span></span><br><span class="line"><span class="comment">	 * but because we are the idle thread, we just pick up running again</span></span><br><span class="line"><span class="comment">	 * when this runqueue becomes "idle".</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_idle(current, smp_processor_id());</span><br><span class="line"></span><br><span class="line">	calc_load_update = jiffies + LOAD_FREQ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	idle_thread_set_boot_cpu();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	init_sched_fair_class();</span><br><span class="line"></span><br><span class="line">	init_schedstats();</span><br><span class="line"></span><br><span class="line">	psi_init();</span><br><span class="line"></span><br><span class="line">	init_uclamp();</span><br><span class="line"></span><br><span class="line">	scheduler_running = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_ATOMIC_SLEEP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">preempt_count_equals</span><span class="params">(<span class="keyword">int</span> preempt_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nested = preempt_count() + rcu_preempt_depth();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (nested == preempt_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __might_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Blocking primitives will set (and therefore destroy) current-&gt;state,</span></span><br><span class="line"><span class="comment">	 * since we will exit with TASK_RUNNING make sure we enter with it,</span></span><br><span class="line"><span class="comment">	 * otherwise we will destroy state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ONCE(current-&gt;state != TASK_RUNNING &amp;&amp; current-&gt;task_state_change,</span><br><span class="line">			<span class="string">"do not call blocking ops when !TASK_RUNNING; "</span></span><br><span class="line">			<span class="string">"state=%lx set at [&lt;%p&gt;] %pS\n"</span>,</span><br><span class="line">			current-&gt;state,</span><br><span class="line">			(<span class="keyword">void</span> *)current-&gt;task_state_change,</span><br><span class="line">			(<span class="keyword">void</span> *)current-&gt;task_state_change);</span><br><span class="line"></span><br><span class="line">	___might_sleep(file, line, preempt_offset);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__might_sleep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ___might_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Ratelimiting timestamp: */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> prev_jiffy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* WARN_ON_ONCE() by default, no rate limit required: */</span></span><br><span class="line">	rcu_sleep_check();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((preempt_count_equals(preempt_offset) &amp;&amp; !irqs_disabled() &amp;&amp;</span><br><span class="line">	     !is_idle_task(current) &amp;&amp; !current-&gt;non_block_count) ||</span><br><span class="line">	    system_state == SYSTEM_BOOTING || system_state &gt; SYSTEM_RUNNING ||</span><br><span class="line">	    oops_in_progress)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time_before(jiffies, prev_jiffy + HZ) &amp;&amp; prev_jiffy)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	prev_jiffy = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save this before calling printk(), since that will clobber it: */</span></span><br><span class="line">	preempt_disable_ip = get_preempt_disable_ip(current);</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR</span><br><span class="line">		<span class="string">"BUG: sleeping function called from invalid context at %s:%d\n"</span>,</span><br><span class="line">			file, line);</span><br><span class="line">	printk(KERN_ERR</span><br><span class="line">		<span class="string">"in_atomic(): %d, irqs_disabled(): %d, non_block: %d, pid: %d, name: %s\n"</span>,</span><br><span class="line">			in_atomic(), irqs_disabled(), current-&gt;non_block_count,</span><br><span class="line">			current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_stack_end_corrupted(current))</span><br><span class="line">		printk(KERN_EMERG <span class="string">"Thread overran stack, or stack corrupted\n"</span>);</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(current);</span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		print_irqtrace_events(current);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_DEBUG_PREEMPT)</span><br><span class="line">	    &amp;&amp; !preempt_count_equals(preempt_offset)) &#123;</span><br><span class="line">		pr_err(<span class="string">"Preemption disabled at:"</span>);</span><br><span class="line">		print_ip_sym(KERN_ERR, preempt_disable_ip);</span><br><span class="line">	&#125;</span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(___might_sleep);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __cant_sleep(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">int</span> preempt_offset)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> prev_jiffy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled())</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_COUNT))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (preempt_count() &gt; preempt_offset)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time_before(jiffies, prev_jiffy + HZ) &amp;&amp; prev_jiffy)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	prev_jiffy = jiffies;</span><br><span class="line"></span><br><span class="line">	printk(KERN_ERR <span class="string">"BUG: assuming atomic context at %s:%d\n"</span>, file, line);</span><br><span class="line">	printk(KERN_ERR <span class="string">"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\n"</span>,</span><br><span class="line">			in_atomic(), irqs_disabled(),</span><br><span class="line">			current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line">	debug_show_held_locks(current);</span><br><span class="line">	dump_stack();</span><br><span class="line">	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__cant_sleep);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MAGIC_SYSRQ</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize_rt_tasks</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">g</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_attr</span> <span class="title">attr</span> = &#123;</span></span><br><span class="line">		.sched_policy = SCHED_NORMAL,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;tasklist_lock);</span><br><span class="line">	for_each_process_thread(g, p) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Only normalize user tasks:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		p-&gt;se.exec_start = <span class="number">0</span>;</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.wait_start,  <span class="number">0</span>);</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.sleep_start, <span class="number">0</span>);</span><br><span class="line">		schedstat_set(p-&gt;se.statistics.block_start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dl_task(p) &amp;&amp; !rt_task(p)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Renice negative nice level userspace</span></span><br><span class="line"><span class="comment">			 * tasks back to 0:</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (task_nice(p) &lt; <span class="number">0</span>)</span><br><span class="line">				set_user_nice(p, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		__sched_setscheduler(p, &amp;attr, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_MAGIC_SYSRQ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These functions are only useful for the IA64 MCA handling, or kdb.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * They can only be called when the whole system has been</span></span><br><span class="line"><span class="comment"> * stopped - every CPU needs to be quiescent, and no scheduling</span></span><br><span class="line"><span class="comment"> * activity can take place. Using them for anything else would</span></span><br><span class="line"><span class="comment"> * be a serious bug, and as a result, they aren't even visible</span></span><br><span class="line"><span class="comment"> * under any other configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * curr_task - return the current task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The current task for @cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">curr_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_curr(cpu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA64</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ia64_set_curr_task - set the current task for a given CPU.</span></span><br><span class="line"><span class="comment"> * @cpu: the processor in question.</span></span><br><span class="line"><span class="comment"> * @p: the task pointer to set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: This function must only be used when non-maskable interrupts</span></span><br><span class="line"><span class="comment"> * are serviced on a separate stack. It allows the architecture to switch the</span></span><br><span class="line"><span class="comment"> * notion of the current task on a CPU in a non-blocking manner. This function</span></span><br><span class="line"><span class="comment"> * must be called with all CPU's synchronized, and interrupts disabled, the</span></span><br><span class="line"><span class="comment"> * and caller must save the original value of the current task (see</span></span><br><span class="line"><span class="comment"> * curr_task() above) and restore that value before reenabling interrupts and</span></span><br><span class="line"><span class="comment"> * re-starting the system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ia64_set_curr_task</span><span class="params">(<span class="keyword">int</span> cpu, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_curr(cpu) = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="comment">/* task_group_lock serializes the addition/removal of task groups */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(task_group_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">alloc_uclamp_sched_group</span><span class="params">(struct task_group *tg,</span></span></span><br><span class="line"><span class="function"><span class="params">					    struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;tg-&gt;uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), <span class="literal">false</span>);</span><br><span class="line">		tg-&gt;uclamp[clamp_id] = parent-&gt;uclamp[clamp_id];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_free_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	free_fair_sched_group(tg);</span><br><span class="line">	free_rt_sched_group(tg);</span><br><span class="line">	autogroup_free(tg);</span><br><span class="line">	kmem_cache_free(task_group_cache, tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate runqueue etc for a new task group */</span></span><br><span class="line"><span class="function">struct task_group *<span class="title">sched_create_group</span><span class="params">(struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	tg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);</span><br><span class="line">	<span class="keyword">if</span> (!tg)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_fair_sched_group(tg, parent))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!alloc_rt_sched_group(tg, parent))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	alloc_uclamp_sched_group(tg, parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	sched_free_group(tg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_online_group</span><span class="params">(struct task_group *tg, struct task_group *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;task_group_lock, flags);</span><br><span class="line">	list_add_rcu(&amp;tg-&gt;<span class="built_in">list</span>, &amp;task_groups);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Root should already exist: */</span></span><br><span class="line">	WARN_ON(!parent);</span><br><span class="line"></span><br><span class="line">	tg-&gt;parent = parent;</span><br><span class="line">	INIT_LIST_HEAD(&amp;tg-&gt;children);</span><br><span class="line">	list_add_rcu(&amp;tg-&gt;siblings, &amp;parent-&gt;children);</span><br><span class="line">	spin_unlock_irqrestore(&amp;task_group_lock, flags);</span><br><span class="line"></span><br><span class="line">	online_fair_sched_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rcu callback to free various structures associated with a task group */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_free_group_rcu</span><span class="params">(struct rcu_head *rhp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Now it should be safe to free those cfs_rqs: */</span></span><br><span class="line">	sched_free_group(container_of(rhp, struct task_group, rcu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_destroy_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Wait for possible concurrent references to cfs_rqs complete: */</span></span><br><span class="line">	call_rcu(&amp;tg-&gt;rcu, sched_free_group_rcu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_offline_group</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* End participation in shares distribution: */</span></span><br><span class="line">	unregister_fair_sched_group(tg);</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;task_group_lock, flags);</span><br><span class="line">	list_del_rcu(&amp;tg-&gt;<span class="built_in">list</span>);</span><br><span class="line">	list_del_rcu(&amp;tg-&gt;siblings);</span><br><span class="line">	spin_unlock_irqrestore(&amp;task_group_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_change_group</span><span class="params">(struct task_struct *tsk, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All callers are synchronized by task_rq_lock(); we do not use RCU</span></span><br><span class="line"><span class="comment">	 * which is pointless here. Thus, we pass "true" to task_css_check()</span></span><br><span class="line"><span class="comment">	 * to prevent lockdep warnings.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tg = container_of(task_css_check(tsk, cpu_cgrp_id, <span class="literal">true</span>),</span><br><span class="line">			  struct task_group, css);</span><br><span class="line">	tg = autogroup_task_group(tsk, tg);</span><br><span class="line">	tsk-&gt;sched_task_group = tg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	<span class="keyword">if</span> (tsk-&gt;sched_class-&gt;task_change_group)</span><br><span class="line">		tsk-&gt;sched_class-&gt;task_change_group(tsk, type);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">		set_task_rq(tsk, task_cpu(tsk));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change task's runqueue when it moves between groups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The caller of this function should have put the task in its new group by</span></span><br><span class="line"><span class="comment"> * now. This function just updates tsk-&gt;se.cfs_rq and tsk-&gt;se.parent to reflect</span></span><br><span class="line"><span class="comment"> * its new group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_move_task</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> queued, running, queue_flags =</span><br><span class="line">		DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(tsk, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	running = task_current(rq, tsk);</span><br><span class="line">	queued = task_on_rq_queued(tsk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		dequeue_task(rq, tsk, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running)</span><br><span class="line">		put_prev_task(rq, tsk);</span><br><span class="line"></span><br><span class="line">	sched_change_group(tsk, TASK_MOVE_GROUP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queued)</span><br><span class="line">		enqueue_task(rq, tsk, queue_flags);</span><br><span class="line">	<span class="keyword">if</span> (running) &#123;</span><br><span class="line">		set_next_task(rq, tsk);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * After changing group, the running task may have joined a</span></span><br><span class="line"><span class="comment">		 * throttled one but it's still the running task. Trigger a</span></span><br><span class="line"><span class="comment">		 * resched to make sure that task can still run.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		resched_curr(rq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, tsk, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_group *<span class="title">css_tg</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> css ? container_of(css, struct task_group, css) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *</span></span><br><span class="line"><span class="class"><span class="title">cpu_cgroup_css_alloc</span>(<span class="title">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">parent_css</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span> = <span class="title">css_tg</span>(<span class="title">parent_css</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">		<span class="comment">/* This is early initialization for the top cgroup */</span></span><br><span class="line">		<span class="keyword">return</span> &amp;root_task_group.css;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tg = sched_create_group(parent);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tg))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;tg-&gt;css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expose task group only after completing cgroup initialization */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cgroup_css_online</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">parent</span> = <span class="title">css_tg</span>(<span class="title">css</span>-&gt;<span class="title">parent</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		sched_online_group(tg, parent);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line">	<span class="comment">/* Propagate the effective uclamp value for the new group */</span></span><br><span class="line">	cpu_util_update_eff(css);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_css_released</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	sched_offline_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_css_free</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Relies on the RCU grace period between css_released() and this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_free_group(tg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is called before wake_up_new_task(), therefore we really only</span></span><br><span class="line"><span class="comment"> * have to set its group bits, all the other stuff does not apply.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_fork</span><span class="params">(struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line"></span><br><span class="line">	rq = task_rq_lock(task, &amp;rf);</span><br><span class="line"></span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	sched_change_group(task, TASK_SET_GROUP);</span><br><span class="line"></span><br><span class="line">	task_rq_unlock(rq, task, &amp;rf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cgroup_can_attach</span><span class="params">(struct cgroup_taskset *tset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">css</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cgroup_taskset_for_each(task, css, tset) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">		<span class="keyword">if</span> (!sched_rt_can_attach(css_tg(css), task))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Serialize against wake_up_new_task() such that if its</span></span><br><span class="line"><span class="comment">		 * running, we're sure to observe its full state.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		raw_spin_lock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Avoid calling sched_move_task() before wake_up_new_task()</span></span><br><span class="line"><span class="comment">		 * has happened. This would lead to problems with PELT, due to</span></span><br><span class="line"><span class="comment">		 * move wanting to detach+attach while we're not attached yet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (task-&gt;state == TASK_NEW)</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">		raw_spin_unlock_irq(&amp;task-&gt;pi_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_cgroup_attach</span><span class="params">(struct cgroup_taskset *tset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">css</span>;</span></span><br><span class="line"></span><br><span class="line">	cgroup_taskset_for_each(task, css, tset)</span><br><span class="line">		sched_move_task(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK_GROUP</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cpu_util_update_eff</span><span class="params">(struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">top_css</span> = <span class="title">css</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_se</span> *<span class="title">uc_se</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> eff[UCLAMP_CNT];</span><br><span class="line">	<span class="keyword">enum</span> uclamp_id clamp_id;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> clamps;</span><br><span class="line"></span><br><span class="line">	css_for_each_descendant_pre(css, top_css) &#123;</span><br><span class="line">		uc_parent = css_tg(css)-&gt;parent</span><br><span class="line">			? css_tg(css)-&gt;parent-&gt;uclamp : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="comment">/* Assume effective clamps matches requested clamps */</span></span><br><span class="line">			eff[clamp_id] = css_tg(css)-&gt;uclamp_req[clamp_id].value;</span><br><span class="line">			<span class="comment">/* Cap effective clamps with parent's effective clamps */</span></span><br><span class="line">			<span class="keyword">if</span> (uc_parent &amp;&amp;</span><br><span class="line">			    eff[clamp_id] &gt; uc_parent[clamp_id].value) &#123;</span><br><span class="line">				eff[clamp_id] = uc_parent[clamp_id].value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Ensure protection is always capped by limit */</span></span><br><span class="line">		eff[UCLAMP_MIN] = min(eff[UCLAMP_MIN], eff[UCLAMP_MAX]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Propagate most restrictive effective clamps */</span></span><br><span class="line">		clamps = <span class="number">0x0</span>;</span><br><span class="line">		uc_se = css_tg(css)-&gt;uclamp;</span><br><span class="line">		for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">			<span class="keyword">if</span> (eff[clamp_id] == uc_se[clamp_id].value)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			uc_se[clamp_id].value = eff[clamp_id];</span><br><span class="line">			uc_se[clamp_id].bucket_id = uclamp_bucket_id(eff[clamp_id]);</span><br><span class="line">			clamps |= (<span class="number">0x1</span> &lt;&lt; clamp_id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!clamps) &#123;</span><br><span class="line">			css = css_rightmost_descendant(css);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Immediately update descendants RUNNABLE tasks */</span></span><br><span class="line">		uclamp_update_active_tasks(css, clamps);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer 10^N with a given N exponent by casting to integer the literal "1eN"</span></span><br><span class="line"><span class="comment"> * C expression. Since there is no way to convert a macro argument (N) into a</span></span><br><span class="line"><span class="comment"> * character constant, use two levels of macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POW10(exp) ((unsigned int)1e##exp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POW10(exp) _POW10(exp)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_PERCENT_SHIFT	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCLAMP_PERCENT_SCALE	(100 * POW10(UCLAMP_PERCENT_SHIFT))</span></span><br><span class="line">	s64 percent;</span><br><span class="line">	u64 util;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span></span></span><br><span class="line"><span class="class"><span class="title">capacity_from_percent</span>(<span class="title">char</span> *<span class="title">buf</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> <span class="title">req</span> = &#123;</span></span><br><span class="line">		.percent = UCLAMP_PERCENT_SCALE,</span><br><span class="line">		.util = SCHED_CAPACITY_SCALE,</span><br><span class="line">		.ret = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	buf = strim(buf);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, <span class="string">"max"</span>)) &#123;</span><br><span class="line">		req.ret = cgroup_parse_float(buf, UCLAMP_PERCENT_SHIFT,</span><br><span class="line">					     &amp;req.percent);</span><br><span class="line">		<span class="keyword">if</span> (req.ret)</span><br><span class="line">			<span class="keyword">return</span> req;</span><br><span class="line">		<span class="keyword">if</span> ((u64)req.percent &gt; UCLAMP_PERCENT_SCALE) &#123;</span><br><span class="line">			req.ret = -ERANGE;</span><br><span class="line">			<span class="keyword">return</span> req;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req.util = req.percent &lt;&lt; SCHED_CAPACITY_SHIFT;</span><br><span class="line">		req.util = DIV_ROUND_CLOSEST_ULL(req.util, UCLAMP_PERCENT_SCALE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_write</span><span class="params">(struct kernfs_open_file *of, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">size_t</span> nbytes, <span class="keyword">loff_t</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclamp_request</span> <span class="title">req</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line"></span><br><span class="line">	req = capacity_from_percent(buf);</span><br><span class="line">	<span class="keyword">if</span> (req.ret)</span><br><span class="line">		<span class="keyword">return</span> req.ret;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;uclamp_mutex);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	tg = css_tg(of_css(of));</span><br><span class="line">	<span class="keyword">if</span> (tg-&gt;uclamp_req[clamp_id].value != req.util)</span><br><span class="line">		uclamp_se_set(&amp;tg-&gt;uclamp_req[clamp_id], req.util, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because of not recoverable conversion rounding we keep track of the</span></span><br><span class="line"><span class="comment">	 * exact requested value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tg-&gt;uclamp_pct[clamp_id] = req.percent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update effective clamps to track the most restrictive value */</span></span><br><span class="line">	cpu_util_update_eff(of_css(of));</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	mutex_unlock(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_min_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_uclamp_max_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cpu_uclamp_print</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">enum</span> uclamp_id clamp_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line">	u64 util_clamp;</span><br><span class="line">	u64 percent;</span><br><span class="line">	u32 rem;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	tg = css_tg(seq_css(sf));</span><br><span class="line">	util_clamp = tg-&gt;uclamp_req[clamp_id].value;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (util_clamp == SCHED_CAPACITY_SCALE) &#123;</span><br><span class="line">		seq_puts(sf, <span class="string">"max\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	percent = tg-&gt;uclamp_pct[clamp_id];</span><br><span class="line">	percent = div_u64_rem(percent, POW10(UCLAMP_PERCENT_SHIFT), &amp;rem);</span><br><span class="line">	seq_printf(sf, <span class="string">"%llu.%0*u\n"</span>, percent, UCLAMP_PERCENT_SHIFT, rem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_uclamp_min_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_uclamp_print(sf, UCLAMP_MIN);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_uclamp_max_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cpu_uclamp_print(sf, UCLAMP_MAX);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_UCLAMP_TASK_GROUP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_shares_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cftype, u64 shareval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (shareval &gt; scale_load_down(ULONG_MAX))</span><br><span class="line">		shareval = MAX_SHARES;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(shareval));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_shares_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (u64) scale_load_down(tg-&gt;shares);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(cfs_constraints_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> u64 max_cfs_quota_period = <span class="number">1</span> * NSEC_PER_SEC; <span class="comment">/* 1s */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 min_cfs_quota_period = <span class="number">1</span> * NSEC_PER_MSEC; <span class="comment">/* 1ms */</span></span><br><span class="line"><span class="comment">/* More than 203 days if BW_SHIFT equals 20. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 max_cfs_runtime = MAX_BW * NSEC_PER_USEC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_bandwidth</span><span class="params">(struct task_group *tg, u64 period, u64 quota)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, ret = <span class="number">0</span>, runtime_enabled, runtime_was_enabled;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg == &amp;root_task_group)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure we have at some amount of bandwidth every period.  This is</span></span><br><span class="line"><span class="comment">	 * to prevent reaching a state of large arrears when throttled via</span></span><br><span class="line"><span class="comment">	 * entity_tick() resulting in prolonged exit starvation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (quota &lt; min_cfs_quota_period || period &lt; min_cfs_quota_period)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Likewise, bound things on the otherside by preventing insane quota</span></span><br><span class="line"><span class="comment">	 * periods.  This also allows us to normalize in computing quota</span></span><br><span class="line"><span class="comment">	 * feasibility.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (period &gt; max_cfs_quota_period)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bound quota to defend quota against overflow during bandwidth shift.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (quota != RUNTIME_INF &amp;&amp; quota &gt; max_cfs_runtime)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Prevent race between setting of cfs_rq-&gt;runtime_enabled and</span></span><br><span class="line"><span class="comment">	 * unthrottle_offline_cfs_rqs().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	get_online_cpus();</span><br><span class="line">	mutex_lock(&amp;cfs_constraints_mutex);</span><br><span class="line">	ret = __cfs_schedulable(tg, period, quota);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	runtime_enabled = quota != RUNTIME_INF;</span><br><span class="line">	runtime_was_enabled = cfs_b-&gt;quota != RUNTIME_INF;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we need to toggle cfs_bandwidth_used, off-&gt;on must occur</span></span><br><span class="line"><span class="comment">	 * before making related changes, and on-&gt;off must occur afterwards</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (runtime_enabled &amp;&amp; !runtime_was_enabled)</span><br><span class="line">		cfs_bandwidth_usage_inc();</span><br><span class="line">	raw_spin_lock_irq(&amp;cfs_b-&gt;lock);</span><br><span class="line">	cfs_b-&gt;period = ns_to_ktime(period);</span><br><span class="line">	cfs_b-&gt;quota = quota;</span><br><span class="line"></span><br><span class="line">	__refill_cfs_bandwidth_runtime(cfs_b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restart the period timer (if active) to handle new period expiry: */</span></span><br><span class="line">	<span class="keyword">if</span> (runtime_enabled)</span><br><span class="line">		start_cfs_bandwidth(cfs_b);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock_irq(&amp;cfs_b-&gt;lock);</span><br><span class="line"></span><br><span class="line">	for_each_online_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> = <span class="title">tg</span>-&gt;<span class="title">cfs_rq</span>[<span class="title">i</span>];</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> = <span class="title">cfs_rq</span>-&gt;<span class="title">rq</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line"></span><br><span class="line">		rq_lock_irq(rq, &amp;rf);</span><br><span class="line">		cfs_rq-&gt;runtime_enabled = runtime_enabled;</span><br><span class="line">		cfs_rq-&gt;runtime_remaining = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cfs_rq-&gt;throttled)</span><br><span class="line">			unthrottle_cfs_rq(cfs_rq);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (runtime_was_enabled &amp;&amp; !runtime_enabled)</span><br><span class="line">		cfs_bandwidth_usage_dec();</span><br><span class="line">out_unlock:</span><br><span class="line">	mutex_unlock(&amp;cfs_constraints_mutex);</span><br><span class="line">	put_online_cpus();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_quota</span><span class="params">(struct task_group *tg, <span class="keyword">long</span> cfs_quota_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	period = ktime_to_ns(tg-&gt;cfs_bandwidth.period);</span><br><span class="line">	<span class="keyword">if</span> (cfs_quota_us &lt; <span class="number">0</span>)</span><br><span class="line">		quota = RUNTIME_INF;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((u64)cfs_quota_us &lt;= U64_MAX / NSEC_PER_USEC)</span><br><span class="line">		quota = (u64)cfs_quota_us * NSEC_PER_USEC;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">tg_get_cfs_quota</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota_us;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg-&gt;cfs_bandwidth.quota == RUNTIME_INF)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	quota_us = tg-&gt;cfs_bandwidth.quota;</span><br><span class="line">	do_div(quota_us, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> quota_us;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_set_cfs_period</span><span class="params">(struct task_group *tg, <span class="keyword">long</span> cfs_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((u64)cfs_period_us &gt; U64_MAX / NSEC_PER_USEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	period = (u64)cfs_period_us * NSEC_PER_USEC;</span><br><span class="line">	quota = tg-&gt;cfs_bandwidth.quota;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">tg_get_cfs_period</span><span class="params">(struct task_group *tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 cfs_period_us;</span><br><span class="line"></span><br><span class="line">	cfs_period_us = ktime_to_ns(tg-&gt;cfs_bandwidth.period);</span><br><span class="line">	do_div(cfs_period_us, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cfs_period_us;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_cfs_quota_read_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_get_cfs_quota(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_quota_write_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cftype, s64 cfs_quota_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_quota(css_tg(css), cfs_quota_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_cfs_period_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_get_cfs_period(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_period_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cftype, u64 cfs_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tg_set_cfs_period(css_tg(css), cfs_period_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span>;</span></span><br><span class="line">	u64 period, quota;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * normalize group quota/period to be quota/max_period</span></span><br><span class="line"><span class="comment"> * note: units are usecs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">normalize_cfs_quota</span><span class="params">(struct task_group *tg,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cfs_schedulable_data *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 quota, period;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tg == d-&gt;tg) &#123;</span><br><span class="line">		period = d-&gt;period;</span><br><span class="line">		quota = d-&gt;quota;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		period = tg_get_cfs_period(tg);</span><br><span class="line">		quota = tg_get_cfs_quota(tg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* note: these should typically be equivalent */</span></span><br><span class="line">	<span class="keyword">if</span> (quota == RUNTIME_INF || quota == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> RUNTIME_INF;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> to_ratio(period, quota);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tg_cfs_schedulable_down</span><span class="params">(struct task_group *tg, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> *<span class="title">d</span> = <span class="title">data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line">	s64 quota = <span class="number">0</span>, parent_quota = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tg-&gt;parent) &#123;</span><br><span class="line">		quota = RUNTIME_INF;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct cfs_bandwidth *parent_b = &amp;tg-&gt;parent-&gt;cfs_bandwidth;</span><br><span class="line"></span><br><span class="line">		quota = normalize_cfs_quota(tg, d);</span><br><span class="line">		parent_quota = parent_b-&gt;hierarchical_quota;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ensure max(child_quota) &lt;= parent_quota.  On cgroup2,</span></span><br><span class="line"><span class="comment">		 * always take the min.  On cgroup1, only inherit when no</span></span><br><span class="line"><span class="comment">		 * limit is set:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (cgroup_subsys_on_dfl(cpu_cgrp_subsys)) &#123;</span><br><span class="line">			quota = min(quota, parent_quota);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (quota == RUNTIME_INF)</span><br><span class="line">				quota = parent_quota;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (parent_quota != RUNTIME_INF &amp;&amp; quota &gt; parent_quota)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cfs_b-&gt;hierarchical_quota = quota;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_schedulable_data</span> <span class="title">data</span> = &#123;</span></span><br><span class="line">		.tg = tg,</span><br><span class="line">		.period = period,</span><br><span class="line">		.quota = quota,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (quota != RUNTIME_INF) &#123;</span><br><span class="line">		do_div(data.period, NSEC_PER_USEC);</span><br><span class="line">		do_div(data.quota, NSEC_PER_USEC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	ret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &amp;data);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_cfs_stat_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">seq_css</span>(<span class="title">sf</span>));</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line"></span><br><span class="line">	seq_printf(sf, <span class="string">"nr_periods %d\n"</span>, cfs_b-&gt;nr_periods);</span><br><span class="line">	seq_printf(sf, <span class="string">"nr_throttled %d\n"</span>, cfs_b-&gt;nr_throttled);</span><br><span class="line">	seq_printf(sf, <span class="string">"throttled_time %llu\n"</span>, cfs_b-&gt;throttled_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (schedstat_enabled() &amp;&amp; tg != &amp;root_task_group) &#123;</span><br><span class="line">		u64 ws = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(i)</span><br><span class="line">			ws += schedstat_val(tg-&gt;se[i]-&gt;statistics.wait_sum);</span><br><span class="line"></span><br><span class="line">		seq_printf(sf, <span class="string">"wait_sum %llu\n"</span>, ws);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CFS_BANDWIDTH */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_FAIR_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_rt_runtime_write</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cft, s64 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_rt_runtime(css_tg(css), val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_rt_runtime_read</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_rt_runtime(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_rt_period_write_uint</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cftype, u64 rt_period_us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_set_rt_period(css_tg(css), rt_period_us);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_rt_period_read_uint</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sched_group_rt_period(css_tg(css));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_RT_GROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">cpu_legacy_files</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"shares"</span>,</span><br><span class="line">		.read_u64 = cpu_shares_read_u64,</span><br><span class="line">		.write_u64 = cpu_shares_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"cfs_quota_us"</span>,</span><br><span class="line">		.read_s64 = cpu_cfs_quota_read_s64,</span><br><span class="line">		.write_s64 = cpu_cfs_quota_write_s64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"cfs_period_us"</span>,</span><br><span class="line">		.read_u64 = cpu_cfs_period_read_u64,</span><br><span class="line">		.write_u64 = cpu_cfs_period_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"stat"</span>,</span><br><span class="line">		.seq_show = cpu_cfs_stat_show,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_RT_GROUP_SCHED</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"rt_runtime_us"</span>,</span><br><span class="line">		.read_s64 = cpu_rt_runtime_read,</span><br><span class="line">		.write_s64 = cpu_rt_runtime_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"rt_period_us"</span>,</span><br><span class="line">		.read_u64 = cpu_rt_period_read_uint,</span><br><span class="line">		.write_u64 = cpu_rt_period_write_uint,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.min"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_min_show,</span><br><span class="line">		.write = cpu_uclamp_min_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_max_show,</span><br><span class="line">		.write = cpu_uclamp_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; &#125;	<span class="comment">/* Terminate */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_extra_stat_show</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cgroup_subsys_state *css)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cfs_bandwidth</span> *<span class="title">cfs_b</span> = &amp;<span class="title">tg</span>-&gt;<span class="title">cfs_bandwidth</span>;</span></span><br><span class="line">		u64 throttled_usec;</span><br><span class="line"></span><br><span class="line">		throttled_usec = cfs_b-&gt;throttled_time;</span><br><span class="line">		do_div(throttled_usec, NSEC_PER_USEC);</span><br><span class="line"></span><br><span class="line">		seq_printf(sf, <span class="string">"nr_periods %d\n"</span></span><br><span class="line">			   <span class="string">"nr_throttled %d\n"</span></span><br><span class="line">			   <span class="string">"throttled_usec %llu\n"</span>,</span><br><span class="line">			   cfs_b-&gt;nr_periods, cfs_b-&gt;nr_throttled,</span><br><span class="line">			   throttled_usec);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">cpu_weight_read_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">css</span>);</span></span><br><span class="line">	u64 weight = scale_load_down(tg-&gt;shares);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_weight_write_u64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct cftype *cft, u64 weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * cgroup weight knobs should use the common MIN, DFL and MAX</span></span><br><span class="line"><span class="comment">	 * values which are 1, 100 and 10000 respectively.  While it loses</span></span><br><span class="line"><span class="comment">	 * a bit of range on both ends, it maps pretty well onto the shares</span></span><br><span class="line"><span class="comment">	 * value used by scheduler and the round-trip conversions preserve</span></span><br><span class="line"><span class="comment">	 * the original value over the entire range.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (weight &lt; CGROUP_WEIGHT_MIN || weight &gt; CGROUP_WEIGHT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">	weight = DIV_ROUND_CLOSEST_ULL(weight * <span class="number">1024</span>, CGROUP_WEIGHT_DFL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(weight));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> s64 <span class="title">cpu_weight_nice_read_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				    struct cftype *cft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> weight = scale_load_down(css_tg(css)-&gt;shares);</span><br><span class="line">	<span class="keyword">int</span> last_delta = INT_MAX;</span><br><span class="line">	<span class="keyword">int</span> prio, delta;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find the closest nice value to the current weight */</span></span><br><span class="line">	<span class="keyword">for</span> (prio = <span class="number">0</span>; prio &lt; ARRAY_SIZE(sched_prio_to_weight); prio++) &#123;</span><br><span class="line">		delta = <span class="built_in">abs</span>(sched_prio_to_weight[prio] - weight);</span><br><span class="line">		<span class="keyword">if</span> (delta &gt;= last_delta)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		last_delta = delta;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PRIO_TO_NICE(prio - <span class="number">1</span> + MAX_RT_PRIO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_weight_nice_write_s64</span><span class="params">(struct cgroup_subsys_state *css,</span></span></span><br><span class="line"><span class="function"><span class="params">				     struct cftype *cft, s64 nice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> weight;</span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nice &lt; MIN_NICE || nice &gt; MAX_NICE)</span><br><span class="line">		<span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">	idx = NICE_TO_PRIO(nice) - MAX_RT_PRIO;</span><br><span class="line">	idx = array_index_nospec(idx, <span class="number">40</span>);</span><br><span class="line">	weight = sched_prio_to_weight[idx];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sched_group_set_shares(css_tg(css), scale_load(weight));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __maybe_unused <span class="title">cpu_period_quota_print</span><span class="params">(struct seq_file *sf,</span></span></span><br><span class="line"><span class="function"><span class="params">						  <span class="keyword">long</span> period, <span class="keyword">long</span> quota)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (quota &lt; <span class="number">0</span>)</span><br><span class="line">		seq_puts(sf, <span class="string">"max"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		seq_printf(sf, <span class="string">"%ld"</span>, quota);</span><br><span class="line"></span><br><span class="line">	seq_printf(sf, <span class="string">" %ld\n"</span>, period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* caller should put the current value in *@periodp before calling */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __maybe_unused <span class="title">cpu_period_quota_parse</span><span class="params">(<span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">						 u64 *periodp, u64 *quotap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tok[<span class="number">21</span>];	<span class="comment">/* U64_MAX */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sscanf</span>(buf, <span class="string">"%20s %llu"</span>, tok, periodp) &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	*periodp *= NSEC_PER_USEC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sscanf</span>(tok, <span class="string">"%llu"</span>, quotap))</span><br><span class="line">		*quotap *= NSEC_PER_USEC;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tok, <span class="string">"max"</span>))</span><br><span class="line">		*quotap = RUNTIME_INF;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CFS_BANDWIDTH</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cpu_max_show</span><span class="params">(struct seq_file *sf, <span class="keyword">void</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">seq_css</span>(<span class="title">sf</span>));</span></span><br><span class="line"></span><br><span class="line">	cpu_period_quota_print(sf, tg_get_cfs_period(tg), tg_get_cfs_quota(tg));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">cpu_max_write</span><span class="params">(struct kernfs_open_file *of,</span></span></span><br><span class="line"><span class="function"><span class="params">			     <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">loff_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">tg</span> = <span class="title">css_tg</span>(<span class="title">of_css</span>(<span class="title">of</span>));</span></span><br><span class="line">	u64 period = tg_get_cfs_period(tg);</span><br><span class="line">	u64 quota;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = cpu_period_quota_parse(buf, &amp;period, &amp;quota);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		ret = tg_set_cfs_bandwidth(tg, period, quota);</span><br><span class="line">	<span class="keyword">return</span> ret ?: nbytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cftype</span> <span class="title">cpu_files</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"weight"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.read_u64 = cpu_weight_read_u64,</span><br><span class="line">		.write_u64 = cpu_weight_write_u64,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"weight.nice"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.read_s64 = cpu_weight_nice_read_s64,</span><br><span class="line">		.write_s64 = cpu_weight_nice_write_s64,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_max_show,</span><br><span class="line">		.write = cpu_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.min"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_min_show,</span><br><span class="line">		.write = cpu_uclamp_min_write,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		.name = <span class="string">"uclamp.max"</span>,</span><br><span class="line">		.flags = CFTYPE_NOT_ON_ROOT,</span><br><span class="line">		.seq_show = cpu_uclamp_max_show,</span><br><span class="line">		.write = cpu_uclamp_max_write,</span><br><span class="line">	&#125;,</span><br><span class="line">#endif</span><br><span class="line">	&#123; &#125;	<span class="comment">/* terminate */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> <span class="title">cpu_cgrp_subsys</span> = &#123;</span></span><br><span class="line">	.css_alloc	= cpu_cgroup_css_alloc,</span><br><span class="line">	.css_online	= cpu_cgroup_css_online,</span><br><span class="line">	.css_released	= cpu_cgroup_css_released,</span><br><span class="line">	.css_free	= cpu_cgroup_css_free,</span><br><span class="line">	.css_extra_stat_show = cpu_extra_stat_show,</span><br><span class="line">	.fork		= cpu_cgroup_fork,</span><br><span class="line">	.can_attach	= cpu_cgroup_can_attach,</span><br><span class="line">	.attach		= cpu_cgroup_attach,</span><br><span class="line">	.legacy_cftypes	= cpu_legacy_files,</span><br><span class="line">	.dfl_cftypes	= cpu_files,</span><br><span class="line">	.early_init	= <span class="literal">true</span>,</span><br><span class="line">	.threaded	= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_CGROUP_SCHED */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_cpu_task</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">"Task dump for CPU %d:\n"</span>, cpu);</span><br><span class="line">	sched_show_task(cpu_curr(cpu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class="line"><span class="comment"> * nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class="line"><span class="comment"> * nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class="line"><span class="comment"> * that remained on nice 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The "10% effect" is relative and cumulative: from _any_ nice level,</span></span><br><span class="line"><span class="comment"> * if you go up 1 level, it's -10% CPU usage, if you go down 1 level</span></span><br><span class="line"><span class="comment"> * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class="line"><span class="comment"> * If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class="line"><span class="comment"> * the relative distance between them is ~25%.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sched_prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inverse (2^32/x) values of the sched_prio_to_weight[] array, precalculated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In cases where the weight does not change often, we can use the</span></span><br><span class="line"><span class="comment"> * precalculated inverse to speed up arithmetics by turning divisions</span></span><br><span class="line"><span class="comment"> * into multiplications:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> u32 sched_prio_to_wmult[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">48388</span>,     <span class="number">59856</span>,     <span class="number">76040</span>,     <span class="number">92818</span>,    <span class="number">118348</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>    <span class="number">147320</span>,    <span class="number">184698</span>,    <span class="number">229616</span>,    <span class="number">287308</span>,    <span class="number">360437</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>    <span class="number">449829</span>,    <span class="number">563644</span>,    <span class="number">704093</span>,    <span class="number">875809</span>,   <span class="number">1099582</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>   <span class="number">1376151</span>,   <span class="number">1717300</span>,   <span class="number">2157191</span>,   <span class="number">2708050</span>,   <span class="number">3363326</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>   <span class="number">4194304</span>,   <span class="number">5237765</span>,   <span class="number">6557202</span>,   <span class="number">8165337</span>,  <span class="number">10153587</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>  <span class="number">12820798</span>,  <span class="number">15790321</span>,  <span class="number">19976592</span>,  <span class="number">24970740</span>,  <span class="number">31350126</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>  <span class="number">39045157</span>,  <span class="number">49367440</span>,  <span class="number">61356676</span>,  <span class="number">76695844</span>,  <span class="number">95443717</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span> <span class="number">119304647</span>, <span class="number">148102320</span>, <span class="number">186737708</span>, <span class="number">238609294</span>, <span class="number">286331153</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CREATE_TRACE_POINTS</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>关于本站</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>#我是一名不学无数的伪程序猿</p>]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>schedule</title>
    <url>/schedule/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
